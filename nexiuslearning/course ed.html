<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NexiusLearningCourseFull</title>
    <!--<link rel="stylesheet" href="style.css">-->
    
</head>
<body>
    <h1>A vállalati webfejlesztés alapjai</h1>
    <h2>A fejlesztői környezet kialakítása</h2>
    <h3>Visual Studio Code</h3>
    <p>A Microsoft által fejlesztett IDE (Integrated Development Environment). Kiváló támogatást nyújt a Webes fejlesztésekhez, ingyenes és több ezer kiegészítő érhető el hozzá.</p>

    <h3>Git</h3>
    <p>A Git verziókezelő rendszert Linus Torwalds, a Linux atyja fejlesztette ki. A cél az volt, hogy akár több ezren is zökkenőmentesen tudjanak együtt dolgozni ugyanazon a programon. Mára már ez lett a közös munka egyik alapköve.</p>

    <h2>A Google Chrome és a Visual Studio Code telepítése</h2>

    <h3>Google Chrome</h3>
    <p>Innen tudod letölteni: <a href="https://www.google.com/chrome/">https://www.google.com/chrome/</a></p>

    <p>Jelenleg a vezető böngésző. Asztali és mobil platformokon is a legtöbben ezt használják, ezért érdemes ezzel tesztelni a készülő weboldaladat, vagy webes alkalmazásodat.</p>

    <h3>Visual Studio Code</h3>
    <p>Innen tudod letölteni: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>

    <p>Jelenleg az egyik legjobb szerkesztő program, ha webes projekten dolgozol.</p>

    <h2>A Visual Studio Code szükséges bővitményeinek telepítése</h2>

    <h3>Visual Studio Code Extensions</h3>
    <p>Ha kiegészítőket keresel hozzá, itt találsz: <a href="https://marketplace.visualstudio.com/VSCode">https://marketplace.visualstudio.com/VSCode</a></p>

    <p>Ezekkel a kiegészítőkkel megtaníthatod a VSCode -ot új nyelvekre és technológiákra. Ha már telepítve van a program, akkor azon belül is eléred ezt a listát az "Extensions" gombra kattintva a bal oldalon.</p>

    <h3>Live Server Extension</h3>
    <p>Ezzel a kiegészítővel a mentés után azonnal látod az eredményt a böngészőben.</p>
    <p>Az "Extensions" panelen írd be: "live server".</p>
    <p>A hivatalon letöltő oldal: <a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer"> tovább az oldalra</a></p>

    <h3>Gyorsbillentyűk</h3>
    <p>Mellékeltem egy dokumentumot, ami taralmazza a munka gyorsítására való billentyűkombinációkat. Ezek arra jók, hogy nem kell egérrel a menüből kikeresned a parancsokat, hanem a megfelelő billentyűk lenyomására azok azonnal végrehajtódnak. Tipikusan ilyenek a menük megnyitása, panelek megynyitása vagy elrejtése, változók átnevezése, kód formázása és hasonlók.</p>
    <p>Letöltés: <a href="./resources/keyboard-shortcuts-windows.pdf">Keyboard shortcuts for Windows</a></p>

    <h2>A Node.js telepítése</h2>
    <p>Innen tudod letölteni: <a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>

    <p>Arra való, hogy programokat tudj futtatni Windowson vagy Linuxon, amiket JavaScript nyelven írtál. Erre régebben nem volt lehetőség, az ilyen kódokat csak a böngészőben lehetett futtatni.</p>
        
    <h3>Ellenőrzés</h3>
    <ul>
    <li>Nyiss egy terminál ablakot.</li>
    <li>Program verziójának ellenőrzése: node -v</li>
    <li>Csomagtelepítő ellenőrzése: npm -v</li>
    </ul></p>

    <h2>A Visual Studio Code felhasználói felületének bemutatása</h2>

    <h3>Visual Studio Code user interface</h3>
    <p>A felhasználói felület elemeinek részletes leírását itt találod (angol nyelven): <br>
    <a href="https://code.visualstudio.com/docs/getstarted/userinterface"> https://code.visualstudio.com/docs/getstarted/userinterface</a></p>
        
    <p>A gyorsbillentyűk listáját az oldal alján megtalálod.</p>

    <h2>Szövegszerkesztés a Visual Studio Code segítségével</h2>

    <h3>A videóban használt billentyűkombinációk</h3>
    <ul>
        <li><b>Ctrl+D</b> a szöveg következő előfrodulásának a kijelöléshez adása</li>
        <li><b>F2</b> a szöveg összes előfordulásának kijelölése</li>
        <li><b>Alt+Up/Down</b> az aktív sor mozgatása felfelé vagy lefelé</li>
        <li><b>Alt+Shift+Up/Down</b> az aktív megduplázása felfelé vagy lefelé</li>
    </ul>

    <h2>A Git telepítése</h2>

    <h3>Git</h3>
    <p>Letöltő oldal (Windowshoz): <a href="https://git-scm.com/download/win"> https://git-scm.com/download/win</a></p>

    <p>A Gitet Linus Torvalds fejlesztette, hogy tudja követni a Linux kernel fájljait. A következő célokat tűzte ki:
        <ul>
            <li>Sebesség</li>
            <li>Egyszerűség</li>
            <li>Elágazások (branchek) támogatása</li>
            <li>Nagy projektek gyors és hatékony támogatása (pl. a Linux kernel)</li>
            <li>A teljes elosztottság</li>
        </ul>
    </p>
    
    <h3>Parancsok listája</h3>
    <p>A Git parancssoros használatát fogjuk alkalmazni, ezért mellékeltem egy összefoglalót az elérhető parancsokról. Alább megtalálod.</p>
    <p>Letöltés: <a href="./resources/gitcheatsheet-200324-141746.pdf">Git Cheat Sheet</a></p>

    <h2>Ismerkedés a GitHubbal</h2>
    <h3>GitHub</h3>
    <p>A GitHub címe: <a href="https://github.com/"> https://github.com/</a></p>

    <p>A GitHub egy ingyenes Git szerver. Ide tudják az együtt dolgozó kollégák feltölteni a módosításaikat, és a GitHubon keresztül szinkronizálni a munkájukat.</p>
    <h3>Példák és dokumentáció</h3>
    <ul>
        <li><a href="https://guides.github.com/activities/hello-world/">https://guides.github.com/activities/hello-world/</a></li>
        <li><a href="https://git-scm.com/book/en/v2/GitHub-Account-Setup-and-Configuration">https://git-scm.com/book/en/v2/GitHub-Account-Setup-and-Configuration</a></li>
    </ul>

    <h2>Egy GitHub repository klónozása</h2>

    <h3>Mi az a klónozás?</h3>
    <p>Az a művelet, amikor egy meglévő Git repository tartalmát letöltöm a gépemre, és beállítom, hogy a Git figyelje a mappát.</p>

    <h3>A klónozás lépései</h3>
    <ol>
        <li>A klónozható url kimásolása a GitHub oldaláról.</li>
        <li>Parancssor nyitása a sajátgépen.</li>
        <li>Betallózás a kívánt könyvtárba.</li>
        <li>Klón parancs: git clone < repo_url > </li>
        <li>Létrejön az új mappa, a neve megegyezik a repo nevével.</li>
    </ol>

    <h2>Egy GitHub repository forkolása</h2>
    <h3>Forkolás</h3>
    <p>A forkolás nagyon hasonló a klónozáshoz, csak itt nem én hozom létre a kezdő tartalmat. Valaki másnak kiválasztom a repoját, majd egyszerűen rányomok a Fork gombra.</p>

    <p>Így létrejön egy új repo a saját nevem alatt, de az eredeti repo tartalmával. Innen már én fejlesztem tovább az alkalmazásomat, a módosításaim nem lesznek hatással az eredeti, forkolt repora.</p>

    <h2>A fájlok különböző állapotai a fejlesztés során</h2>
    <h2>Git - fájlok állapotai</h2>
    <h3>Egy fájl négy állapotban lehet a gépünkön:</h3>
    <ul>
        <li><b>Untracked:</b> a Git nem törődik a fájllal. Ez újonnan létrehozott fájloknál jellemző.</li>
        <li><b>Unmodified:</b> a Git követi a fájlt, és mi nem módosítottuk azt. Ez az újonnan letöltött fájlok állapota.</li>
        <li><b>Modified:</b> a Git követi a fájlt, és mi módosítottuk.</li>
        <li><b>Staged:</b> a Git követi a fájlt, mi módosítottuk, és a módosítás be fog kerülni az adatbázisba.</li>
    </ul>

    <h3>Státuszváltások</h3>
    <img src="./resources/git_status.png" alt="gitStatus">
    <h3>A git munkafolyamat tehát így néz ki új fájlok esetében:</h3>
    <ol>
        <li>Létrehozunk egy új fájlt</li>
        <li>git add parancssal hozzáadjuk a staging area-hoz</li>
        <li>git commit paranccsal a staging area tartalmát hozzáadjuk az adatbázishoz</li>
    </ol>
    <h3>Meglévőek esetében pedig így:</h3>
    <ol>
        <li>Módosítjuk a fájlt</li>
        <li>git add parancssal hozzáadjuk a staging area-hoz</li>
        <li>git commit paranccsal a staging area tartalmát hozzáadjuk az adatbázishoz</li>
    </ol>
    <h3>Dokumentáció</h3>
    <ul>
        <li><a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository">https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository</a></li>
        <li>Lokálisan: git status --help</li>
        <li>Lokálisan: git add --help</li>
        <li>Lokálisan: git commit --help</li>
    </ul>

    <h2>Egy fájl állapotának változása a gyakorlatban</h2>

    <h3>Egy fájl életútja a Gitben</h3>
    <p>Részletesen bemutatom a videóban a lehetséges állapotokat egy fájlon. Fontos az állapotok megértése a későbbi munkához, ezért nézd végig.</p>
    <h2>Szinkronizálás</h2>
    <p>Ismerjük a commit parancsot, amivel a változtatásainkat tudjuk véglegesíteni a helyi gépünkön. Ideje ezeket feltölteni egy közös Git szerverre.</p>
    <h2>A közös munka alapját a következő három parancs jelenti:</h2>
    <h3>Fetch - Mi történt mostanában?</h3>
    <p>A git fetch parancs megnézi, milyen változások történtek a szerveren. Ezeket a változásokat le is tölti, de nem nyúl hozzá az aktuális munkánkhoz, a working directory nem változik a hatására. Ezáltal nyugodtan kiadhatjuk bármikor a parancsot, nem lesz kellementlen mellékhatása.</p>
    <h3>Pull - Jöhet minden!</h3>
    <p>A git pull parancs letölti a változásokat a szerverről, és integrálja a saját munkánkba. Fontos különbség a fetch parancshoz képest, hogy a pull nem egy biztonságos parancs, változni fog a mappánk tartalma, ha kiadjuk. Mindig commitoljunk, mielőtt kiadnánk a pull parancsot!</p>
    <h3>Push - Megy a munkám!</h3>
    <p>A git push parancs feltölti a commitjainkat a szerverre. Jegyezzük meg, csak azok a változások mennek fel, amiket commitoltunk! Mielőtt pusholni próbálnánk, kérjük el a szervertől a változásokat a pull paranccsal!</p>
    <h3>Dokumentáció</h3>
    <ul>
        <li><a href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes">https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes</a></li>
        <li>Lokálisan: git fetch --help</li>
        <li>Lokálisan: git pull --help</li>
        <li>Lokálisan: git push --help</li>
    </ul>

    <h2>A kialakított fejlesztői környezet bemutatása</h2>
    <p>Kristóf ügyes volt, belőtte a fejlesztőkörnyeztet.<br>Remélem, a videók és leírások segítettk neked abban, hogy te is olyan légy mint Kristóf :)</p>

    <h1>Egy statikus HTML oldal készítése és publikálása</h1>
    
    <h2>A webfejlesztési projekt megismerése</h2>
    
    <h3>Hogyan születik egy feladat?</h3>
    <p>Ezzel a videóval már három szereplősre bővült a történetünk.</p>
    <p>Ma már egyre ritkábban találkozunk magányos farkasként tevékenykedő fejlesztőkkel. Egyre nagyobbak és egyre bonyolultabbak az alkalmazások, ezért szinte mindig csapatok dolgoznak rajtuk. Ha mégis egyedül dolgozik valaki, annak is az az oka, hogy egy kisebb részfeladatot lát el, amelyeket önállóan is le tud fejleszteni.</p>
    <h3>Tamás (Product Owner)</h3>
    <p>Az ő feladata összefogni a munkát, közvetíteni a megrendelő és a fejlesztők között, felügyelni a teljes munkafolyamat haladását, határidőit.</p>
    <h3>Józsi (Lead Developer)</h3>
    <p>A Tamástól kapott feladatokat részfeladatokra bontja, kiosztja az egyes fejlesztőknek, segíti a munkájukat. Rendszeresen konzultál Tamással.</p>
    <h3>Kristóf (Developer vagy Junior Developer)</h3>
    <p>A kiosztott, jól körülhatárolható feladatokat ő végzi el, rendszeresen egyeztet Józsival, általában heti rendszerességgel. Ha kitartó lesz és szeretnék, pár év múlva belőle is vezető fejlesztő lehet. Majd meglátjuk :)</p>
    
    <h2>1. feladat - A weboldal vázának elkészítése</h2>
    
    <h3>A feladat pontosítása</h3>
    <p>Ha megfigyeled a videót, azt láthatod, hogy a feladat elhangzása után Kristóf rövid szondázó kérdésekkel pontosítja az elhangzottakat. Nem az a lényeg, hogy a vezető érti-e a feladatot, hanem hogy az értse aki el fogja készíteni. Ha valami nem egyértelmű, soha ne szégyelld megkérdezni.</p>

    <h2>A HTML nyelv áttekintése</h2>
    <p>Itt csak röviden összefoglalom, hogy miről is lesz szó.</p>
    
    <h2>A HTML nyelv bemutatása</h2>
    
    <h3>HTML = Hyper Text Markup Language</h3>
    <p>A HTML szabványt aránylag ritkán frissítik.<br>Ennek előnye, hogy ha készítesz valamilyen webes alkalmazást, akkor azt akár évtizedek múlva is meg tudják nyitni egy böngészőben, mivel a szabvány visszafelé kompatibilis a legtöbb esetben.</p>
    <p>Csatolok egy összefoglalót, amin az összes ismert HTML elem megtalálható: <br>
    <a href="./resources/html5_cheat_sheet_tags.png">Letöltés</a></p>
    
    <h2>Egy HTML dokumentum felépítése</h2>
    <h3>HTML5 példaoldalak</h3>
    <p>Sokféleképpen neki lehet állni egy weboldal készítésének, de mindenekelőtt szükséged lesz egy alapvető HTML vázra. Az allábiakban linkelek neked pár oldalt, ahol erre láthatsz példákat:</p>
    <ul>
        <li><a href="https://codepen.io/cPenFrontEnd/pen/yyzQrK">https://codepen.io/cPenFrontEnd/pen/yyzQrK</a></li>
        <li><a href="https://code-maven.com/html-skeleton">https://code-maven.com/html-skeleton</a> </li>
        <li><a href="https://html5bones.com/">https://html5bones.com/</a></li>
    </ul>
    
    <h2>Szövegformázó elemek - header</h2>
    <h3>A címsorok neve h (heading) betűvel kezdődik.</h3>
    <p>A h1 a legnagyobb, utána csökkenő sorrendben egészen a h6-ig.</p>
    <p>Általában a tartalom tagolására használjuk őket. A Google és a többi kereső is kiemelten figyelmbe veszi őket, ha például a címsor szövege nincs összefüggésben az alatta található tartalommal, a keresők hátrébb sorolják az oldalt, úgymond büntetik.</p>
    
    <h2>Szövegformázó elemek - em, strong</h2>
    <!--<h3>EM elem</h3>
    <p>Az <code><em></code> elem a tartalmát, hangsúlyozottan, kiemelt szövegként jeleníti meg.</p>
    <p>Tipp: Jelenleg is szabványos elem, de szebb hatást érhetsz el CSS használatával.</p>
    <h3>STRONG elem</h3>
    <p>The <code> <strong> </code> elem is szövegek formázására való. Ez egy fontosabb szövegrészletet határoz meg.</p>
    <p>Tipp: Szintén igaz rá, hogy szebb hatást érhetsz el CSS használatával.</p>-->
    
    

    <div class="content"><h2>EM elem</h2><p>Az <code>&lt;em&gt;</code> elem a tartalmát, hangsúlyozottan, kiemelt szövegként jeleníti meg.</p><p><b>Tipp:</b> Jelenleg is szabványos elem, de szebb hatást érhetsz el CSS használatával.</p><h2>STRONG elem</h2><p>The <code>&lt;strong&gt;</code> elem is szövegek formázására való. Ez egy fontosabb szövegrészletet határoz meg.</p><p><b>Tipp:</b> Szintén igaz rá, hogy szebb hatást érhetsz el CSS használatával.</p></div>

    <h2>Blokk és inline elemek</h2>

    <div class="content"><h2>Blokk szintű elemek</h2><p>A blokk szintű elemek mindig új sorban kezdődnek, és akkor sem kerülnek másik elem mellé, ha amúgy elférnének tőle. Azaz előttük utánuk sortörés van és általában nagyobb margóval rendelkeznek, távolabb vannak a többi elemtől.</p><h2>Inline elemek</h2><p>Mivel minden elem ami nem blokk szintű inline, ezért ezeket külön nem sorolnám fel. Amit meg kell róluk jegyezni, hogy sorban egymás mellé teszi őket a böngésző, egészen addig amíg kiférnek. Ha már nem, akkor egy új sorban folytatja a megjelenítésüket.</p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements" rel="noopener noreferrer" target="_blank">Blokk szintű elemek felsorolása</a></p></div>

    <h2>Az elkészített weboldal váznak a bemutatása</h2>

    <div class="content"><h2>Mit látunk a videón?</h2><p>Amikor egy feladattal készen vagy, főleg kezdőként stresszes tud lenni a bemutatása. Ilyenkor még bizonytalanabb az ember, ráadásul mindannyiunknak más a kritikatűrő képessége.</p><p>Azt szokták javasolni, hogy legyünk nyitottak a jobbító szándékú megjegyzésekre. A vezető is volt kezdő, akinek be kell számolnunk a munkánkról. Nem az a célja, hogy magbántson minket, hanem hogy a közös munka sikeres legyen. Ha ezeket az alapvető dolgokat mindkét részről betartják, akár ilyen jó hangulatú is lehet egy demo, mint ahogy a videón látod.</p></div>

    <h2>2. feladat - A weboldal képeinek kihelyezése</h2>
    <div class="content"><p>Ahhoz, hogy Kristóf sikeresen elvégezze a feladatot, új ismeretekre lesz szüksége.</p><p>A képek kezelése mellett, nem árt ha tudja kezelni a Chrome DevTools-t, ahol le tudja ellenőrizni a munkáját és megkeresheti az esetleges hibák forrását is.</p></div>

    <h2>A Chrome DevTools használata</h2>
    <div class="content"><h2>Chrome DevTools</h2><p>Megnyitás:
    <kbd>F12</kbd></p><p>A Chrome DevTools segít neked abban, hogy át tudd tekinteni az alkalmazásod felépítését, vagy mag tudd keresni a hibákat. Ha hibásan működik valami, semmiképp sem szabad megijedni. Meg kell nyitni a megfelelő fejlesztőeszközt és megkeresni a hiba forrását. A hibákból mindig tanulunk valamit, így azok hasznosak a számunkra.</p><p><b>A letöltéseknél megtalálod az alapvető panelek bemutatását:</b></p><div class="download"><div class="download-content"><div class="download-title text-truncate">chrome_devtools.png</div><div class="download-size">333 kB</div></div><div class="download-button"><a class="button" href="./resources/chrome_devtools.png" target="_blank" role="button">Letöltés</a></div></div></div>

    <h2>Ismerkedés az URL fogalmával</h2>

    <div class="content"><h2>URL - Uniform Resource Locator</h2><p>A tartalmak az interneten bárhol lehetnek. Hogyan találjuk meg őket? Ehhez kell az URL, ha ismerjük az adott oldal vagy kép vagy film vagy bámi URL-jét, akkor a böngészőbe beírva meg tudod nézni vagy le tudod tölteni.</p><p>Fontos, hogy minden erőforrásnak legyen egyedi azonosítója. Erre való az URL.</p><h2>Az URL részei</h2><p>Egy példa:
        <a class="text-truncate" href="https://www.training360.com/tanfolyami-naptar" rel="noopener noreferrer" target="_blank">https://www.training360.com/tanfolyami-naptar</a></p><ul><li>A <b>https</b> a használandó
        <a href="https://hu.wikipedia.org/wiki/Protokoll_(informatika)" target="_blank" title="Protokoll (informatika)">protokoll</a>. A protokoll neve után kettőspont (:) írandó.</li><li>A <b>training360.com</b> a célgép
        <a href="https://hu.wikipedia.org/wiki/Tartom%C3%A1nyn%C3%A9v" target="_blank" title="Tartománynév">tartományneve</a>. Ez elé két perjel (//) írandó.</li><li>A <b>443</b> a célgép azon hálózati
        <a href="https://hu.wikipedia.org/w/index.php?title=Portsz%C3%A1m&amp;action=edit&amp;redlink=1" target="_blank" title="Portszám (a lap nem létezik)">portszáma</a>, amin kérésünket várja; ez elé kettőspont (:) írandó. Ezt a részt gyakran teljesen elhagyhatjuk, például esetünkben a
        <a href="https://hu.wikipedia.org/wiki/HTTP#Biztons%C3%A1gos_HTTP" target="_blank" title="HTTP">HTTPS</a> protokoll alapértelmezett portszáma a 443.</li><li>A <b>/tanfolyami-naptar</b> a kért elérési út a célgépen. Ez a rész mindig a perjellel (/) kezdődik.</li></ul></div>

    <h2>Listák használata</h2>

    <div class="content"><h2>Listák</h2><p>Felsorolások megjelenítésére használhatod.</p><h2>UL - Unordered List</h2><p>Elem: <code>&lt;ul&gt;&lt;/ul&gt;</code><br>Lista elemei: <code>&lt;li&gt;&lt;/li&gt;</code></p><h2>OL - Ordered List</h2><p>Elem: <code>&lt;ol&gt;&lt;/ol&gt;</code><br>Lista elemei: <code>&lt;li&gt;&lt;/li&gt;</code></p><h2>Dokumentáció</h2><ul><li><a class="text-truncate" href="https://www.w3schools.com/tags/tag_ul.asp" target="_blank">https://www.w3schools.com/tags/tag_ul.asp</a></li><li><a class="text-truncate" href="https://www.w3schools.com/tags/tag_ol.asp" target="_blank">https://www.w3schools.com/tags/tag_ol.asp</a></li><li><a class="text-truncate" href="https://www.w3schools.com/tags/tag_dl.asp" target="_blank">https://www.w3schools.com/tags/tag_dl.asp</a></li></ul></div>

    <h2>Képek elhelyezése a weboldalon</h2>

    <div class="content"><h2>Image elem</h2><p>Elem: <code>&lt;img&gt;</code></p><p>Képek megjelenítésére való. <b>Self closed</b> elem, azaz a végére <b>nem kell</b> másik <code>&lt;/img&gt;</code> tag. Az <code>src</code> attribútum adja meg, hogy honnan kerüljön a kép betöltésre.</p><p>A képek méretezése és alakítása már kicsit bonyolultabb dolog, amikor a CSS formázásokat vesszük, majd kitérek rá.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/tags/tag_img.asp" target="_blank">https://www.w3schools.com/tags/tag_img.asp</a></p></div>

    <h2>Linkek elhelyezése a weboldalon</h2>

    <div class="content"><h2>Anchor elem</h2><p>Elem: <code>&lt;a&gt;&lt;/a&gt;</code></p><p>Kötelező attribútumok:</p><ul><li><code>href</code>: az URL, ahová kattintás után jutsz.</li></ul><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/tags/tag_a.asp" target="_blank">https://www.w3schools.com/tags/tag_a.asp</a></p></div>

    <h2><div class="content"><h2>Anchor elem</h2><p>Elem: <code>&lt;a&gt;&lt;/a&gt;</code></p><p>Kötelező attribútumok:</p><ul><li><code>href</code>: az URL, ahová kattintás után jutsz.</li></ul><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/tags/tag_a.asp" target="_blank">https://www.w3schools.com/tags/tag_a.asp</a></p></div></h2>

    <div class="content"><p>Az XML jellegű struktúrák lényege, hogy az elemeket egymásba lehet ágyazni. Így már beszélhetünk szülő és gyermek elemekről, aszerint, hogy melyik elem melyikbe van beágyazva.</p><h2>Dokumentáció:</h2><p><a class="text-truncate" href="https://www.w3schools.com/html/html_elements.asp" target="_blank">https://www.w3schools.com/html/html_elements.asp</a></p></div>

    <h2>A képekkel kiegészített weboldal bemutatása</h2>

    <div class="content"><p>Kristóf ügyes volt, szépen halad a webfejlesztővé válás rögös, de izgalmas útján.</p></div>

    <h2>3. feladat - Az étlap elkészítése</h2>
    <div class="content"><p>Az étlapot most táblázatos formában kell elkészítenie Kristófnak.</p><p>Lenne rá más megoldás is, de így legalább meg tudsz te is ismerkedni a táblázatokkal.</p></div>

    <h2>Táblázat készítése</h2>
    <div class="content"><h2>Table elem</h2><p>Elem: <code>&lt;table&gt;&lt;/table&gt;</code></p><p>A táblázatokat strukturált adatokhoz használjuk. Vannak sorok, oszlopok, és általában ugyanazok az adatok szerepelnek minden sorban.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/html/html_tables.asp" target="_blank">https://www.w3schools.com/html/html_tables.asp</a></p></div>

    <h2>Egy táblázat részei</h2>

    <div class="content"><p>Egy táblázat olyan mint egy Excel tábla. Sorokból és oszlopokból áll, ezek találkozásánál vannak az adatcellák. Mindegyikhez vannak külön HTML elemek:</p><p>Fejléc: <code>&lt;thead&gt;&lt;/thead&gt;</code><br>Sor: <code>&lt;tr&gt;&lt;/tr&gt;</code><br>Fejléc cella: <code>&lt;th&gt;&lt;/th&gt;</code><br>Cella: <code>&lt;td&gt;&lt;/td&gt;</code></p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/tags/tag_table.asp" target="_blank">https://www.w3schools.com/tags/tag_table.asp</a></p></div>

    <h2>Sorok és oszlopok összevonása</h2>

    <div class="content"><h2>Rowspan és Colspan</h2><p>A nevükből adódóan sorok és oszlopok összevönására valók. Ezek attribútumok, tehát nem önálló elemek, hanem a <code>td</code> vagy a <code>th</code> elem tulajdonságai.</p><h2>Dokumentáció</h2><ul><li><a class="text-truncate" href="https://www.w3schools.com/tags/att_td_rowspan.asp" target="_blank">https://www.w3schools.com/tags/att_td_rowspan.asp</a></li><li><a class="text-truncate" href="https://www.w3schools.com/tags/att_td_colspan.asp" target="_blank">https://www.w3schools.com/tags/att_td_colspan.asp</a></li></ul></div>

    <h2>Az elkészített oldal publikálása és megosztása</h2>

    <div class="content"><h2>Publikálás</h2><p>Ahhoz, hogy az emberek meg tudják nézni a webalkalmazásodat, szerverre van szükséged. Ha ilyennel nem rendelkezel, használhatsz felhő szolgáltatást is, sok cég kínál ingyenes tárhelyet. Mi a github pages nevűt használjuk a videóban, de lényeges különbség nincs közöttük abból a szempontból, hogy fel kell tölteni a fájlokat és rájuk mutatni egy URL-lel, ezután az emberek elérik az alkalmazást.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://help.github.com/en/github/working-with-github-pages" target="_blank">https://help.github.com/en/github/working-with-github-pages</a></p></div>

    <h2>Az étlappal bővített weboldal bemutatása</h2>

    <p>Kristóf már magabiztosan demózza a munkát.</p>

    <h2>Az elkészített weboldal átadása</h2>
    <p>Végül a dolgok visszatérnek oda, ahonnan indultak, Józsinak is be kell mutatni a projekt állását Tamásnak.</p>

    <h1>A CSS alapjai</h1>

    <h2>A megjelenítéssel kapcsolatos követelmények</h2>

    <p>Nem elég, ha egy alkalmazás jól működik. Az appokat legtöbbször nem a profi működés, hanem a jó megjelenés adja el. Ez így van a mi projektünkkel is.</p>

    <h2>1. feladat - A weboldal szövegeinek formázása</h2>

    <div class="content"><p>Kristófnak új ismereteket kell elsajátítania.</p><p>Az oldalak formázásához külön nyelvet használnak, CSS a neve.</p></div>

    <h2>A CSS áttekintése</h2>

    <div class="content"><h2>CSS - Cascading Style Sheets (Kaszkádolt stíluslap)</h2><p>Ahhoz, hogy megértsük, milyen okból kifolyólag lett szükség a CSS-re, elég magának a HTML nyelvnek a történetét ismernünk. A HTML arra való, hogy egyszerű tartalmat tegyünk közzé a neten. Régen, amikor az internet nem volt ilyen széles körben elterjedt, csak kutatóintézetek, egyetemek használták, ezzel nem is volt probléma. Azonban ahogy az internet egyre nagyobb nyilvánosságot kapott, és ma már bárkinek lehet honlapja, egyre nagyobb lett az igény az oldalak egyedibbé/egyénibbé tételére.</p><p>Emiatt az újabb HTML szabványokba egyre több és több olyan tulajdonságot tettek, melyek a formázásra, megjelenésre vonatkoztak. Idővel aztán a HTML fájlunk több formázó utasítást, mint taget tartalmazott. Ezáltal a kódunk mérete jócskán megnőtt, és átláthatatlanabb lett. Így felmerült az igény, hogy a tartalmi és a megjelenésre vonatkozó rész el legyen különítve egymástól. Ezért létrehozták a CSS szabványt. Az oldalunk tartalma maradt továbbra is a HTML fájlban, azonban minden formázást CSS segítségével valósítunk meg. (Lehetőleg, ha nem is kötelező jelleggel, de külön fájlban.)</p><p>Tehát a CSS arra szolgál, hogy megadjuk weblapjaink stílusát, beleértve a designt, az elrendezést, a különböző médiákhoz igazodó megjelenítést. Stílus definiálható magában a HTML állományban, de lehet külső állományban is. Az utóbbit használva könnyebb áttekinteni, kezelni, és hasznos a közös munkánál is.</p></div>

    <h2>Az Inline stílusok</h2>

    <div class="content"><h2>Inline CSS</h2><p>Attribútum: <code>style</code></p><p>Ahogy a nevük is mutatja, az inline stílusokat a sorban, a HTML elemünk attribútumaként adjuk meg.</p><p>Így gyorsan testre tudjuk szabni az elemeket, de nehéz lesz karbantartani a stílusokat, ha valami változik, az összes elemben feül kell írni egyesével.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/css/css_howto.asp" target="_blank">https://www.w3schools.com/css/css_howto.asp</a></p></div>

    <h2>Egy CSS stíluslap elkészítése</h2>

    <div class="content"><h2>CSS stíluslap</h2><p>A CSS stíluslap egy külön fájl, amiben leírhatod az oldal megjelenését.</p><p>Mivel a site builder és a designer legtöbbször nem ugyanaz a személy, így praktikus, ha a stílusok külön fájlokban vannak leírva.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/css/css_intro.asp" target="_blank">https://www.w3schools.com/css/css_intro.asp</a></p></div>

    <h2>A CSS szintaxisa és felépítése</h2>

    <div class="content"><h2>Egy tipikus CSS direktíva felépítése</h2><p>A szelektor mondja meg, hogy melyik elemre legyen a parancs alkalmazva. A deklarációk egy tulajdonság nevéből és az értékéből állnak, pontos vesszővel elválasztva egymástól.</p><p class="img-container"><img src="./resources/css_directive.gif" alt="CSS direktíva felépítése"></p></div>

    <h2>Képpontok - px</h2>

    <div class="content"><h2>PX - képpont</h2><p>Mivel a monitor képe képpontokból - pixelekből áll össze, kézenfekvő, hogy ebben adjuk meg a dolgok méretét. Viszont gondolni kell arra is, hogy nem minden monitoron, kijelzőn vannak egyforma távolságban egymástól a képpontok.</p></div>

    <h2>A különböző betűtípusok</h2>

    <div class="content"><h2>A <code>font-family</code> attribútum</h2><p>A karakterek megjelenése betűtípus fájlokban van meghatározva. Például ilyenek a .ttf fájlok Windows operációs rendszer esetén.</p><p>Igen ám, de mi van akkor, ha olyan betűtípust szeretnék használni, ami nincs telepítve az adott számítógépen? Ennek a problémának a megoldására van a "fallback system", ami azt jelenti, hogy több betűtípust is megadhatsz felsorolás szerűen, és ha az egyiket nem találja a böngésző, akkor megpóbálkozik a következővel.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/cssref/pr_font_font-family.asp" target="_blank">https://www.w3schools.com/cssref/pr_font_font-family.asp</a></p></div>

    <h2>Saját betűkészletek használata</h2>

    <div class="content"><h2>@font-face</h2><p>Ezzel a CSS utasítással új betűtípust tudsz meghatározni. Meg kell adnod a nevét és a helyet, ahonnak a böngésző be tudja tölteni. Nem fontos, hogy a név egyezzen a betűtípus fájl nevével, érdemes rövidebb, egyszerűbb nevet adni neki.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/cssref/css3_pr_font-face_rule.asp" target="_blank">https://www.w3schools.com/cssref/css3_pr_font-face_rule.asp</a></p></div>

    <h2>Szövegformázás</h2>

    <div class="content"><h2>Szövegek formázása</h2><ul><li><code>font-family</code>: a betűtípus beállítása</li><li><code>font-style</code>: <code>normal</code>|<code>italic</code> (normál vagy dőlt)</li><li><code>font-weight</code>: <code>normal</code>|<code>bold</code> vagy <code>100</code> - <code>900</code>-ig számokkal megadva a betűvastagság</li><li><code>font-size</code>: <code>px</code>|<code>em</code>|<code>rem</code>|<code>vw</code>|<code>%</code> a betűméret megadása</li><li><code>color</code>: a betűszín</li></ul><h2>Dokumentáció</h2><ul><li><a class="text-truncate" href="https://www.w3schools.com/css/css_font.asp" target="_blank">https://www.w3schools.com/css/css_font.asp</a></li><li><a class="text-truncate" href="https://www.w3schools.com/css/css_font_style.asp" target="_blank">https://www.w3schools.com/css/css_font_style.asp</a></li><li><a class="text-truncate" href="https://www.w3schools.com/css/css_font_size.asp" target="_blank">https://www.w3schools.com/css/css_font_size.asp</a></li></ul></div>

    <h2>Külső betűtípusok használata - Google Fonts</h2>

    <div class="content"><h2>Google Fonts</h2><p>URL: <a class="text-truncate" href="https://fonts.google.com/" target="_blank">https://fonts.google.com/</a></p><p>Egy olyan, közel 1000 ingyenes betűtípust tartalmazó válogatás, aminek nagyon könnyű a használata.</p></div>

    <h2>A formázott szöveggel ellátott weboldal bemutatása</h2>

    <p>Mivel részfeladatról van szó, itt Kristóf csak Józsival beszéli meg a részleteket.</p>

    <h2>2. feladat - A weboldal hátterének és elrendezésének kialakítása</h2>

    <div class="content"><p>Sosem könnyű eldönteni, hogyan is nézzen ki egy alkalmazás. Hol van a határ a prakrikusság és a szép megjelenés között?</p><p>Ebben a Story-ban a színekkel, hátterekkel és az elrendezéssel fog trükközni Kristóf barátunk.</p></div>

    <h2>Ismerkedés az id-val</h2>

    <div class="content"><h2>ID</h2><p>Jele a CSS-ben: <code>#</code></p><p>A HTML szabvány szerint minden elemnek adhatsz egyedi azonosítót az oldalon, ez az ID. Ezt az ID-t a CSS fájlban, amikor kiválasztasz egy elemet, kettőskereszttel jelölheted.</p><p>Ha például az id az, hogy <b>head</b>, akkor a szelektora az lesz a CSS-ben, hogy <code>#head</code>.</p><p>Fontos korlátozás, hogy egy ID-t csak egyszer használhatsz, mert az egyértelműen tartozik egy elemhez.</p><p>Az alábbi animáción követheted, ahogyan ID alapján megformázom a div-eket:</p><p><img class="shadow" src="./resources/css_selector_id.gif" alt="CSS formázás ID alapján"></p></div>

    <h2>A HTML elemcsoportok formázása osztályok segítségével</h2>

    <div class="content"><h2>Class selector</h2><p>Jele: <code>.</code></p><p>Elemek kiválasztása az osztály alapján.</p><p>Nézd meg az alábbi példát, ahol a diveket az osztály alapján választom ki. Mivel mind a kettő ugyanahhoz az osztályhoz tartozik, ha az osztályra adom meg a stílusokat, automatikusan mind a kettő megkapja őket:</p><p><img class="shadow" src="./resources/css_selector_class.gif" alt="CSS formázás osztályokkal"></p></div>

    <h2>Tartalomtagolás div és span segítségével</h2>

    <div class="content"><h2>DIV</h2><p>A <code>&lt;div&gt;</code> egy osztást (division) hoz létre az oldalon. Blokk szintű elem és alapból nagyon kevés beállítása van, ezért a designerek is szeretnek vele játszani.</p><h2>SPAN</h2><p>A div-től eltérően nem blokk, hanem inline elem. Leginkább akkor hasznos, ha egy szövegből egy részletet szeretnél másképp megformázni.</p><h2>Dokumentáció</h2><ul><li><a class="text-truncate" href="https://www.w3schools.com/tags/tag_div.ASP" target="_blank">https://www.w3schools.com/tags/tag_div.ASP</a></li><li><a class="text-truncate" href="https://www.w3schools.com/tags/tag_span.asp" target="_blank">https://www.w3schools.com/tags/tag_span.asp</a></li></ul></div>

    <h2>A HTML elemek formázása - margin, border, padding</h2>

    <div class="content"><h2>CSS Box Model - hajtogassunk dobozt</h2><p>Az úgynevezett doboz modell azt mutatja meg, hogyan épülnek fel az elemek, és hogyan helyezkednek el egymáshoz képest a böngészőben.</p><h3>Margin</h3><p>Kívülről befelé haladva az első eleme a box-modelnek a <code>margin</code>. Ez nem része konkrétan az elemnek, ez az elhagyás az elem körül. Magyarul margónak is nevezhetjük. A legtöbb elem rendelkezik alapértelmezett marginnal, ezt tudjuk a saját CSS szabályainkkal felülbírálni.</p><p>Meg lehet adni oldalanként vagy egy utasítással is:</p><ul><li><b>oldalankénti megadás: <code>margin-top, margin-right, margin-bottom, margin-left</code></b></li><li><b>megadás egyben: <code>margin: top right bottom left</code></b></li><li><b>megadás páronként: <code>margin: top-bottom right-left</code></b></li></ul><p>Az alábbi példában néhány elem <code>margin</code> tuladonságát módosítom:</p><p><img class="shadow" src="./resources/css_box_margin.gif" alt="Margin"></p><h3>Border</h3><p>A következő a <code>border</code>, vagy szegély. Ha nem adjuk meg, akkor a vastagsága 0px lesz.
        <strong>Az elem méretét növeli a border vastagsága, azaz ha 2px a border, akkor az elem minden irányban 4 pixellel szélesebb lesz.</strong></p><p>Megadása:</p><ul><li><b>egy utasítással: <code>border: style width color;</code></b></li><li><b>sarkak kerekítése: <code>border-radius: 10px;</code></b></li><li><b>oldalanként: <code>border-left: style width color;</code></b></li><li><b>tulajdonságonként: <code>border-style, border-width, border-color</code></b></li></ul><p>A példában egy <code>div</code> elemet formázok:</p><p><img class="shadow" src="./resources/css_box_border.gif" alt="Border"></p><h3>Padding</h3><p>Itt már az elemen belül járunk, úgy is mondhatnám, hogy átléptük a határt (border). Tehát ez már az elem belső padkája, az elemen belül ennyivel beljebb kezdődik a tartalom.
        <strong>Az elem méretét akkor növeli, ha a <code>box-sizing: border-box;</code> nincs beállítva.</strong></p><p>Megegyezik a <code>margin</code> megadásával, ezért egy példát mutatok inkább:</p><p><img class="shadow" src="./resources/css_box_padding.gif" alt="Padding"></p><h2>Dokumentáció</h2><ul><li><a class="text-truncate" href="http://www.w3schools.com/css/css_margin.asp" rel="nofollow" target="_blank">Margin</a></li><li><a class="text-truncate" href="http://www.w3schools.com/css/css_border.asp" rel="nofollow" target="_blank">Border</a></li><li><a class="text-truncate" href="http://www.w3schools.com/css/css_padding.asp" rel="nofollow" target="_blank">Padding</a></li></ul></div>

    <h2>A HTML elemek formázása - box-shadow</h2>

    <div class="content"><h2>Box-shadow</h2><p>A <code>box-shadow</code> az elemet körülvevő vetett árnyék. A CSS3 hozta be. Az alábbi séma szerint lehet megadni, amit a videóban részletesen elmagyarázok:</p><p><code>box-shadow: none|h-shadow v-shadow blur spread color|inset|initial|inherit;</code></p><p>A megértést az alábbi példa is segíti:</p><p><img class="shadow" src="./resources/css_box_shadow.gif" alt="CSS box-shadow"></p><h3>Dokumentáció</h3><p><a href="http://www.w3schools.com/cssref/css3_pr_box-shadow.asp" rel="nofollow" target="_blank">Box shadow</a></p></div>

    <h2>Relatív mértékegységek használata</h2>

    <div class="content"><h2>%, em, rem</h2><ul><li><code>%</code>: a méretet a befogadó elem méretének százalékában adja meg.</li><li><code>em</code>: a betűméret, 1 esetén megegyezik, de például az 1.5 másfélszeres.</li><li><code>rem</code>: root em, nem a szülő elem em-jét nézi, hanem a <code>&lt;html&gt;</code> elemét.</li></ul></div>

    <h2>Láthatóság és megjelenítés</h2>

    <div class="content"><h2>Display vs. visibility</h2><h3><code>display</code></h3><p>A <code>display</code> tulajdonság az elem megjelenítését befolyásolja. Azt mondja meg, hogy a böngészőnek figyelembe kell-e vennie az elemet az oldal megjelenítésekor, és ha igen, akkor hogyan.</p><p>Használata: <code>display: inline|block|flex|inline-block|none;</code></p><p>A <code>none</code> érték azt írja elő, hogy nem kell megjeleníteni az elemet. A megjelenített oldalon a böngésző nem foglal helyet az elemnek, ezért a felhasználó nem láthatónak érzékeli.</p><h3><code>visibility</code></h3><p>Ezzel szemben a <code>visibility</code> csak a láthatóságot módosítja. Tehát ha elrejtjük vele az elemet, akkor a helyfoglalás megmarad.</p><p>Használata: <code>visibility: visible|hidden|collapse|initial|inherit;</code></p><h3>A példában mindkettőt megmutatom:</h3><p class="margin-top-1"><img class="shadow" src="./resources/css_display_vs_visibility.gif" alt="Display vs. visibility"></p><h3>Dokumentáció</h3><p><a class="text-truncate" href="http://www.w3schools.com/css/css_display_visibility.asp" rel="noopener noreferrer" target="_blank">http://www.w3schools.com/css/css_display_visibility.asp</a></p></div>

    <h2>Az egyes HTML elemek pozicionálása</h2>

    <div class="content"><h2>Position - helyezkedjünk kicsit!</h2><p>Azt adhatjuk meg vele, hogyan legyen kalkulálva az elem pozíciója.</p><ul><li><code>position: static;</code> ez az alapértelmezett, a helyzet a többi elemtől függ.</li><li><code>position: relative;</code> a helyzet a saját normál pozíciótól függ.</li><li><code>position: fixed;</code> a böngészőablakhoz képest helyezkedik el.</li><li><code>position: absolute;</code> a helyzet az első nem static elemtől függ.</li></ul><p>Egy jó példa a fentiekre:</p><p><img class="shadow" src="./resources/css_display_position.gif" alt="HTML elemek pozicionálása"></p></div>

    <h2>A színek megadásának különböző módjai - RGBA</h2>

    <div class="content"><h2>RGB (red, green, blue) színmegadás</h2><p>A monitor három alapszínből keveri ki az összeset többit.<br><strong>Red (vörös), Green (zöld), Blue (kék)</strong></p><p>A színek intenzitását egy 256-os skálán lehet megadni, 0-255-ig. (2 a 8-adikon).<br>Összesen 256 * 256 * 256 színnel gazdálkodhatunk, azaz több mint 16 millióval.</p><p>Példul:</p><ul><li>vörös: <code>rgb(255, 0, 0)</code></li><li>zöld: <code>rgb(0, 255, 0)</code></li><li>kék: <code>rgb(0, 0, 255)</code></li><li>sárga: <code>rgb(255, 255, 0)</code></li><li>fehér: <code>rgb(255, 255, 255)</code></li><li>fekete:&nbsp; <code>rgb(0, 0, 0)</code></li></ul><h2>Átlátszóság (alpha csatorna)</h2><p>Ha azt szeretnénk, hogy az átlátszóság mértékét is tudjuk állítani a színnel együtt, akkor egy negyedik értéket is megadunk: ez az alpha csatorna, ami 0-1 között lehet. Ekkor <code>rgba</code> lesz a zárójel előtt, például így:</p><p><code>rgba(255, 128, 44, 0.2)</code></p><p>Ez csak minimálisan látszik át:<br><code>rgba(255, 128, 44, 0.95)</code></p><p>Ez pedig egyáltalán nem látszik, tejlesen átlátszó:<br><code>rgba(255, 128, 44, 0)</code></p><h2>Példák</h2><p class="margin-top-1"><img class="shadow" src="./resources/css_colors_rgb.gif" alt="CSS színek: RGB és RGBA"></p></div>

    <h2>A színek megadásának különböző módjai - HEX</h2>

    <div class="content"><h2>Hexadecimal (a 16-os számrendszer szépségei)</h2><p>Gyakorlatilag a logikája megegyezik az RGB színmegadással, csak nem tízes, hanem tizenhatos számrendszerben adjuk meg a színek fedettségét. Az öreg rókák szeretik, mert kevesebbet kell írni és ezt szokták meg. :)</p><p>Pár átváltás a kettő között:</p><ul><li><code>rgb(255, 255, 255)</code> = <code>#FFFFFF</code> fehér</li><li><code>rgb(66, 134, 244)</code> = <code>#4286f4</code></li><li><code>rgb(244, 92, 66)</code> = <code>#f45c42</code></li><li><code>rgb(0, 0, 0)</code> = <code>#000000</code> fekete</li></ul><p><strong>Az alábbi példában a bal oldalt figyeld, látszik a kettő egymás alatt!</strong></p><p><img class="shadow" src="./resources/css_colors_hexadecimal.gif" alt="CSS színek: hexadecimális"></p><p><a href="https://www.google.hu/search?q=rgb+to+hex&amp;oq=rgb+to+hex&amp;aqs=chrome..69i57.2103j0j7&amp;sourceid=chrome&amp;ie=UTF-8" rel="nofollow" target="_blank">Próbáld ki te is!</a></p></div>

    <h2>A weboldal hátterének formázása</h2>

    <div class="content"><h2>Background</h2><p>A <code>background</code> az, amivel az oldal vagy bizonyos elemek hátterét tudod formázni.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/cssref/css3_pr_background.asp" target="_blank">https://www.w3schools.com/cssref/css3_pr_background.asp</a></p></div>

    <h2>A stílusokkal formázott háttér és elrendezés bemutatása</h2>

    <p>Ez húzós volt, de Kristóf vette az akadályt.<br>Remélem te is jól haladtál!</p>

    <h2>3. feladat - A weboldal megjelenésének finomhangolása</h2>

    <p>Az alkalmazás olyan, mint a ház, azt mondják soha sem készül el teljesen.<br>Az utolsó fázisban finomhangoljuk a megjelenést és mélyebben megismerkedünk a CSS szelektorokkal.</p>
    
    <h2>A szelektorok vizsgálatának előkészítése</h2>

    <p>Ahhoz, hogy tudjuk tesztelni a szelektorokat, előkészítem a HTML forrást.</p>

    <h2>A többszörösen egymásbaágyazott szelektorok</h2>

    <div class="content"><h2>Specify szelektor</h2><p>Előfordul, hogy egy szelektorral nem tudod pontosan kijelölni az elemet. Ekkor pontosabban kell rámutatnod az elemre, pontosabban kell specifikálnod. Egyszerre több szelektort használsz, például:</p><p><code>a.menu-link:hover</code></p><p>vagy durvábban</p><p><code>input.form-control[type=email]:focus</code></p><p><strong>A szelektort egybeírjuk, ha egy elemre vagy elem-csoportra vonatkozik.</strong></p><p class="img-container"><img src="./resources/css_selector_specify.gif" alt="Specify CSS szelektor"></p><h2>Egymásba ágyazott elemek kiválasztása</h2><p>Van, hogy csak egy bizonyos elemen belül szeretnél dolgozni. Ekkor először a szülőt kell megadnod. Például a login azonosítójú formon belüli összes input elem megadása:</p><p><code>form#login input</code></p><p>&gt; jel csak a közvetlen gyerekeket jelöli, az unokákat már nem ;)</p><p><code>form#login &gt; input</code></p><p>A példában először az egyik, majd a másik formban dolgozom:</p><p class="img-container"><img src="./resources/css_selector_nested.gif" alt="Egymásba ágyazott elemek kiválasztása CSS szelektorokkal"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors" rel="nofollow" target="_blank">CSS szelektorok</a></p></div>

    <h2>Az attribútum szelektor</h2>

    <div class="content"><h2>Attribute szelektor</h2><p>Az elemet valamilyen tulajdonsága alapján választja ki. A tulajdonság nevét és értékét egyenlőségjellel elválasztva szögletes zárójelek között adjuk meg. Például:</p><p><code>[type='button']</code></p><p>Ha nem adunk meg értéket, akkor azokat az elemeket jelöli ki, ahol a tulajdonság létezik. Például:</p><p><code>[disabled]</code></p><p><b>Jele:</b>
        <code>[ ]</code><br><b>Előnye:</b> külön formázást adhatunk meg egy elemnek eltérő tulajdonságok esetén.<br><b>Hátránya:</b> böngésző támogatása nem teljesen egységes.</p><p><img class="shadow" src="./resources/css_selector_attr.gif" alt="Attribute CSS szelektor"></p><h2>Dokumentáció</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS" rel="nofollow" target="_blank">CSS: Cascading Style Sheets</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors" rel="nofollow" target="_blank">CSS szelektorok</a></li></ul></div>

    <h2>Szövegek helyettesítése a szelektorokban</h2>
    <div class="content"><h2>Szövegek helyettesítése CSS szelektorokban</h2><h3>[attribute^=value]</h3><p>Példa:
        <code>a[href^="https"]</code><br>Kiválasztja az összes olyan elemet, aminek az adott attribútuma a megadott szöveggel kezdődik.</p><h3>[attribute$=value]</h3><p>Példa:
        <code>a[href$=".pdf"]</code><br>Kiválasztja az összes olyan elemet, aminek az adott attribútuma a megadott szöveggel végződik.</p><h3>[attribute*=value]</h3><p>Példa:
        <code>a[href*="training360"]</code><br>Kiválasztja az összes olyan elemet, aminek az adott attribútuma a megadott szöveget bárhol tartalmazza.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/cssref/css_selectors.asp" target="_blank">https://www.w3schools.com/cssref/css_selectors.asp</a></p></div>

    <h2>Pszeudo szelektorok</h2>

    <div class="content"><h2>Pseudo szelektorok</h2><p>A pseudo szó hamisat jelent. Azért ez a nevük, mert olyan tulajdonságokra vonatkoznak, amelyeket a böngésző automatikusan rendel az elemekhez. Például ha az elem fölé visszük az egeret, vagy kattintottunk már egy linkre. Az eredeti szelektor után kell kettősponttal írni, például:</p><p><code>a:hover</code> vagy <code>a:visited</code></p><h2>Fontosabb pseudo szelektorok</h2><ul><li><code>:hover</code> - ha az elem fölé viszik az egeret,</li><li><code>:visited</code> - azok a linkek, amelyekre már kattintottak,</li><li><code>:active</code> - ha a felhasználó használ egy elemet, mondjuk rákattint,</li><li><code>:focus</code> - elsősorban input mezőknél, ha éppen használjuk,</li><li><code>:first-child</code> - a szülő elem első gyereke,</li><li><code>:last-child</code> - a szülő elem utolsó gyereke,</li><li><code>:nth-child(n)</code> - az n-edik gyereke a szülő elemnek,</li><li><code>:empty</code> - olyan elem, aminek nincs gyereke, azaz nem tartalmaz beágyazott elemet,</li><li><code>:checked</code> - a kiválasztott checkbox,</li><li><code>:disabled</code> - letiltott elem.</li></ul><p>Az alábbi példában bemutatok néhányat a fentiek közül:</p><p class="img-container"><img src="./resources/css_selector_pseudo.gif" alt="CSS pseudo szelektorok"></p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/cssref/css_selectors.asp" target="_blank">https://www.w3schools.com/cssref/css_selectors.asp</a></p></div>

    <h2>A finomhangolt weboldal bemutatása</h2>

    <p>Most már kezd egészen elfogadható kinézete lenni az oldalnak.<br>A valóságban ebbe a folyamatba be szoktak vonni designereket is, úgy még ennél is jobb lehet a végeredmény.</p>

    <h2>A formázott weboldal átadása</h2>

    <p>Miután Tamáson is átmennek a módosítások, jöhet az ügyfél általi véleményezés is.</p>

    <h1>Űrlapok készítése</h1>

    <h2>Az űrlappal kapcsolatos igények megfogalmazása</h2>

    <p>Egy jó űralpot összerakni nem is olyan könnyű dolog.<br>Meg kell határozni a gyűjtendő adatok körét, az űrlap felépítését, megjelenését és azt is, hogy az adatok hová kerülnek?</p>

    <h2>1. feladat - Egy egyszerű űrlap elkészítése</h2>
    <p>Azt mondják, űrlap nélkül nem weboldal a weboldal.<br>Ezért előre látható volt, hogy eljön a nap Kristóf életében is, amikor meg kell barátkoznia az űrlapokkal.</p>

    <h2>Az űrlapok áttekintése</h2>

    <div class="content"><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/html/html_forms.asp" target="_blank">https://www.w3schools.com/html/html_forms.asp</a></p></div>

    <h2>Az űrlapok haszna</h2>

    <div class="content"><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/html/html_forms.asp" target="_blank">https://www.w3schools.com/html/html_forms.asp</a></p></div>

    <h2>A label</h2>

    <div class="content"><h2>Form - ahol az adat kezdődik</h2><p><strong>Űrlapot a <code>form</code> elem használatával hozhatunk létre.</strong><br>Az űrlapon belül vannak a beviteli mezők, listák.<br>Egy alapvető űrlap így néz ki:</p><p><img class="shadow" src="./resources/04_html_form.gif" alt="Alapvető űrlap"></p><h2><code>Input</code> és <code>label</code></h2><p><strong>Az <code>input</code> elem az adatok kézi bevitelére szolgál.</strong><br><strong>Az <code>input</code> mezőket címkével láthatjuk el, ez a <code>label</code> elem.</strong></p><h2>Az <code>input</code> elem fontos tulajdonságai:</h2><ul><li><code>name</code>: az adat neve, későbbi azonosításhoz kell.</li><li><code>type</code>: az adat típusa, lehet text, password, radio stb.</li></ul><h2>Példa különböző típusú <code>input</code> elemekre</h2><p class="margin-top-1"><img class="shadow" src="./resources/04_html_form_input_types.gif" alt="Input típusok"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms" rel="nofollow" target="_blank">Útmutató az űrlapokhoz</a></p></div>

    <h2>A checkbox és a radio</h2>

    <div class="content"><p>A <strong>checkbox</strong> és a <strong>radio</strong> szintén adatbevitelre szolgál. Ebben az esetben a felhasználónak nem kell beírnia semmit, csupán választania kell a felkínált lehetőségek közül.</p><h2>Checkbox - csekkoljunk be!</h2><p><strong>Egy <code>input</code> elem, amelynek a típusa: <code>checkbox</code></strong>. A checkbox önálló elem, ha bepipáljuk az azt jelenti, hogy igent mondtunk a kérdésre.</p><p>Először a létrehozását mutatom meg, utána a megjelenését:</p><p><img class="shadow" src="./resources/05_html_checkbox_1.gif" alt="Checkbox"></p><p><img class="shadow" src="./resources/05_html_checkbox_2.gif" alt="Checkbox"></p><h2>Radio - egyszerre csak egyet!</h2><p><strong>Szintén egy <code>input</code> elem, de mindig többet használunk egyszerre</strong>. Az alapvető különbség a radio és a checkbox között, hogy a <strong>radio</strong> esetében több választási lehetőséget kínálunk fel, amelyek közül csak egyet lehet választani. Pl. neme, autó színe.
        A radio esetén fontos, hogy a <code>name</code> tulajdonság az adott csoportba tartozó öszes radio-nál azonos legyen:</p><p><img class="shadow" src="./resources/05_html_radio_1.gif" alt="Radio"></p><p><img class="shadow" src="./resources/05_html_radio_2.gif" alt="Radio"></p><h2>A <code>value</code> tulajdonság</h2><p><strong>Value, azaz a mező értéke.</strong>
        Ha beállítjuk a <code>value</code> atrribútumot, alapértelmezett értéket adhatunk az <code>input</code> elemnek:</p><p><img class="shadow" src="./resources/05_html_value.gif" alt="A value attribútum"></p><p><img class="shadow" src="./resources/05_html_value_2.gif" alt="A value attribútum"></p><h2>A <code>checked</code> tulajdonság</h2><p>Ha bejelölünk egy radio vagy checkbox elemet, felveszi a <code>checked</code> tulajdonságot. Viszont ezt nem csak automatikusan veheti fel, mi is megadhatjuk, hogy alapból be legyen jelölve. Csak hozzá kell adnunk az elemhez:</p><p><img class="shadow" src="./resources/05_html_checked.gif" alt="A checked attribútum"></p><p><img class="shadow" src="./resources/05_html_checked_2.gif" alt="A checked attribútum"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox" rel="nofollow" target="_blank">Checkbox</a></p></div>

        <h2>Fieldset</h2>

        <div class="content"><h2><code>fieldset</code></h2><p>Két fontos tag, amit a formok kapcsán még érdemes megemlíteni: a <code>fieldset</code> és a <code>legend</code>.
            A <code>fieldset</code> segítségével csoportosítani tudjuk a logikailag összetartozó űrlapelemeket, a <code>legend</code> segítségével pedig ezekhez a csoportokhoz tudunk feliratot készíteni.
            A <code>legend</code> mindig a <code>fieldset</code> elemen belül kell hogy legyen!</p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Personalia:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span>
                Name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
                Email: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
                Date of birth: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
            </code></pre><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/tags/tag_fieldset.asp" rel="noopener noreferrer" target="_blank">https://www.w3schools.com/tags/tag_fieldset.asp</a></p></div>

    <h2>Az elkészített űrlap bemutatása</h2>
    <p>Most még csak az űrlap váza készült el, a működés és a megjelenés még hátravan.</p>

    <h2>2. feladat - Űrlap formázása Bootstrap segítségével</h2>
    <p>Ha eléggé felkészültek vagyunk és időnk is van rá, nekiállhatunk saját CSS-t írni minden elemre. Viszont a legtöbbször erre nincs idő, így valamilyen előre megírt CSS keretrendszert érdemes használni.</p>

    <h2>A Bootstrap megismerése</h2>

    <div class="content"><h2>Bootstrap - ugorjunk a bakancsba!</h2><p>A CSS keretrendszerek gyakorlatilag előre megírt .css fájlokból állnak. A mi dolgunk, akik használjuk őket, csak annyi, hogy a HTML elemeket az előre meghatározott osztályokhoz rendeljük. Most megmutatom neked a Bootstrap keretrendszer beállítását egy oldalra.</p><h2>Használatba vétel</h2><p>Több módon is beillesztheted az oldaladba a Bootstrap keretrendszert.</p><h3>CDN használata</h3><p>A CDN a tartalom továbbító hálózat rövidítése.
        Ha lekérsz rajta keresztül egy fájlt, akkor igyekszik mindig a legközelebbi
        szerverről visszaküldeni neked, hogy minél gyorsabban megkapd. Viszont hátránya,
        hogy nem garantálja hogy a fájl mindig fent lesz a szervereden, így tesztelési
        vagy oktatási célra alkalmas, éles rendszerhez pedig saját vagy fizetett CDN ajánlott.</p><p>Négy fájlra lesz szükséged, a css-t a fejlécbe, a js fájlokat a body végére célszerű elhelyezni:</p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://code.jquery.com/jquery-3.4.1.slim.min.js"</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        </code></pre><h3>Saját kiszolgáló</h3><p>Ha a fájlokat a saját szervereden akarod elhelyezni, akkor először le kell őket töltened. Majd kicsomagolni a megfelelő helyre.
        Azt javaslom, hogy mindig készíts mondjuk egy lib mappát, ahol azokat a fájlokat tárolod, amelyeket nem fogsz módosítani. Így elkerülheted hogy összekeveredjenek a saját munkáddal és sokkal könnyebb lesz karbantartani a frissítéseket.</p><p>A Bootstrap letöltése:</p><div class="download"><div class="download-content"><div class="download-title text-truncate">bootstrap-4.4.1.zip</div><div class="download-size">2,8 MB</div></div><div class="download-button"><a class="button" href="https://github.com/twbs/bootstrap/archive/v4.4.1.zip" target="_blank" role="button">Letöltés</a></div></div><h3>Csomagkezelők használata</h3><p>Léteznek automatikus csomagkezelők, amelyek egy paranccsal rávehetők, hogy letöltsék a külső alkalmazásokat. Ilyenek például:
        <a href="https://www.npmjs.com/" rel="noopener noreferrer" target="_blank">NPM</a>.</p><p>A példában távolról ágyazom be a fájlokat:</p><p><img class="shadow" src="./resources/asset-v1_Training360_1001_2019_T1_type_asset_block_bootstrap-include.gif" alt="Bootstrap include"></p><h2>Eszköz szélessége</h2><p>A Bootstrap esetében fontos, hogy mindig igazodik az ablak szélességéhez, azaz a vízszintes görgetést elkerüli. Így mobilon is könnyen használható lesz az oldal. Ehhez viszont be kell állítani egy meta elemet az oldal fejlécében:</p><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;</span></code></pre><p></p><p>A mobil eszközöknek különböző a felbontása, ezért a gyártó megadja, hogy hogyan skálázódjon az oldal az ő eszközén. Mert hiába QHD azaz négyszeres FullHD a felbontás, attól még a kijelző kicsi. Ezt követi le a Bootstrap.</p><h2>Dokumentáció</h2><p><a href="http://getbootstrap.com/getting-started/" rel="noopener noreferrer" target="_blank">GetBootstrap</a></p></div>

    <h2>A Bootstrap rácsrendszere</h2>

    <div class="content"><h2>Bootstrap - rácsrendszer</h2><p>Hogy gyorsabb legyen az egyes elemek szélességét megadni, a Bootstrap bevezette az úgynevezett rácsrendszert. Ez arra való, hogy az elemek szélessége százalékosan igazodjon a befogadó ablak szélességéhez.</p><h2>Row - (sor)</h2><p>Úgy kell elképzelni ezt a rácsrendszert, mint egy táblázatot. Vannak benne sorok és oszlopok, ahol találkoznak ott vannak a cellák. Ha új tartalmat szeretnél létrehozni, akkor először mindig kell egy sor, amibe majd beteszed az oszlopokat.
        Ez alapvetően egy <code>div</code>, amit a <code>row</code> osztályhoz kell rendelned:</p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        </code></pre><h2>Col - column (oszlop)</h2><p>Tehát az oszlopokat soha ne önmagukban használd, hanem mindig egy soron belül.
        Ezek is <code>div</code>-ek, és <code>col-*</code> kezdetű osztályokhoz kell rendelned őket.</p><p><strong>A Bootstrap minden sort 12 oszlopra oszt fel!</strong><br><strong>Öt méretosztályt különböztet meg az oldal szélessége alapján:</strong></p><p><img class="shadow" src="./resources/bootstrap-grid.jpg" alt="Bootstrap Grid"></p><p><b>Megjegyszés:</b> ha megnézed a képet, látod hogy melyik osztály melyik méret esetén működik.</p><h3>Oszlopok száma</h3><p>Az adott oszlopszélességet úgy tudod megadni, hogy az előtag után írod az oszlopok számát.</p><ul><li>A <code>col-sm-12</code> azt jelenti, hogy telefon méretben teljes szélességű.</li><li>A <code>col-xl-3</code> nagy képernyőn 1/4 szélességű, mert a 12/3 = 4.</li><li>A <code>col-md-6 col-sm-12</code> közepes képernyőn 1/2, kicsin pedig teljes szélességű.</li></ul><h2>Mobile first - elsősorban telefonra</h2><p>A Mobile first kifejezés azt jelenti, hogy ha csak a telefon méretre adod meg az oszlopok szélességét, akkor az összes nagyobb méret esetén is az marad érvényben.
        De ha mondjuk megadod <code>col-md</code> esetén is az oszlopok számát, de <code>col-lg</code> esetén nem, akkor az <code>lg</code> esetén is az <code>md</code> marad érvényben. Tehát alulról felfelé nézi a beállításokat, mindig a kisebb az erősebb.</p><h2>Dokumentáció</h2><p><a href="https://getbootstrap.com/docs/4.4/layout/grid/" rel="noopener noreferrer" target="_blank">Bootstrap grid system</a></p></div>

        <h2>A navigációs sáv - Navbar</h2>

        <div class="content"><h2>Navbar</h2><p>Ez az oldal tetején található navigációs sáv slang-es neve. Most villámgyorsan fogunk egyet készíteni a Bootstrap leírása alapján.</p><h2>Példakód</h2><p>Először be kell szerezned a példakódot, ami előre meg van írva, csak be kell illesztened a forráskódodba. Érdemes egyből az oldal tetején, azaz rögtön a <code>&lt;body&gt;</code> tab után elhelyezni, mivel általában a navigációval kezdődik az oldal.</p><p><strong>Menj a bootstrap oldalán a <a href="https://getbootstrap.com/docs/4.4/components/navbar/#supported-content" rel="noopener noreferrer" target="_blank">navbar</a>-hoz:</strong></p><p><img class="shadow" src="./resources/bt-navbar.jpg" alt="navbar copy"></p><p><b>Megjegyzés:</b> a kód jobb felső sarkában van a Copy gomb, azzal gyorsan ki tudod másolni a vágólapra.</p><h2>A navbar részei</h2><h3>Brand</h3><p>Ez a cég vagy a szolgálatás fantázianeve. A brand. Ez van rögtön balról az első helyen. Érdemes tehát átírni a kívánt névre.
            Állítsd be a <code>href="/"</code> attribútumot, mivel a brand szövegére kattintva általában az emberek a főoldalra szeretnének jutni.</p><h3>Linkek</h3><p>A linkek közül az első általában a <code>Home</code> feliratú, ennek a <code>href="/"</code> beállítást célszerű adni, ahogy a brand-nek is.</p><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"collapse navbar-collapse"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"navbarSupportedContent"</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-nav mr-auto"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-item active"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-link"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/"</span>&gt;</span>Home <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sr-only"</span>&gt;</span>(current)<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                ...
              <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p></p><p>Ha megnézed a kódot, látod hogy a linkek egy <code>ul</code>-ben vannak, azon belül pedig természetesen <code>li</code> elemekben.
            Ha hozzárendeled az <code>li</code> elemet az <code>active</code> osztályhoz, akkor sötétebb színű a szöveg, amivel jelzi hogy éppen ezezn az oldalon van a felhasználó.
            Le is tilthatsz egy linket, ha az <code>a</code> elemet a <code>disabled</code> osztályhoz rendeled.</p><h3>Search</h3><p>Igény esetén meg lehet hagyni a kereső blokkot is, ami egy beviteli mezőből és egy gombból áll. De ezt csak akkor hagyd meg, ha meg is csinálod, hogy működjön, mert nincs idegesítőbb annál, ha nyomják a gombot mint süket az ajtót és nem történik semmi :)</p><h2>Dokumentáció</h2><p><a href="https://getbootstrap.com/docs/4.3/components/navbar/#supported-content" target="_blank">Bootstrap Navbar</a></p></div>

    <h2>Bootstrappel formázott értesítések</h2>

    <div class="content"><h2>Alert</h2><p>Ezek figyelemfelkeltő üzenetek a felhasználók számára. Egyébként egyszerű div-ek, csak a Bootstrap szépen megformázza őket. Legtöbbször valamilyen művelet után használhatod őket, vagy ha mondjuk hibásan akar a felhasználó beküldeni adatokat.</p><h2>Fajtái</h2><p><img class="shadow" src="./resources/bt-alerts.jpg" alt="Bootstrap Alerts"></p><h2>Használata</h2><p>Két osztályt kell használnod. Az első alapvetően formázza meg az alertet, a második pedig a színét állítja be.
        A kódban az összes színösszeállításra van példa, ezek közül leggyakrabban a <code>primary</code>, <code>success</code>, <code>danger</code>, esetleg a <code>warning</code> osztályúakat fogod használni.</p><p><b>Megjegyzés:</b> vigyázz, mert mint minden div, ez is blokk szintű. Ha nem akarod, hogy teljes szélességű legyen, ted egy keskenyebb col-ba.</p><h2>Dokumentáció</h2><p><a href="https://getbootstrap.com/docs/4.4/components/alerts/" rel="noopener noreferrer" target="_blank">Bootstrap Alerts</a></p></div>

        <h2>Bootstrappel formázott táblák</h2>

        <div class="content"><h2>Bootstrap - táblásítsunk!</h2><p>A táblázatok esetében gondolom már belefutottál abba, hogy nem egyszerű szépen formázni őket. A Bootstrap ennek a terhét is leveszi a válladról.</p><h2>Table elem</h2><p>A Bootstrap-nek meg kell mondani, melyik táblákat formázza meg.
            Ezt a <code>table</code> osztály hozzáadásával teheted meg.
            Csak akkor fogja megfelelően formázni a táblázatodat, ha <code>&lt;thead&gt;&lt;/thead&gt;</code> és <code>&lt;tbody&gt;&lt;/tbody&gt;</code> elemekre bontod.
            A <code>thead</code>-en belül <code>tr</code> és <code>th</code> elemekkel dolgozz, a <code>tbody</code>-ban pedig a megszokott módon, <code>tr</code> és <code>td</code> elemekkel.</p><h2>Táblák fajtái</h2><p>Többféleképp meg tudod jeleníteni a táblázatokat, csak a megfelelő osztályt kell alkalmaznod hozzá:</p><ul><li>Csíkozott (minden második sor kicsit sötétebb): <code>table-striped</code></li><li>Szegélyezett (látszanak a cellák szegélyei): <code>table-bordered</code></li><li>Hovered (a sor beszürkül, ha fölé viszed az egeret): <code>table-hover</code></li><li>Tömör (kisebb paddingot hagy a cellákon): <code>table-sm</code></li></ul><p>A fenti osztályokat szabadon kombinálhatod is egymással.</p><h2>Sorok vagy cellák kiemelése</h2><p>Lehetőséged van különböző háttérszínnel kiemelni a fontosabb adatokat.
            Ha a lenti osztályokhoz rendeled a sort vagy a cellát, a háttérszíne is változik:</p><ul><li><code>table-active</code> : #f5f5f5</li><li><code>table-success</code> : #dff0d8</li><li><code>table-warning</code> : #fcf8e3</li><li><code>table-danger</code> : #f2dede</li><li><code>table-info</code> : #d9edf7</li></ul><h2>Dokumentáció</h2><p><a href="https://getbootstrap.com/docs/4.4/content/tables/" rel="noopener noreferrer" target="_blank">Bootstrap Tables</a></p></div>

    <h2>Bootstrappel formázott űrlapok</h2>

    <div class="content"><h2>Bootstrap űrlapok</h2><p>Tudod, a mai információéhes világban az űrlapok talán a leggyakrabban használt HTML elemek. Természetesen Bootstrap barátunk segít megformázni őket.</p><h2>Form elem</h2><p>Bootstrap esetén az űrlap vezérlőelemeit (input, label, select stb.) a <code>&lt;div class="form-group"&gt;&lt;/div&gt;</code> elemen belül kell elhelyezned.
        A <code>form-group</code>-on belül a konkrét beviteli elem a <code>form-control</code> osztályhoz kell hogy tartozzon. Például elhelyezel benne egy label-t és egy input-ot.</p><ul><li>Alap űrlap: a vezérlők (input, select, stb...) a label-ek alatt vannak.</li><li><code>form-inline</code>: a label és vezérlő sorban van.</li><li><code>form-horizontal</code>: a label és vezérlő egymás mellett vannak (ebben az esetben a labelnek be kell állítani a szélességét egy <code>col-*</code> oszállyal és a vezérlőt div-be kell tenned).</li></ul><h2>Form vezérlő elemek</h2><p>Különböző input típusok vannak, például a checkbox vagy a radio. Ezekre is van megoldása a Bootstrap-nek, de egy kicsit másképp működnek.</p><ul><li><code>checkbox</code>: checkbox osztályú div-en belül, label-ben kell elhelyezned.</li><li><code>radio</code>: ugyanaz, csak radio osztállyal.</li><li><code>&lt;select&gt;&lt;/select&gt;</code>: csak hozzá kel adnod a form-control osztályhoz.</li><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code>: szintén form-control osztály.</li></ul><h2>Dokumentáció</h2><p><a href="https://getbootstrap.com/docs/4.4/components/forms/#form-controls" rel="noopener noreferrer" target="_blank">Bootstrap Form Controls</a></p></div>

        <h2>Bootstrappel formázott gombok</h2>

        <div class="content"><h2>Bootstrap gombok</h2><p>Nincs annál fájdalmasabb, amikor haladnál a munkával és azzal kell szórakozni, hogy jobban nézzenek ki a gombok, amikre majd a felhasználó kattintani fog.
            A Bootstrap ezt a terhet is leveszi a válladról az előre megírt gombjaival sőt egyenesen gomb-csoportjaival.
            De hogyan is?</p><h2>Button elem</h2><p>Gombot többféle elemből is lehet gyártani: <code>&lt;a&gt; &lt;button&gt; &lt;input&gt;</code>.
            Attól függ mire van épp szükség. Ha a megfelelő osztályokhoz rendeled őket, egy alapvetően kellemes megjelenést vesznek fel.</p><p><strong>Alap osztály a <code>btn</code>, ezt mindig rendeld hozzá az elemhez!</strong></p><h2>Gombok fajtái</h2><p class="margin-top-1"><img class="shadow" src="./resources/bt-buttons.jpg" alt="Buttons"></p><p><b>Megjegyzés:</b> egyszerre csak az egyik osztályhoz tartozhat a gombod.</p><h2>Gombok méretezése</h2><p>Szintén osztályokkal tudod a gombok méretét beállítani. Ha azt szeretnéd, hogy ne az alapértelmezett méretben jelenjenek meg, az alábbi osztályokat használd:</p><ul><li><code>btn-lg</code> : nagyobb méret,</li><li><code>btn-sm</code> : kis méret,</li><li><code>btn-block</code> : block szintű, teljesen kitölti a befogadó elemet.</li></ul><h2>Gombok állapota</h2><p>Mint a legtöbb HTML elemnek, a gomboknak is lehetnek állapotai, amelyeket szintén osztályok segítségével jeleníthetsz meg:</p><ul><li><code>active</code> : a gomb benyomott állapotú (pl. váltógomboknál hasznos),</li><li><code>disabled</code> : halványabb színű és áthúzott kurzort kap.</li></ul><h2>Gomb csoportok</h2><p>Csoportosíthatod is a gombjaidat vezérlő elemekbe, csak annyit kell tenned, hogy <code>btn-group</code> oszályú div-be helyezed őket.</p><h2>Dokumentáció</h2><p><a href="https://getbootstrap.com/docs/4.4/components/buttons/" rel="noopener noreferrer" target="_blank">Bootstrap Buttons</a></p></div>

    <h2>Bootstrappel formázott ikonok</h2>

    <div class="content"><h2>Ikonok</h2><p>Sokkal szebb tud lenni egy vezérlőgomb vagy egy menüpont, ha teszel rá egy ikont. Erre a legjobb megoldás valamilyen webfont használata. Ezek olyan betűkészletek, amelyek nem betűket, hanem ábrákat tartalmaznak.
        A font-awesome nevűt nagyon egyszerűen használhatod:</p><p><strong>1. Ágyazd be a CSS-t:</strong></p><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://use.fontawesome.com/releases/v5.8.1/css/all.css"</span>&gt;</span></code></pre><p></p><p><strong>2. Válaszd ki a neked tetsző ikont a listából: <a href="https://fontawesome.com/icons?d=gallery" rel="noopener noreferrer" target="_blank">Ikonok</a></strong></p><p><strong>3. Illeszd be a doksi alapján:</strong></p><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-cart-arrow-down"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></code></pre><p></p><p>Akár ilyen szép is lehet a végeredmény:</p><p><img class="shadow" src="./resources/bt-fa-icons.jpg" alt="Button with icon"></p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://fontawesome.com/" rel="noopener noreferrer" target="_blank">https://fontawesome.com/</a></p><h2>Példakód</h2><iframe class="shadow" height="500" style="width: 100%;" scrolling="no" title="Fontawesome embedding" src="https://codepen.io/cherryapp/embed/xxGeXzp?height=265&amp;theme-id=dark&amp;default-tab=html,result" allowfullscreen="true"></iframe><p><a href="https://codepen.io/cherryapp/pen/xxGeXzp" target="_blank">Fontawesome embedding</a> on CodePen.</p></div>

    <h2>A formázott űrlap bemutatása</h2>
    <p>Húzós körön vagyunk túl, kis pihenő után jöhet majd a következő sprint.</p>

    <h2>Húzós körön vagyunk túl, kis pihenő után jöhet majd a következő sprint.</h2>

    <h1>Űrlapok készítése JavaScript segítségével</h1>

    <h2>Az űrlap továbbfejlesztési igényeinek megfogalmazása</h2>
    <p>Ha éppen van fejlesztési igény, attól nem szabad megilyedni. Ez természetes velejárója a munkánknak.</p>

    <h2>1. feladat - A rendelés összértékének kiszámítása</h2>
    <p>Eljött az idő, hogy Kristóf megismerkedjen a JAVASCRIPT nyelvvel.<br>Az egyik leggyorsabban tanulható programnyelv, napjainkra pedig nagyon eltejedt.</p>

    <h2>A JavaScript áttekintése</h2>

    <div class="content"><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/js/js_intro.asp" target="_blank">https://www.w3schools.com/js/js_intro.asp</a></p></div>

    <h2><div class="content"><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/js/js_intro.asp" target="_blank">https://www.w3schools.com/js/js_intro.asp</a></p></div></h2>

    <div class="content"><h2>JavaScript</h2><p>A JavaScript-et (innen js) egy Brendad Eich nevű úriember fejlesztette ki még a 90-es években. Arra találta ki, hogy a böngészőnek lehessen egyszerű parancsokat adni, vagy reagálni arra ha valaki rákattint egy elemre az oldalon vagy bevisz valamilyen adatot. Mivel elég egyszerű megtanulni és dolgozni vele, ezért mi ezt választottuk arra, hogy megtanítsuk neked a programozás alapjait. Biztos vagyok benne, hogy élvezni fogod, úgyhogy vágjunk is bele.</p><h2>A <code>script</code> elem</h2><p>Azt mondtam, hogy a böngészőben használjuk a js-t. A js kód egy egyszerű szöveges fájlban van, így a szerkesztése elméletileg bármilyen szövegszerkesztő programmal lehetséges. Mi erre is a VS Code programot fogjuk használni, mert ezt már jól ismered és egyébként is sokat segít a kódolásban.
        De hogyan tudod beszúrni a kódot az oldaladba? Erre van a <code>script</code> elem. Ezt kétféle módon is használhatod:</p><h3>Inline kód</h3><p>Ekkor egy <code>script</code> elemet hozol létre a <code>head</code> vagy <code>body</code> elemen belül és ennek a tartalma lesz a js kód.</p><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
          <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Amy"</span>;
          alert(name);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p></p><h3>Külső (external) JavaScript</h3><p>Itt pedig egy külön fájlt hozol létre és azt szúrod be a HTML kódba úgy, hogy megadod a <code>script</code> elem <code>src</code> attribútumában, a képekhez hasonlóan (ott is <code>src</code> az elérési út neve).</p><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"myScript.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        </code></pre><p></p><h2><code>head</code> vagy <code>body</code></h2><p>Azt mondtam, hogy a js kódot az oldalon a head vagy a body elemben is elhelyezheted. Oké, de mi a gyakorlat? Általában a js kódokat a body elem végén szokták elhelyezni. Azért mert a js kódban sokszor az oldal egyéb elemein végzel majd műveleteket (átírod a tartalmat, hozzáadsz vagy törölsz elemeket, stb...). A böngésző pedig úgy olvassa a HTML kódot mint egy könyvet, fentről lefelé. Tehát ha a js kódot az oldal tetejére teszed és abban egy lejjebb lévő elemet akarsz módosítani az hibát eredményez, mert azt az elemet a böngésző még nem hozta létre.</p><h2>Példa egy tipikus js elhelyezésre</h2><p></p><pre><code class="html hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello JS!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
        </code></pre><p></p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_whereto.asp" rel="noopener noreferrer" target="_blank">JS beszúrása</a></p></div>

    <h2>Változók deklarálása és definiálása - let</h2>

    <div class="content"><p>Valaki azt mondta, hogy egy biztos dolog van, az pedig a változás. Ez a programozásra is nagyon igaz, mivel az adatokat ilyen változókban tároljuk el.</p><h2>Változó létrehozása</h2><p>A változó az a hely a számítógép memóriájában, ahol valamilyen adatot vagy mennyiséget tárolunk. Amikor egy változót létrehozol js -ben, akkor a böngésző a neki kiosztott memóriában elkülönít egy területet az adatok tárolására, majd az általad megadott címkével ellátja, hogy később is megtaláld.</p><blockquote><strong>Fontos:</strong> a vátlozók létrehozásánál különböző kulcsszavakat használhatsz. Régebben a <code>var</code> kulcszót lehetett csak használni, de a 2015 -ös szabvány behozta a <code>let</code> és <code>const</code> kulcsszavakat. Továbbra is használható a <code>var</code>, de mi már mindenhol az újabb kulcsszavakat fogjuk használni.</blockquote><p><strong>Változót a <code>let</code> (régebben <code>var</code>) kulcsszóval hozhatsz létre:</strong></p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> price1 = <span class="hljs-number">5</span>;
        <span class="hljs-keyword">let</span> price2 = <span class="hljs-number">6</span>;
        <span class="hljs-keyword">let</span> total = price1 + price2; <span class="hljs-comment">// 11</span></code></pre><p></p><p>A kód magyarázata:</p><ul><li><code>let</code> : utasítom a böngészőt, hogy egy változót fogok létrehozni</li><li><code>price1</code> : a változó azonosítója, azt is szoktuk mondani, hogy a neve</li><li><code>=</code> : értékadó operátor, egyenlőségjel</li><li><code>5</code> : az érték amit a price1 változóban akarok tárolni</li></ul><p><strong>A kódot a böngésző hajtja végre és jobbról balra dolgozik.</strong></p><p>Mit jelent az, hogy jobbról balra dolgozik akkor, amikor valaminek értéket adsz? Azt, hogy először létrehozza a számot, ha az első sort nézzük akkor az 5-öt. Elkészíti a változót és abban tárolja el a számot. Nem csak számokat tudsz változókban tárolni természetesen, hanem szövegeket, igaz-hamis értékeket vagy összetett adatotkat is, ezeket később mind szépen sorravesszük.</p><h2>Dokumentáció</h2><p><a class="text-truncate" href="https://www.w3schools.com/js/js_let.asp" rel="noopener noreferrer" target="_blank">https://www.w3schools.com/js/js_let.asp</a></p></div>


    <h2>Változók deklarálása és definiálása - const</h2>

    <div class="content"><h2>Deklarálás, Definiálás</h2><p><strong>Deklarálás:</strong> egy változó deklarálása azt jelenti, hogy kinyilvánítom (deklarálom) hogy szeretnék egy változót létrehozni.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> age;</code></pre><p></p><p>Létrehoztam, de nem adtam neki értéket. Elméletileg a kódban bárhol létrehozhatsz egy új változót, de az áttekinthetőség miatt az elején szokták. Előfordulhat, hogy ilyenkor még nem tudod mi lesz az értéke, ezért csak deklarálod a változót.</p><p><strong>Definiálás:</strong> akkor definiálod a változót, amikor meghatráozod (definiálod) az értékét.</p><p></p><pre><code class="javascript hljs">age = <span class="hljs-number">25</span>;</code></pre><p></p><p>Figyeld meg, hogy nem írtam a változó neve elé a <code>let</code> parancsot. Ez azért van, mert ezt a változót már előzőleg deklaráltam, azaz létrejött már a memóriában, csak még nem tettem bele semmilyen értéket. Most ezért nem kell a <code>let</code> parancsot beírnom, mert az azt jelentené hogy újra létre akarom hozni, én viszont csak az értékét akarom beállítani.</p><p><strong>Egyszerre:</strong> amikor a deklarálás és a definiálást egyszerre hajtod végre, azt inicializálásnak is szokták nevezni, de ez programnyelvenként eltérő lehet. Ekkor egy lépésben létrejön a változó és értéket is kap.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> age = <span class="hljs-number">25</span>;
    </code></pre><p></p><h2>Minek nevezzelek?</h2><p>A változók nevét nem mindegy hogy hogyan határozod meg. Beszédesnek és könnyen olvahatónak kell lennie, hogy te és a munkatársaid is könnyen eligazodjatok a kódban.</p><h3>Változó nevek</h3><ul><li>Nem keződhet számmal és speciális karakterrel.</li><li>Nem lehet benne szóköz.</li><li>Kifejezőnek kell lennie.</li><li>Egyedinek kell lennie.</li><li>Ha több szóból áll, nagybetűvel jelöljük a szavak kezdetét, ezt úgy hívják <strong>camelCase</strong> azaz tevepúp módszer.</li></ul><h3>Példák</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> <span class="hljs-number">2</span>sheep = <span class="hljs-number">2</span>; <span class="hljs-comment">// rossz, mert számmal kezdődik</span>
    <span class="hljs-keyword">let</span> one moment = <span class="hljs-number">1</span>; <span class="hljs-comment">// rossz, mert szóköz van benne</span>
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">45</span>; <span class="hljs-comment">// roszz, mert nem kifejező a név</span>
    <span class="hljs-keyword">let</span> userAge = <span class="hljs-number">45</span>; <span class="hljs-comment">// jó mert kifejező, nem számmal kezdődik és camelCase</span>
    </code></pre><p></p><h2><code>const</code></h2><p>A js-ben a const egy olyan memóriaterületet jelöl, aminek csak egyszer adhatsz értéket. Ha egyszer már definiáltad, akkor később nem tudod az értékét megváltoztatni. Arra szokták használni, hogy védjenek fontos adatokat a program futása során, nehogy véletlenül megváltozzanak és ez hibát eredményezzen.</p><h3>Használata</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> programName = <span class="hljs-string">"ultimatePoker"</span>;
    programName = <span class="hljs-string">"myPoker"</span>; <span class="hljs-comment">// ez hibát eredményez, mert nem lehet az értékét megváltoztatni</span>
    </code></pre><p></p><h2>Dokumentáció</h2><ul><li><a href="https://www.w3schools.com/js/js_let.asp" rel="noopener noreferrer" target="_blank">JavaScript Let</a></li><li><a href="https://www.w3schools.com/js/js_const.asp" rel="noopener noreferrer" target="_blank">JavaScript Const</a></li></ul></div>

    <h2>A változók típusai</h2>

    <div class="content"><h2>Type</h2><p>Minden változónak van típusa, csak ezt a js-ben nem kell megadni, magától állítja be. Itt kicsit bemutatom neked a változók típusait.</p><h2>Primitívek</h2><p>A primitívek olyan (elmaradott törzsek a dzsungelben) változó típusok, amelyek nem bonthatóak tovább al-típusokra. Vannak például tömbök és objektumok is, amelyek más változókat tartalmaznak, ezekről hamarosan tanulsz majd. A javascriptben a primitív típusok kivételével minden objektum. Ezért is mondjuk, hogy a javascript objektumalapú nyelv.</p><p>A primitív típusok a következők:</p><ul><li>boolean</li><li>number</li><li>string</li><li>null</li><li>undefined</li><li>symbol</li></ul><p>A boolean, string, number primitíveknek van objektum megfelelője is. Amikor egy primitíven hívunk meg valamilyen objektum metódust, automatikusan objektummá alakul, és a műveletet követően visszaalakul primitívvé.</p><p>A primitív érték alakíthatatlan.</p><blockquote><h3>Fogalom</h3><strong>Immutable</strong>: azaz egy-egy objektumon nem végezhető módosítás, helyette a műveletek egy új, módosított objektumot adnak vissza.</blockquote><h2>A változó mint objektum.</h2><p>Minden objektumnak lehetnek tulajdonságai (property) és metódusai (method).</p><p>Az alábbi példában egy Number típusú (prmimitív) változó tulajdonságait és metódusait mutatja meg a Chrome böngésző eszköztára:</p><p><img class="shadow" src="./resources/variable_as_object.gif" alt="Változó objektum tulajdonságai"></p><h2>Dot operator - tulajdonságok elérése</h2><p>Az előző példában már láthattad, hogy egy objektum property-jeit és method-jait a <code>.</code> pont beírása után tudod lekérni vagy beállítani.
        Ezt <strong>dot operator</strong>-nak is hívják a pont angol neve után. Nagyon sokat fogod még használni a későbbiekben ezért jegyezd meg, hogy úgymond bele tudsz lépni az adott objektumba - változóba a pont beírása után.</p><p><strong>Két módon is használhatod:</strong></p><p></p><pre><code class="javascript hljs">object.property
        object[<span class="hljs-string">'property'</span>]</code></pre><p></p><p>Az eredemény ugyanaz lesz, de a későbbiekben látni fogod, hogy van hogy a pontot nem lehet használni. Ilyenkor jól jön majd a szögletes zárójeles írásmód.</p><h2>typeof</h2><p>A változók típusát a typeof beépített függvény segítségével kérhetjük le.
        Ez csak az alapvető típusokat ismeri, a későbbiekben foglalkozunk a pontosabb típus meghatározással is. A változó típusát a tulajdonságai és metódusai alapján is meg lehet határozni.</p><p>Az alábbi példa a typeof függvény használatát mutatja be:</p><p><img class="shadow" src="./resources/variable_typeof.gif" alt="Változó típusának meghatározása"></p><h3>Dokumentáció:</h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" rel="noopener noreferrer" target="_blank">Változók tulajdonságai</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors" rel="noopener noreferrer" target="_blank">Dot operator</a></li></ul></div>

    <h2>Ismerkedés a számok világával</h2>

    <div class="content"><h2>Számok</h2><p>Programozóként nagyon gyakran fogsz számokkal dolgozni. Ez első számítógépeket is kifejezetten matematikai feladatokra használták és mai napig minden művelet alapja a matek a számítógépben, csak ez szépen el van fedve a felhasználók elől.</p><h2>Number</h2><p>Ahogy a neve is mutatja, a Number típust számok tárolására használhatod.
        A JavaScript nem különbözteti meg az egész és tört számokat a típus szempontjából, az összes szám ugyanabba a Number típusba tartozik.</p><p><strong>Fontos jellemzői:</strong></p><ul><li>A tizedes jegyeket pont (.) jelöli.</li><li>Az összetett műveletekre a matematikából ismert zárójelezési szabályok érvényesek.</li></ul><h2>NaN - Not a Number (nem szám)</h2><p>A <code>NaN</code> a JavaScript nyelvben egy úgynevezett lefoglalt szó.
        Ezt az értéket akkor veszi fel egy változó, ha érvénytelen számot tartalmaz. Például ha számot szöveggel akarunk osztani, vagy rossz formában adtuk meg a Number típusú változót.</p><h2>Elemi műveletek</h2><ul><li>Összeadás: <code>+</code></li><li>Kivonás: <code>-</code></li><li>Szorzás: <code>*</code></li><li>Osztás: <code>/</code></li></ul><p>Az alábbi példában az elemi műveleteket mutatjuk be számok esetén:</p><p><img class="shadow" src="./resources/variable_number_atomic.gif" alt="Elemi műveletek számokkal"></p><h2>Egyéb műveletek</h2><ul><li>Maradékos osztás: <code>%</code> (az osztás utáni maradékot adja vissza, pl: 10 % 3 művelet eredménye 1).</li><li>Hatványozás: <code>**</code> (3**3, azaz 3*3*3 eredménye 27).</li></ul><h2>Precedencia szabályok</h2><p>Ahogyan a matematikában, úgy a programozásban is változó "erősségűek" a különböző műveletek. Azt már tudjuk, hogy az osztás, és a szorzás magasabb rendű művelet, mint az összeadás, és kivonás. Ez a szabály érvényes a JavaScript-re is. Ezen felül van még két új műveletünk.</p><p>Az egyik a maradékos osztás, mely ugyanúgy, mint a szorzás, vagy az osztás, magasabb rendű művelet, így megelőzi azokat.</p><p>A másik műveletünk a hatványozás. A hatványozás nem csak az összeadásnál és kivonásnál, de a szorzásnál, osztásnál, és maradékos osztásnál is magasabb rendű művelet, így először mindig a hatványozás művelete fog kiértékelődni.</p><p>Pl.: <code>10 + 18 / 3**2 = 12</code>, mert először a hatványozás, után az osztás, és legutoljára az összeadás művelete hajtódik végre.</p><h2>Végtelen - Infinity</h2><p>A JavaScript-ben bármikor előállíthatunk pozitív, és negatív végtelent is.</p><p><code>Number.POSITIVE_INFINITY</code><br><code>Number.NEGATIVE_INFINITY</code></p><p>Valamint le tudjuk ellenőrizni, hogy egy adott érték végtelen-e:</p><p><code>Number.isFinite(value)</code></p><h2>Dokumentáció</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="noopener noreferrer" target="_blank">Number típus</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite" rel="noopener noreferrer" target="_blank">Infinity</a></li></ul></div>

    <h2>Szövegek tárolása</h2>

    <div class="content"><p>A programnyelvek általában úgy tárolják a szövegeket, hogy az egyes karaktereket mentik el a memóriában és utána ezeket összefűzik egy egésszé. Innen is ered a string (fűző, zsinór) név.</p><h2>String típus</h2><p>Karakterláncokat tárol. Ezeket szövegnek is szokták nevezni köznapi nyelven, de ez nem pontos meghatározás. Később, amikor a tömböket megismerjük, visszatérünk rá, hogy pontosan mit is jelent a karakterek tömbje.
        Segítségével hosszabb szövegeket is tárolhatsz a memóriában. Amikor el akarsz tárolni egy email címet vagy egy nevet, az tipikusan String típusú lesz.</p><p><strong>Jellemzői:</strong></p><ul><li><code>"", ''</code> : idézőjelet vagy aposztrófot használhatsz a szövegek létrehozására</li><li>Összefűzés: a <code>+</code> jel segítségével. Gyakran előfordul, hogy több darabból kell összeállítanod egy szöveget. Ekkor a + jel segítségével fűzhetsz össze több String típusú változót.</li></ul><p>Az alábbi példában egy String típusú változót definiálok.</p><p><img class="shadow" src="./resources/variable_types_string_definition.gif" alt="String definiálása"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noopener noreferrer" target="_blank">String</a></p></div>

    <h2>Van vagy nincs? - undefined és null</h2>

    <div class="content"><p>Fontos információt hordoz az is, hogy egy változó létezik-e, esetleg létezik de van-e már értéke?</p><h2>Undefined</h2><p>Egészen addig, amíg egy változót nem definiálsz, az értéke undefined lesz, ha pedig a típusát lekéred azt fogod kapni, hogy "undefined".</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> userAge; <span class="hljs-comment">// az értéke: undefined azaz definiálatlan</span>
        <span class="hljs-keyword">typeof</span> userAge; <span class="hljs-comment">// ez pedig string -ként lesz "undefined"</span></code></pre><p></p><p>Ezt arra szokták használni, hogy megnézzék hogy megadott-e a felhasználó egy értéket vagy jól futott-e le a programunk?</p><h2>Null</h2><p>Hasonlóan az undefined-hez egy speciális típus, az a különbség hogy nem azt jelzi hogy még nincs definiálva a változó, ezt az értéket szándékosan szokták egy változónak adni, úgymond kinullázzák.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> amount = <span class="hljs-literal">null</span>;</code></pre><p></p><p>A fenti példában az amount-nak null értéket adtam. Ezzel azt akartam jelölni, hogy van ugyan értéke, de valamiért én direkt ki akartam nullázni. Ezt olyankor is használják, amikor már nem kell egy változóban tárolt érték. Ilyenkor csak beállítják null-ra és majd később újra értéket ad. Így a memóriából is kitisztítják a szükségtelen értékeket.</p><h2>Dokumentáció</h2><ul><li><a href="https://www.w3schools.com/jsref/jsref_undefined.asp" rel="noopener noreferrer" target="_blank">Undefined</a></li><li><a href="https://www.w3schools.com/js/js_datatypes.asp" rel="noopener noreferrer" target="_blank">Data types</a></li></ul></div>

    <h2>Típuskonverziók</h2>

    <div class="content"><p>Amikor egy típust át akarunk alakítani egy másikra, mondjuk String-ből Int-et vagy Boolean-t készíteni, akkor típuskonverzióról vagy átalakításról beszélünk. Ennek a fajtáit és technikáit mutatom most meg neked.</p><h2>Implicit típuskonverzió</h2><p>Az implicit típuskonverzió olyan típuskonverzió, amelyet a fordítóprogram automatikusan alkalmazhat, amikor szükségét érzi. Ha ezt az átalakíást nem tudja a program automatikusan elvégezni, akkor általában valamilyen hibaüzenetet kapsz.</p><p>A String és a Number típusokat ismered, most ezeken mutatok egy implicit konverziót oda és vissza.</p><p></p><pre><code class="javascript hljs"><span class="hljs-string">'5'</span> - <span class="hljs-string">'2'</span> <span class="hljs-comment">// 3</span>
        <span class="hljs-string">'5'</span> * <span class="hljs-string">'2'</span> <span class="hljs-comment">// 10</span></code></pre><p></p><p>A js nagyon toleráns a típushibákkal szemben, mert nem te adod meg a típusokat, hanem automatikusan állítja be őket. A példában nem lehet elvégezni a szorzás vagy kivonás műveleteket a String típuson, ezért átalakítja Number-ré. Mivel ez sikerül neki, hiba nélkül le fog futni a String-ek szorzása és kivánása is, mert a művelet előtt megtörténik az automatikus azaz implicit típuskonverzió és az már a számokon megy végbe.</p><p>De mi lesz, ha nem tudja elvégezni az implicit típuskonveziót?</p><p></p><pre><code class="javascript hljs"><span class="hljs-string">"3hello"</span> * <span class="hljs-string">"4"</span> <span class="hljs-comment">// NaN</span>
        <span class="hljs-string">"3hello"</span> - <span class="hljs-string">"4"</span> <span class="hljs-comment">// NaN</span></code></pre><p></p><p>A példában nem tudta elvégezni az implicit konverziót, mert a String-ben betűk is voltak. Így NaN, azaz Not a Number lett az értéke a kifejezésnek.</p><h2>Explicit típuskonverzió</h2><p>Itt mi erőltetjük a konverziót és nem az értelmezőmotor hajtja végre automatikusan. A típusoknak a js-ben van úgynevezett konstruktora, amivel egy adott típusú változót létre lehet hozni.</p><h3>Az alap konstruktorok a következők:</h3><p></p><pre><code class="javascript hljs"><span class="hljs-built_in">Boolean</span>() <span class="hljs-comment">// false</span>
        <span class="hljs-built_in">String</span>() <span class="hljs-comment">// ""</span>
        <span class="hljs-built_in">Number</span>() <span class="hljs-comment">// 0</span></code></pre><p></p><p>Ha ezeket a parancsokat kiadod, és nem adsz meg semmit a zárójelek között, akkor a komment utáni értékekkel jön létre a változó. Így tudod kényszeríteni, hogy egy változó milyen típusú legyen.</p><h3>Típuskonverzió konstruktorokkal:</h3><p></p><pre><code class="javascript hljs"><span class="hljs-built_in">Number</span>(<span class="hljs-string">"Hello"</span>) <span class="hljs-comment">// NaN</span>
        <span class="hljs-built_in">Number</span>(<span class="hljs-string">"2"</span>) <span class="hljs-comment">// 2</span>
        <span class="hljs-built_in">Number</span>(<span class="hljs-string">"3h"</span>) <span class="hljs-comment">// NaN</span>
        <span class="hljs-built_in">Number</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// 0</span>
        <span class="hljs-built_in">String</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// "0"</span>
        <span class="hljs-built_in">String</span>(<span class="hljs-number">22</span>) <span class="hljs-comment">// "22"</span>
        <span class="hljs-built_in">String</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// "NaN"</span>
        <span class="hljs-built_in">String</span>(<span class="hljs-string">'-33'</span>) <span class="hljs-comment">// "-33"</span></code></pre><p></p><p><b>Megjegyzés:</b> látod, hogy a String típusnál nem akad ki semmin, azaz mindig megy a konverzió. Ennek oka az, hogy a String az összes jelet ismeri, amit a Number, tehát a számok is benne vannak, azaz mindent meg tud jeleníteni amit a számoknál használsz.</p><h3>Vegyes típusok egy kifejezésben:</h3><p></p><pre><code class="javascript hljs"><span class="hljs-string">'22'</span> + <span class="hljs-number">2</span> <span class="hljs-comment">// "222"</span>
        <span class="hljs-number">2</span> + <span class="hljs-string">"11"</span> <span class="hljs-comment">// "211"</span>
        <span class="hljs-number">22</span> * <span class="hljs-string">"3"</span> <span class="hljs-comment">// 66</span></code></pre><p></p><p><b>Megjegyzés:</b> amikor egy összeadásban egy String szerepel, mindig String típusú lesz az eredmény. Ezért szokták mondani, hogy a String erősebb. De a szorzás már nem értelmezhető String típuson, ezért ekkor a String-ből lesz Number.</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_type_conversion.asp" rel="noopener noreferrer" target="_blank">JS type conversion</a></p></div>

    <h2>Típuskonverzió utasításokkal</h2>

    <div class="content"><h2>Explicitebben</h2><p>Azt mondtam, hogy az explicit típuskonverzió esetén te mondod meg, hogy milyen típust akarsz. Erre vannak olyan parancsok (függvények - róluk később) a js-ben, amik elvégzik a típuskonverziót. Lássuk a legfontosabbakat.</p><h2><code>toString</code></h2><p>A nem String típusoknál tudod használni a <code>toString</code> parancsot (metódust), ami az adott változó értékét átalakítja String típusra.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> myNumber = <span class="hljs-number">2</span>; myNumber.toString(); <span class="hljs-comment">// "2"</span>
        <span class="hljs-keyword">let</span> myBoolean = <span class="hljs-literal">false</span>; myBoolean.toString(); <span class="hljs-comment">// "false"</span>
        <span class="hljs-keyword">let</span> myString = <span class="hljs-string">"Woff"</span>; myString.toString(); <span class="hljs-comment">// "Woff"</span></code></pre><p></p><p><b>Megjegyzés:</b> a harmadik példa érdekes lehet, mert itt amúgy is String volt a típus. Viszont amikor például egy másik programtól vagy a felhasználótó bekérsz egy adatot, nem biztos hogy jót kapsz. Ezért ha meghívod rá a <code>toString()</code> metódust, abból baj nem lesz, maximum ugyanaz marad, viszont biztos lehetsz benne, hogy String lesz a típusa.</p><h2><code>toFixed, toPrecision</code></h2><p>Ezeket Number típus esetén használhatod. A <code>toFixed()</code> a tizedesek számát állítja be, a <code>toPrecision()</code> pedig az összes számjegyet.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> testNumber = <span class="hljs-number">22.4434</span>;
        testNumber.toFixed(); <span class="hljs-comment">// "22"</span>
        testNumber.toFixed(<span class="hljs-number">2</span>); <span class="hljs-comment">// "22.44"</span>
        testNumber.toPrecision(); <span class="hljs-comment">// "22.4434"</span>
        testNumber.toPrecision(<span class="hljs-number">5</span>); <span class="hljs-comment">// "22.443"</span>
        testNumber.toPrecision(<span class="hljs-number">10</span>); <span class="hljs-comment">// "22.44340000"</span></code></pre><p></p><blockquote><strong>Fontos: mindig String-et adnak vissza!</strong></blockquote><h2><code>parseInt</code>, <code>parseFloat</code></h2><p>Ez a páros pedig arra hivatott, hogy bármiből egész számot vagy tizedes törtet gyártson. A konstuktoros megoldásnál hibatűrőbbek, de azért őket is ki tudod akasztani ha elég ügyes vagy:</p><p></p><pre><code class="javascript hljs"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"1"</span>); <span class="hljs-comment">// 1</span>
        <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">"22"</span>) <span class="hljs-comment">// 22</span>
        <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">"22.4"</span>) <span class="hljs-comment">// 22.4</span>
        <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"1hal"</span>); <span class="hljs-comment">// 1</span>
        <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"hal1"</span>); <span class="hljs-comment">// NaN</span>
        <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">"22.4hal"</span>); <span class="hljs-comment">// 22.4</span>
        <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">"hal22.4"</span>) <span class="hljs-comment">// NaN</span></code></pre><p></p><p><b>Megjegyzés:</b> ha megnézed a példákat azt látod, hogy még az sem baj ha betűk szerepelnek a számban, csak ne azzal kezdődjenek.</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_type_conversion.asp" rel="noopener noreferrer" target="_blank">Type Conversions</a></p></div>

    <h2>Formok kezelése JavaScript segítségével</h2>

    <div class="content"><h2>Form elements</h2><p>A HTML elemeknek van egy speciális csoportja, ezek az űrlap elemek. Abban különböznek a többi elemtől, hogy lehet értékük. Ez az érték tipikusan az, amit a honlap látogatói beírnak. Először meg fogjuk keresni az oldalon az adott elemet, majd kiolvassuk az értéket amit tartalmaz. Erre azért van szükség, hogy le tudjuk ellenőrzini a bevitt adatok helyességét (validálni tudjuk őket).</p><h2><code>querySelector</code> - elemek kiválasztása</h2><p>Ez a <code>querySelector</code> érdekes állatfajta. Ha a nevét két részre bontod, jobban megérted hogy mire való:</p><ul><li><strong>query:</strong> lékérés, lekérdezés, ami ebben az esetben egy HTML elem megkeresését jelenti az oldalon,</li><li><strong>selector:</strong> a lekérés az elem CSS szelektorával történik.</li></ul><p>Tehát nem kell hozzá új technikákat megtanulnod, ahhoz hogy lekérj egy HTML elemet, elég ha ismered a CSS szelektorokat. Remélem még nem felejtetted el őket, mert most nagyon kelleni fognak. :) (Ha igen, akkor ugorj vissza kicsit, és nézd át őket!)</p><h3>Példák</h3><p></p><pre><code class="javascript hljs"><span class="hljs-comment">// Az első example osztályú elem</span>
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".example"</span>);
        
        <span class="hljs-comment">// A test id -jű elem</span>
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#test"</span>);
        
        <span class="hljs-comment">// Az order id -jű űrlapon belül az amount nevű beviteli mező</span>
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"form#order input[name=amount]"</span>);
        </code></pre><p></p><h2><code>value</code> - az érték</h2><p>Oké, most már ki tudsz választani egy elemet az oldalon, de mit kezdesz vele? Az űrlap elemeknek van egy speciális tulajdonsága, a <strong>value</strong>.
        Ez mondja meg az elembe bevitt aktuális értéket. Most egy komplex példában kiválasztok egy elemet és kiolvasom az értékét.</p><h3>Űrlap HTML kódja (nem teljes)</h3><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"order"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Mennyiség<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"amount"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>&gt;</span>
          ...
        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p></p><p>Tehát van egy input-om, aminek a neve "amount" és az "order" id-jű űrlapban van. Akkor ezt a js kódban így is ki tudom választani (írhatsz más szelektort is igény szerint, lényeg hogy egyértelmű legyen).</p><h3>Input kiválasztása</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> amountInput = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"form#order input[name=amount]"</span>);
        </code></pre><p></p><blockquote><b>Fontos:</b> kiválasztottam az input-ot és elmentettem egy változóba, hogy később is tudjak vele dolgozni. A változó egy input elemet jelent, mindent amit az input elemmel tudok csinálni, a változóval is tudok.</blockquote><h3>Érték kiolvasása</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> amount = <span class="hljs-built_in">parseInt</span>(amountInput.value);</code></pre><p></p><p><b>Megjegyzés:</b> egyszerű mint a pofon. Az <code>amountInput</code> változó az inputot jelenti, ahova a vásárló beviszi hogy hány terméket szeretne. Ennek a <code>value</code> tulajdonságában van a szám ami nekem kell a rendelés árának a kalkulálásához. Ezt kiolvasom és elmentem az <code>amount</code> változóba. Viszont számmá alakítom, mert a böngésző az input-ok értékét String-ben adja vissza én pedig majd matekozni szeretnék vele.</p><h2>Dokumentáció</h2><ul><li><a href="https://www.w3schools.com/jsref/met_document_queryselector.asp" rel="noopener noreferrer" target="_blank">QuerySelector</a></li><li><a href="https://www.w3schools.com/tags/att_input_value.asp" target="_blank">Value</a></li></ul></div>

    <h2>Eseménykezelés</h2>

    <div class="content"><h2>Events</h2><p>Az események (angolul events) alapvetőek a js programozásban. Amikor a felhaszáló kattint az oldaladon, vagy görget az egérrel, esetleg bevisz valamilyen adatot vagy elküld egy űrlapot, mindig történik egy esemény amit tudsz figyelni. A közös bennük, hogy nem tudod előre hogy pontosan mikor fognak bekövetkezni.</p><h2>Az <code>onclick</code> attribútum</h2><p>Sokféle eseménye létezik az elemeknek attól függően, hogy milyen fajták. Nem mutatom meg az összeset, most elég lesz az <code>onclick</code> nevű. A nevéből is látszik, hogy akkor következik be ez az esemény, amikor rákattintanak egy HTML elemre. Ez lehet gomb, div vagy gyakorlatilag bármilyen látható elem amire lehet kattintani.</p><h2>Kattintás esemény figyelésének beállítása egy gombra</h2><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"order"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Mennyiség<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"amount"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>&gt;</span>
      
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-success"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"validateForm()"</span>&gt;</span>
          Megrendelés
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          ...
      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p></p><p><b>Mit látsz?</b></p><ul><li>Készítettem egy Bootstrap gombot zöld színben.</li><li>Az <code>onclick</code> attribútummal megadtam egy eseménykezelőt ami a js kódban lesz definiálva.</li></ul><h2>Eseménykezelő függvény</h2><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateForm</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">let</span> amountInput = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"form#order input[name=amount]"</span>);
        <span class="hljs-keyword">let</span> amount = <span class="hljs-built_in">parseInt</span>(amountInput.value);
      }</code></pre><p></p><p><b>Megjegyzés:</b> a függvényeket részletesen megvizsgáljuk majd, a feladat szempontjából elég ha tudod hogy egyszerű kódbokkok, amelyek több parancsot fognak össze.</p><h2>Összefoglalva</h2><p>Beállítottam az eseménykezelőt az <code>onclick</code> attribútummal, aminek az értéke a függvény neve ami el fog indulni majd, amikor rákattintanak a gombra. A függvényben vizsgálom az űrlapon bevitt értékeket hogy helyesek-e, vagy akár számításokat is végezhetek.</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/jsref/event_onclick.asp" rel="noopener noreferrer" target="_blank">Onclick event</a></p></div>

      <h2>HTML elemek módosítása JavaScript segítségével</h2>

      <div class="content"><h2>HTML elemek módosítása</h2><p>JS segítségével könnyen tudod módosítani az oldalon a HTML elemek tartalmát. Most ezt fogom neked megmutatni, jó lesz.</p><h2><code>innerHTML</code></h2><p>Azoknak a HTML elemeknek amelyeknek van lezáró tag-je (azaz nem self-closed elemek) lehet tartalma. Az <code>innerHTML</code> tulajdonság js alól eléthető és ki lehet vele olvasni vagy lehet módosítani is az elemek tartlamát, azaz a bennük található HTML kódot.</p><p><strong>Accessor:</strong> az <code>innerHTML</code> egy accessor, mert el lehet érni vele egy bizonyos tulajdonságot olvasásra és írásra is.</p><h2>Egy elem HTML tartalmának kiolvasása</h2><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> messageContent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"form#order .message"</span>).innerHTML;</code></pre><p></p><p><b>Mi történt?</b></p><ul><li>Kiválasztottam az "order" id-jű űrlap "message" osztályú elemét.</li><li>Az <code>innerHTML</code> tulajdonság segítségével kiolvastam az aktuális tartalmát és elmentettem egy változóba.</li></ul><h2>Tartalom módosítása</h2><p>Most kompletten megmutatom neked, hogyan lehet mondjuk kiírni a rendelés összegét egy <code>p</code> elembe?</p><h3>Az űrlap HTML kódja</h3><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"order"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Mennyiség<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"amount"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-success"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"validateForm()"</span>&gt;</span>
          Megrendelés
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"message"</span>&gt;</span>
          A rendelés összege <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> Ft
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p></p><p>Tehát van egy űrlapod, benne az <code>amount</code> mezővel, egy gombbal és egy <code>message</code> paragrafussal az üzenetnek.</p><h3>A JS kód</h3><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateForm</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// Termék egységára.</span>
        <span class="hljs-keyword">let</span> pricePerPiece = <span class="hljs-number">1200</span>;
      
        <span class="hljs-comment">// Kiválasztom a mennyiséget és a message mező ár részét.</span>
        <span class="hljs-keyword">let</span> amountInput = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"form#order input[name=amount]"</span>);
        <span class="hljs-keyword">let</span> priceField = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"form#order .message strong"</span>);
      
        <span class="hljs-comment">// Kiolvasom a bevitt mennyiséget és szorzom az egységárral.</span>
        <span class="hljs-keyword">let</span> amount = <span class="hljs-built_in">parseInt</span>(amountInput.value);
        <span class="hljs-keyword">let</span> totalAmount = amount * pricePerPiece;
      
        <span class="hljs-comment">// Kiírom az üzenetet, azaz frissítem az árat.</span>
        priceField.innerHTML = <span class="hljs-string">`<span class="hljs-subst">${totalAmount}</span>`</span>;
      }</code></pre><p></p><p><b>Megjegyzés:</b> a függvény utolsó sora az érdekes most számodra. A <code>priceField</code> változó a <code>p</code> elemen belüli <code>span</code> elemet jelenti, ahol az összeg megjelenik. Ennek a tartalmát módosítottam a teljes összegre (<code>totalAmount</code>).</p><p>A feladatot elvégeztük, kattintásra a rendelés összege változni fog. Remélem izgalmas volt és ez még csak a kezdete egy nagy utazásnak.</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/jsref/prop_html_innerhtml.asp" rel="noopener noreferrer" target="_blank">InnerHTML</a></p><h2>Példakód</h2><iframe class="margin-top-1" height="400" style="width: 100%;" scrolling="no" title="Rendelés számítása" src="https://codepen.io/cherryapp/embed/XWbQzvG?height=265&amp;theme-id=dark&amp;default-tab=html,result" allowfullscreen="true"></iframe><p><a href="https://codepen.io/cherryapp/pen/XWbQzvG" target="_blank">Rendelés számítása</a> on CodePen</p></div>

      <h2>A továbbfejlesztett űrlap bemutatása</h2>

      <p>Kristóf jól halad.<br>És te? Ha elakadtál, vagy valami nem egészen világos, nyugodtan nézz utána a tananyagban.</p>

      <h2>2. feladat - Az űrlap mezőinek validálása</h2>

      <div class="content"><h2>Validálás</h2><p>Validálásnak nevezzük, amikor azt vizsgáljuk, hogy érvényes (angolul valid) -e egy bizonyos adat?</p><h2>Miért baj, ha az adat invalid?</h2><p>Ha a felhasználók rossz adatokat vihetnek be a rendszerbe, akkor az rosszul fog működni és ennek akár a teljes leállás is lehet a következménye.</p><h2>A tesztelők által jelentett hibák</h2><ol class="list-strong"><li><span>Nem történik meg a beviteli mezők ellenőrzése, bármelyik kötelező mező üresen hagyható.</span></li><li><span>Az email címbe beírható bármi.</span></li><li><span>Darabszámként elfogad <code>-1</code>-et és <code>11</code>-et is.</span></li></ol><h2>Feladat</h2><p>Gondold át, hogy milyen hibák lehetségesek még ezeken kívül!</p></div>

      <h2>A Stringekkel végezhető metódusok</h2>

      <div class="content"><h2>Metódus</h2><p>Metódusnak azt nevezzük, amit egy típus csinálni tud.</p><p>Hogy mi van?</p><p>Az, hogy milyen hosszú egy String, az a tulajdonsága, olyan és kész. De hogy például képes a saját értékét visszaadni nagybetűs formában az már egy képessége amit végre tud hajtani. A metódus szó módszert jelent. A metódusok írják le, hogy pontosan hogyan megy végbe például egy nagybetűssé alakítás. A különböző típusok esetén vannak átfedések, azaz egy tulajdonság vagy metódus több típus esetén is létezhet.</p><h2>Stringek tulajdonságai</h2><ul><li><code>length</code> : Megadja a String típusú változó hosszát, azaz hogy hány karakterből áll.</li></ul><p><img class="shadow" src="./resources/variable_types_string_property_length.gif" alt="String length tulajdonság"></p><h2>Stringek metódusai</h2><ul><li><code>trim()</code> : Eltávolítja a felesleges szóközöket, amelyek a String előtt és után találhatóak.</li><li><code>concat()</code> : Új karaktereket fűz hozzá a meglévő Stringhez.</li><li><code>toLowerCase()</code> : Kisbetűssé alakítja az adott Stringet.</li><li><code>toUpperCase()</code> : Az előzővel ellentétben nagybetűssé alakítja a karaktereket.</li></ul><p>Az előző négy metódust egy példában mutatom be:</p><p><img class="shadow" src="./resources/variable_types_string_methods_tolower_toupper.gif" alt="String metódusok"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods" rel="noopener noreferrer" target="_blank">String methods</a></p></div>

      <h2>Keresés és módosítás egy Stringen belül</h2>

      <div class="content"><h2><code>indexOf()</code></h2><p>Megkeresi a Stringen belül egy adott szövegrész kezdetét.
        A kezdő karakter indexét adja vissza, amely 0-tól kezdődik, azaz az első karakter a 0 sorszámú és így tovább.</p><p><img class="shadow" src="./resources/variable_types_string_methods_indexof.gif" alt="String metódusok"></p><h2><code>replace()</code></h2><p>Kicseréli a megadott szövegrészt a Stringen belül. Ahogy a példában is látni fogod, ennek a metódusnak kettő darab úgynevezett paramétere van, tehát két adatot kell a zárójelek között megadni: először azt, amit cserélni szeretnél, azután pedig azt, amire ki szeretnéd cserélni.</p><p><img class="shadow" src="./resources/variable_types_string_methods_replace.gif" alt="String metódusok"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods" rel="noopener noreferrer" target="_blank">String methods</a></p></div>

    <h2>Igaz vagy hamis értékek - Boolean</h2>

    <div class="content"><p>A legegyszerűbb változó a Boolean típusú. Csak két értéket vehet fel, ezért a leggyakrabban egy biten tárolható, mert vagy <strong>0 = hamis</strong>, vagy <strong>1 = igaz</strong> az értéke.</p><h2>Boolean típus</h2><ul><li>Igaz - hamis értékeket tárol.</li><li>Segítségével egy biten tudod tárolni a logikai értékeket.</li><li>Két értéket vehet csak fel: <code>true</code> vagy <code>false</code>.</li><li>Mivel nagyon egyszerű típus, az előzőekben megismert típusokkal szemben nincsenek külön metódusai.</li></ul><p>A <code>Boolean</code> típusú változókat elsősorban kiértékelések során tudod felhasználni.</p><p>Álljon itt egy egyszerű példa egy definícióról. A példában először definiálok egy új <code>Boolean</code> típusú változót <code>true</code> kezdőértékkel, majd felüldefiniálom <code>false</code>-szal:</p><p><img class="shadow" src="./resources/variable_types_boolean_definition.gif" alt="Boolean definíció"></p><h2>Logikai kifejezés</h2><p>Olyan kifejezés, amely kiértékelése után <code>true</code> vagy <code>false</code> értéket ad vissza.
        A logikai kifejezések értékekből és operátorokból épülnek fel, például <code>x &lt; y</code> egy logikai kifejezés, mert csak két eset lehetséges, hogy nagyobb vagy nem.
        Ha nagyobb, akkor <code>true</code> lesz az értéke, ha nem (azaz kisebb vagy egyenlő) akkor pedig <code>false</code>.</p><h2>Logikai operátorok</h2><p>Logikai kifejezésekben a következő operátorokat használhatod:</p><ul><li><code>&lt;</code> kisebb,</li><li><code>&gt;</code> nagyobb,</li><li><code>&lt;=</code> kisebb vagy egyenlő,</li><li><code>&gt;=</code> nagyobb vagy egyenlő,</li><li><code>==</code> megegyező érték,</li><li><code>===</code> megegyező érték és típus,</li><li><code>!=</code> nem megegyező érték,</li><li><code>!==</code> nem megegyező érték és típus,</li><li><code>!</code> tagadás - logikai érték megfordítása,</li><li><code>&amp;&amp;</code> és,</li><li><code>||</code> vagy.</li></ul><p>A logikai kifejezésekre szintén érvényesek a zárójelezés szabályai.</p><p>Az alábbi példákban bemutatom a fenti operátorok használatát:</p><p><img class="shadow" src="./resources/variable_types_boolean_operators.gif" alt="Boolean operátorok"></p><p><img class="shadow" src="./resources/variable_types_boolean_operators_2.gif" alt="Boolean operátorok"></p><h2>Különböző típusú változók és a <code>+</code> jel</h2><p>Azt már tudod, hogy a <code>+</code> jel segítségével számokat tudsz összeadni vagy stringek esetén össze tudod őket fűzni. De mi a helyzet, ha különböző típusú változóknál használom a <code>+</code> jelet?</p><p>Az alábbi példák ezt mutatják be:</p><p></p><pre><code class="javascript hljs"><span class="hljs-number">10</span> + <span class="hljs-string">"text"</span>     <span class="hljs-comment">// "10text" - a számot szövegként kezelte</span>
        <span class="hljs-number">10</span> + <span class="hljs-string">"10"</span>       <span class="hljs-comment">// "1010" - a számot szövegként kezelte most is, azonban:</span>
        <span class="hljs-number">10</span> - <span class="hljs-string">"1"</span>        <span class="hljs-comment">// 9, tehát kivonás esetében számként kezelte</span>
        <span class="hljs-number">10</span> + <span class="hljs-literal">true</span>       <span class="hljs-comment">// 11, a true-t 1-nek veszi</span>
        <span class="hljs-number">10</span> - <span class="hljs-literal">true</span>       <span class="hljs-comment">// 9</span>
        <span class="hljs-number">10</span> + <span class="hljs-literal">false</span>      <span class="hljs-comment">// 10, a false-t 0-nak tekinti</span>
        <span class="hljs-string">"10"</span> + <span class="hljs-literal">true</span>     <span class="hljs-comment">// "10true", a boolean értéket string-nek veszi</span>
        </code></pre><p></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean" rel="noopener noreferrer" target="_blank">Boolean típus</a></p></div>

        <h2>Az if feltétel használata</h2>

        <div class="content"><h2>If feltétel</h2><p>Gyakran kell eldönteni valamiről, hogy igaz vagy hamis.
            Ha eldöntöttük és igaz, akkor valamilyen műveletet kell végrehajtani, ha pedig nem igaz, akkor valami mást szeretnénk csinálni.</p><p><strong>Erre való az <code>if-else</code> programozási szerkezet.</strong></p><h2>Az <code>if</code> - <code>else</code> használata</h2><ul><li>Az <code>if</code> kulcsszó után zárójelben kell megadnod a logikai kifejezést.</li><li>A logikai kifejezés után kapcsos zárójelek között van az utasítás.</li><li>Az utasítás után jön az úgynevezett <code>else</code>, a saját utasításával. (Opcionális, azaz nem fontos az <code>if</code> után mindig jönni egy <code>else</code> utasításnak).</li></ul><p>Egy <code>if-else</code> állítás:</p><p><img class="shadow" src="./resources/statement_if_else.gif" alt="If else"></p><h2><code>else if</code></h2><p>Ha több esetet is szeretnél megvizsgálni, akkor több <code>if</code>-et is használhatsz.
            Ekkor az <code>else if</code> kapcsolattal fűzheted egymás után a logikai kifejezéseket.
            Ebben a példában három lehetőséget vizsgálunk, ha - különben ha - különben:</p><p><img class="shadow" src="./resources/statement_else_if.gif" alt="else if"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else" rel="noopener noreferrer" target="_blank">If and Else</a></p></div>

    <h2>Az if feltétel egyszerűsítése</h2>

    <div class="content"><h2>Egyszerűsített vizsgálat</h2><p>Ha csak egyszerű vizsgálatot végzünk, akkor az if...else helyett használhatod az úgynevezett három operandusos kifejezést is.</p><h2>Három operandusos kifejezés</h2><p>Általában értékadáskor használható jól, ha mondjuk megnézed, hogy létezik-e egy bizonyos változó. Ha a kifejezés igaz, akkor a kérdőjel utáni értéket adja vissza, ha hamis, akkor a kettőspont utánit.</p><p><img class="shadow" src="./resources/statement_tenary.gif" alt="Ternary operators"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else" rel="noopener noreferrer" target="_blank">If and Else</a></p></div>

    <h2>A validálást végző űrlap bemutatása</h2>

    <p>Itt már elég sok mindent vizsgálni kell, viszont veszélyes lehet, hogy a fejlesztő mindig elfogult valamennyire a saját munkájával szemben.</p>

    <h2>A továbbfejlesztett űrlap átadása</h2>
    <p>Egy sikeres átadás mindig öröm, utána szusszan egyet a csapat, de általában hamar jönnek az újabb kihívások.</p>

    <h1>Optimalizálás</h1>

    <h2>A fizetendő összeg számítása</h2>

    <p>A legtöbbször nem elég, ha jól működik egy alkalmazás, lehetőséget kell adni arra is, hogy a felhasználó korrigálhassa a már bevitt értékeket.</p>

    <h2>1. feladat - A rendelés végösszegének módosítása</h2>
    <div class="content"><h2>Feladat</h2><p>Módosítsd&nbsp;az elkészült ürlapot úgy, hogy a fizetendő díjba számítson bele 500 Ft házhoz szállítási díjat is, ha a rendelés értéke 5000 Ft alatt van!</p><p>Szervezd külön-külön függvényekbe a kódod a könnyebb áttekinthetőség végett! Legalább 3 függvényed legyen:</p><ul><li>Az első kommunikál a felhasználói felülettel: leolvassa az űrlapadatokat és kiírja a fizetendő összeget.</li><li>A második validálja a kapott adatokat. Hibás vagy hiányzó adat esetén jelzi a hibát. (Például felugró ablakban.)</li><li>A harmadik számítja ki a fizetendő összeget.</li></ul><p>Ennél több függvényt is készíthetsz, ha szeretnél. Például az adatok validálása történhet akár űrlapelemenként is.</p></div>

    <h2>A függvények áttekintése</h2>

    <div class="content"><h2>Függvények - innen nincs visszaút</h2><p>Ha megismered a függvények korlátlan világát, végleg függő leszel ;-)</p><h2>Mi a függvény?</h2><p>A függvény egy egyszerű gép. Bedobáljuk a hozzávalókat, elvégzi a feladatát és a végén kidobja az eredményt.</p><p>Emlékszel még második osztályban? Bedobom a gépbe a hármat és a négyet, tizenkettőt dob ki. Mit csinál a gép? Nyilván összeszorozza a két kapott paramétert. Ugyanígy lehet elképzelni a függvényeket.</p><p><strong>Hivatalosan: azokat a kódrészleteket amelyeket gyakran használunk, kiemelünk függvényekbe.</strong></p></div>

    <h2>A függvények használata</h2>

    <div class="content"><h2>Függvények használata</h2><p>Ahhoz, hogy használni tudj egy függvényt, legalább két lépésre van szükség:</p><ul><li><strong>Declaration:</strong> megadom a függvény nevét és leírom a működését.</li><li><strong>Invocation:</strong> a kód megfelelő helyén meghívom (elindítom) a függvényt.</li></ul><h2>Deklarálás</h2><p>Függvényt a <code>function</code> kulcszóval hozhatsz létre. Két lehetőséged van:</p><ul><li><code>function testFunction() {...}</code> : ez a függvény deklaráció,</li><li><code>let testFunction = function() {...}</code> : ez a függvény expression (úgy adod meg, mint egy változót).</li></ul><p>A két megadási mód között nincs működésbeli különbség. A teljes szintaxis:</p><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span>(<span class="hljs-params">parameter1, parameter2, ..., parameterX</span>) </span>{
        <span class="hljs-comment">// a futtatható kód</span>
      }</code></pre><p></p><h2>Invocation - függvény meghívása</h2><p>Az invocation, azaz a függvény meghívása azt jelenti, hogy elindítod a függvényt, az pedig végrehajtja a feladatát. Ezt a függvény neve után tett zárójelekkel teheted meg. Ezt hívják függvényhívásnak, azaz <b>call</b>-nak:</p><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">a, b</span>) </span>{
        alert(<span class="hljs-string">"Hello Dude!"</span>); <span class="hljs-comment">// megjelenít egy üzenetet amikor meghívják a függvényt</span>
      }
      myFunction();   <span class="hljs-comment">// az üzenet megjelenik</span></code></pre><p></p><h2>Függvény vagy eljárás?</h2><p>Ha egy függvény nem ad vissza semmilyen adatot miután végzett a feladatával, azt eljárásnak szoktuk pontosan hívni. A függvények a futásuk végén visszaadnak valamilyen értéket. Ezt a <code>return</code> kulcsszóval tudod meghatározni:</p><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">a, b</span>) </span>{
        <span class="hljs-keyword">return</span> a * b;             <span class="hljs-comment">// a függvény visszaadja az a és b szorzatát</span>
      }
      <span class="hljs-keyword">var</span> x = myFunction(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">// tehát az eredmény 12 lesz, ami bekerül az x változóba</span></code></pre><p></p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_functions.asp" rel="noopener noreferrer" target="_blank">Functions</a></p></div>

      <h2>A tiszta kód szabályai - Clean Code</h2>

      <div class="content"><h2>Clean Code</h2><p>Ahhoz, hogy a kódod később is ismerős legyen, illetve hogy mások is megértsék, fontos hogy tisztán és átláthatóan dolgozz. A változóknál már foglalkoztunk kicsit a jó nevekkel, itt most kibővítve vesszük át a dolgot.</p><blockquote><b>Fontos:</b> célunk az, hogy olyan kódot írjunk, ami úgy olvasható mintha mondatokat olvasnánk.</blockquote><h2>Elnevezési szabályok</h2><p>A változók és függvények nevei alapvető fontosságúak egy kódban. Nem kell sajnálni a karaktereket arra, hogy beszédes neveket válassz.</p><h3>Beszédes nevek</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> n; <span class="hljs-comment">// nem jó</span>
        <span class="hljs-keyword">let</span> nrOfProducts; <span class="hljs-comment">// nem jó</span>
        <span class="hljs-keyword">let</span> numberOfProducts; <span class="hljs-comment">// jó</span></code></pre><p></p><p>Nincs szükség kommentekre, ha kifejező az elnevezés.</p><h3>Ne legyen a név félrevezető</h3><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adder</span>(<span class="hljs-params">a, b</span>) </span>{
          <span class="hljs-keyword">return</span> a * b;
        }</code></pre><p></p><p>Nevezd át az osztályt, metódust, változót, stb. amikor a jelentése változik.</p><h3>O és I kerülése</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> O;
        <span class="hljs-keyword">var</span> l;</code></pre><p></p><p>A kisbetűs L és nagybetűs O használata is félreinformálhat, mert úgy néznek ki, mint a 0 és az 1.</p><h3>Használj könnyen kiejthető neveket</h3><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getYYYY</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// rossz</span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getYear();
        }
        
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getYear</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// jó</span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getYear();
        }
        </code></pre><p></p><h2>Kommentek</h2><h3>Ritkán írj kommenteket!</h3><ul><li>Ha sűrűn jelennek meg kommentek a kódban, elkezdünk nem törődni velük.</li><li>Tartogasd a kommenteket olyan speciális esetekre, amikor a figyelem felhívására van szükség.</li><li>A jó komment olvasója hálás lesz, hogy az a komment megíródott.</li></ul><h3>Informatív komment</h3><p> Valóban plusz inforációt közöl az olvasóval:</p><p></p><pre><code class="javascript hljs"><span class="hljs-comment">// matches any alphabetic character between m and n</span>
        <span class="hljs-keyword">var</span> idPattern = <span class="hljs-regexp">/m[a-z]n/</span>;
        </code></pre><p></p><h2>Formázás</h2><p>Fontos a formázás? Amikor a forráskódod olvasója ránéz a kódodra, akkor először akaratlanul is annak formázását figyeli meg (és nem a neveket vagy valami mást). A formázás a kommunikációról szól. Egy jól "kommunikáló" kódot könnyű változtatni és karban tartani, tehát a cégnek pénzt takarít meg.</p><h3>Mi számít a formázásnál?</h3><ul><li>Fájl méret</li><li>Függőleges formázás</li><li>Vízszintes formázás</li><li>Indentáció</li></ul><h3>Fájl méret</h3><ul><li>Rövid fájlméreteket tarts fenn!</li><li>De mi számít rövidnek? A statisztikák arra mutatnak rá, hogy a modern szoftverek átlagosan 50-60 soros fájlokat tartalmaznak, míg más szoftverek 200-at.</li></ul><h3>Függőleges formázás - Üres sorok elválasztó eszközként</h3><p></p><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>{
          <span class="hljs-keyword">constructor</span>(name) {
            <span class="hljs-keyword">this</span>.name = name;
        
            <span class="hljs-keyword">this</span>.initPeople();
          }
        
          initPeople() {
            <span class="hljs-comment">//</span>
          }
        }</code></pre><p></p><p>A változók definícióit a konstruktorban elválasztottam a metódus hívásoktól.</p><h3>Vízszintes formázás – sorok hossza</h3><p>Tartsd a sorok hosszát maximum 80 karakternél. Így nem kell soha vízszintesen görgetni amikor a kódot olvasod.</p><h3>Indentáció</h3><p>Az indentáció azt jelenti, hogy egyes sorok beljebb kezdődnek a többinél.</p><ul><li>A szóköz használata jobb, mert minden szerkesztőban ugyanakkora lesz, függetlenül a tab méretétől.</li><li>2 vagy 4 szóköz is lehet.</li><li>De: használja mindenki ugyanazt az indentációs stílust a csapatban.</li></ul><h2>Függvények</h2><p>Egy függvény egy és csakis egy dolgot csináljon!
        Akkor jó a függvény, ha már nem lehet értelmesen több másik függvénybe kiszervezni a működését.</p><ul><li>4 - 6 sor az ideális hosszúság, 10 már sok.</li><li>A függvények nevénél igét vagy ige szerkezetet válassz.</li><li>A függvénynek maximum 3 argumentuma - paramétere legyen.</li></ul><h2>Összefoglalás</h2><p>A fenti szabályok a legtöbb esetben hasznosak amikor dolgozol. De sokszor előfordul, hogy a csapat más szabályokban egyezik meg praktikussági okokból, ebben az esetben természetesen azok az irányadóak.</p></div>

        <h2>Függvények paraméterezése</h2>

        <div class="content"><h2>Paraméterre fel!</h2><p>Ahogy a metódusoknál láttad, a függvényeket paraméterekkel tudod ellátni.</p><blockquote><strong>Paraméter - argumentum:</strong> bemenő adat, amellyel a függvény műveleteket végez.</blockquote><h2>Paraméterek sorrendje</h2><p>A paraméterek ugyanabban a sorrendben kerülnek feldolgozásra, ahogyan azt megadtad a függvény létrehozásánál. Ezért vigyázni kell, ne hagyj ki paramétereket, mert nem ugyanazt fogja érteni a függvény, mint amit megadtál:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Joe'</span>;
            <span class="hljs-keyword">var</span> job = <span class="hljs-string">'programmer'</span>;
            
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPerson</span>(<span class="hljs-params">name, job</span>) </span>{
              <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.card'</span>).innerHTML = <span class="hljs-string">'Név: '</span> + name + <span class="hljs-string">', munka: '</span> + job;
            }
            
            showPerson(name, job); showPerson(job, name);</code></pre><p></p><p>Az első esetben azt írja ki: <code>Név: Joe, munka: programmer</code><br>Majd utána: <code>Név: programmer, munka: Joe</code></p><h2>Arguments - Paraméterek ellenőrzése</h2><p>Az <code>arguments</code> tömb tartalmazza a függvény által kapott paramétereket. Ezzel le is tudod ellenőrizni, hogy megfelelő paramétereket kaptál-e.</p><h2>Default paraméter</h2><p>A JavaScript legújabb verziójában már vannak úgynevezett alapértelmezett vagy default értékei a paramétereknek, de ezt még nem minden böngésző támogatja. Ezért magunknak kell leellenőrizni a paramétereket, és ha nem megfelelő az értékük, akkor beállítani valami értelmesre:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Joe'</span>;
            <span class="hljs-keyword">var</span> job = <span class="hljs-string">'programmer'</span>;
            <span class="hljs-keyword">var</span> card = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.card'</span>);
            
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPerson</span>(<span class="hljs-params">name, job</span>) </span>{
              name = name || <span class="hljs-string">'Balázs'</span>;
              job = job || <span class="hljs-string">'admin'</span>;
              card.innerHTML = <span class="hljs-string">'Név: '</span> + name + <span class="hljs-string">', munka: '</span> + job;
            }
            
            showPerson();</code></pre><p></p><p><strong>Az új szabvány szerint:</strong></p><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPerson</span>(<span class="hljs-params">name = <span class="hljs-string">'Balázs'</span>, job = <span class="hljs-string">'admin'</span></span>) </span>{
              card.innerHTML = <span class="hljs-string">'Név: '</span> + name + <span class="hljs-string">', munka: '</span> + job;
            }
            
            showPerson();
            </code></pre><p></p><h2>Dokumentáció</h2><p><a href="http://www.w3schools.com/js/js_functions.asp" rel="noopener noreferrer" target="_blank">Functions</a></p></div>

    <h2>A változók felhasználási területe - Scope</h2>

    <div class="content"><h2>Scope</h2><p>Azt jelenti angolul, hogy terület, hatáskör, esetleg kiterjedés. A változók scope-ja az a része a programkódnak, ahol a változóval lehet dolgozni, el lehet érni. Azaz egy változó nem használható a teljes programban, csak a scope-jában. Kifejtem részletesebben, figyelj.</p><h2>Egy alapvető szabály</h2><blockquote class="margin-top-1"><strong>A scope-ból kifelé mindig lehet látni, de befelé nem.</strong></blockquote><p>Mit jelent ez? Képzeld el, hogy egy olyan fólia van az ablakon, amitől látod, hogy mi van kint, de kintről nem látnak be. Pont így működik a js scope is. Egy scope -ban az összes változóval tudsz dolgozni, amit a sope -on kívül hoztak létre, de ha a scope -on belül van egy másik scope, abba nem látsz bele. Tehát a gyerek scope változóival nem tudsz dolgozni. A követkeőkben változó fajtánként is kifejtem neked a dolgot.</p><h2>A <code>var</code> scope</h2><p>A js 2015 előtti verziójában egyféleképpen lehetett változókat létrehozni a <code>var</code>, azaz variable kulcsszóval.</p><p><strong>function scope:</strong> A <code>var</code> paranccsal létrehozott változó függvény hatáskörű volt, ez azt jelenti, hogy vagy a kód gyökerében, vagy abban a függvényben lehetett csak használni, ahol létrehozták. Ha máshonnan akartad elérni, akkor hibát kaptál. Tehát a függvényekben létrehozott változóid nem voltak elérhetőek (láthatóak) a függvényen kívül.</p><p><strong>local scope:</strong> A függvény saját scope-ját lokális scope-nak is nevezzük.</p><p><strong>global scope:</strong> A függvényen kívül eső területet pedig globális scope-nak hívjuk. Az, hogy egy scope globális vagy likális ugye attól függ, hogy honnan nézed? Erre hozok most néhány példát.</p><h2>Lokális változó definiálása</h2><p></p><pre><code class="javascript hljs"><span class="hljs-comment">// Global scope: a carName változót itt nem használhatod</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> carName = <span class="hljs-string">"Volvo"</span>; <span class="hljs-comment">// Local scope: Itt használhatod a carName változót</span>
        }
        myFunction();
        <span class="hljs-built_in">console</span>.log( carName ); <span class="hljs-comment">// Uncaught ReferenceError: carName is not defined</span></code></pre><p></p><p><b>Mit láttál most?</b></p><ul><li>Létrehoztam egy függvényt, amiben definiáltam a <code>carName</code> változót.</li><li>Le is futtattam a függvényt, így a <code>carName</code> változó biztosan létre is jött a függvényben.</li><li>Megpróbáltam kiíratni a console-ra a változót, de a kommentben látható hibát kaptam.</li><li>Milyen hiba? <code>Uncaught ReferenceError</code> : váratlan vagy kezeletlen referenciahiba. Azaz olyan dologra - változóra hivatkoztam, olyan változóval akartam dolgozni, ami nem létezik. <code>carName is not defined</code> szép passzív angol szerkezettel meg van mondva: a <code>carName</code> változó nincs definiálva, nem lett létrehozva. Azt mondod, dehogynem, hát a függvényben ott van. Igen ám, de a függvénybe nem látunk bele a globális scope -bó, tehát számunkra nem létezik ott, ahol a log parancsot kiadtam.</li></ul><h2>Globális változó definiálása</h2><p>A globális változó előnye, hogy a kódon belül bárhol eléred. Hátránya, hogy így a program több memóriát fogyaszt. Miért is? Hát azért mert amikor egy függvényt elindít, akkor át kell adnia neki az összes globális változót, mert nem tudhatja hogy használni akarod-e valamelyiket? Ezért ha lehet, mindig lokális változókkal dolgozz.</p><p></p><pre><code class="javascript hljs"><span class="hljs-comment">// Global scope: a carName változót itt használhatod, mert itt hoztad létre</span>
        <span class="hljs-keyword">var</span> carName = <span class="hljs-string">"Volvo"</span>;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-comment">// Local scope: Itt is használhatod a carName változót, mert globális</span>
          <span class="hljs-built_in">console</span>.log( carName ); <span class="hljs-comment">// "Volvo"</span>
        }
        myFunction();
        <span class="hljs-built_in">console</span>.log( carName ); <span class="hljs-comment">// "Volvo"</span></code></pre><p></p><blockquote class="margin-top-2"><b>Fontos:</b> ugyanaz a példa, de a <code>carName</code> globális változó. Mind a két alkalommal el tudom érni, a függvényben és a globális scope-ban is.</blockquote><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_scope.asp" rel="noopener noreferrer" target="_blank">JS scope</a></p></div>

        <h2>Let használata var helyett</h2>

        <div class="content"><h2>Let</h2><p>A 2015-ös js szabványban hozták be a <code>let</code> kulcsszót. A tanfolyamon ezt használjuk már a <code>var</code> helyett, mert hatékonyabb és takarékosabb mint a másik.</p><h2>A blokk</h2><p>A js kód blokkokból épül fel. Ezeket kapcsos zárójelekkel <code>{}</code> jelölik. Egy tipikus blokk ilyen:</p><p></p><pre><code class="javascript hljs">{  <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>; }
        </code></pre><p></p><h2><code>let</code> scope</h2><p>A <code>let</code> kulcsszóval létrehozott változók block scope-úak, egy blokkon belül lehet őket elérni. Ez fontos különbség, mivel így a változó kisebb kódrészben érhető el. Viszont amikor az adott blokk lefut, hamarabb is törlődik a memóriából, így takarékosabb tud lenni a program.</p><h2>Block scope</h2><p> A <code>{}</code> zárójelekkel határolt programterület.</p><p></p><pre><code class="javascript hljs">{  <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>; <span class="hljs-keyword">let</span> y = <span class="hljs-number">3</span>; }
        <span class="hljs-built_in">console</span>.log( x ); <span class="hljs-comment">// 2</span>
        <span class="hljs-built_in">console</span>.log( y ); <span class="hljs-comment">// Uncaught ReferenceError: y is not defined</span></code></pre><p></p><p><b>Lássuk csak!</b></p><ul><li>Az <code>x</code> változót lazán eléred a blokkon kívül is, mivel az function scope-ú, és nem hoztál létre új függvényt, a hagyományos function scope alapján ugyanabban a scope-ban van.</li><li>Viszont az <code>y</code> esetén hibát kapsz, mert az block scope-ú és egy blokkban hoztad létre, ahova a global scope-ból nem látsz bele.</li></ul><h2><code>let</code> módosítása</h2><p>A <code>let</code> kulcsszóval létrehozott változóknál nem lehet a változót kétszer létrehozni egy scope-ban.</p><p><b>Blokkon belül nem lehet újradeklarálni:</b></p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">"Péter"</span>;
        <span class="hljs-keyword">let</span> name = <span class="hljs-string">"Sándor"</span>; <span class="hljs-comment">// Uncaught SyntaxError: Identifier 'name' has already been declared</span></code></pre><p></p><p>A gondja az, hogy már létre lett hozva azonos néven egy változó, azaz az azonosító már deklarálva van.</p><p><b>Blokkon belül lokális változó jön létre:</b></p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">"Péter"</span>;
        {
          <span class="hljs-keyword">let</span> name = <span class="hljs-string">"Sándor"</span>;
          <span class="hljs-built_in">console</span>.log( name ); <span class="hljs-comment">// "Sándor"</span>
        }
        <span class="hljs-built_in">console</span>.log( name ); <span class="hljs-comment">// "Péter"</span></code></pre><p></p><p>Először azt írja ki, hogy "Sándor", majd azt hogy "Péter". A blokkon belül létrehozott <code>name</code> változó nem azonos a globális <code>name</code> változóval. Tehát nem a globális változót hoztam létre újra, hanem a blokknak saját változója van.</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_let.asp" rel="noopener noreferrer" target="_blank">JS let keyword</a></p></div>

        <h2>Konstansok használata - const</h2>

        <div class="content"><h2>Constant</h2><p>Ez az angolban is a latinból jön (mint annyi minden más is). Azt jelenti, hogy állandó. Olyan változóról van szó, aminek egyszer lehet csak értéket adni, amikor létrehozod. Később már az értékét nem tudod megváltoztatni. Ilyen értelemben nem is változó, mert nem tudod változtatni. Azért neveztem mégis így, mert a js esetén bizonyos keretek között módosítható (erről majd a tömböknél és az objektumoknál lesz szó).</p><h2>A <code>const</code> keyword</h2><p>Ha egy változót a <code>const</code> kulcsszóval hozol létre, akkor nem adhatsz neki új értéket.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.141592653589793</span>;
            PI = <span class="hljs-number">3.14</span>;     <span class="hljs-comment">// Uncaught TypeError: Assignment to constant variable.</span>
            PI = PI + <span class="hljs-number">10</span>;  <span class="hljs-comment">// Uncaught TypeError: Assignment to constant variable.</span>
            </code></pre><p></p><h2>Szabályok</h2><ul><li>Mindig nagy betűvel írjuk: <code>PI</code>, <code>START</code>, <code>BASE_COLOR</code>, stb...</li><li>Mindig értéket is kell neki adni amikor létrehozzuk: <code>const BASE_COLOR = 255;</code></li></ul><h2>A <code>const</code> scope</h2><p><strong>Block scope:</strong> a <code>const</code> a <code>let</code>-hez hasonlóan szintán blokk szintű változó, azaz egy blokkon belül látható. Ha a kód gyökeréban hozod létre akkor mindenhol, ha nem akkor a saját blokkján belül.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span>;
            {
              <span class="hljs-keyword">const</span> x = <span class="hljs-number">2</span>;
              <span class="hljs-built_in">console</span>.log( x );
            }
            <span class="hljs-built_in">console</span>.log( x );</code></pre><p></p><p>A <code>let</code>-es példához hasonlóan itt is különböző számokat fogsz látni, a blokkon belül egy másik x van, aminek az értéke 2, a globális scope-ban pedig a 10 értékű.</p><h2><code>const</code> redeclare</h2><p>Na ez az ami nem fog menni. Az alábbi példában azt láthatod, hogy ha egyszer egy blokkon belül létrehoztál egy <code>const</code> változót, akkor azt semmilyen formában nem tudod újra létrehozni, sem újra definiálni azaz új értéket adni neki (persze az adott blokkon belül, ha nyitsz új blokkot akkor igen).</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> x = <span class="hljs-number">2</span>; <span class="hljs-comment">// Rendben</span>
            <span class="hljs-keyword">const</span> x = <span class="hljs-number">3</span>; <span class="hljs-comment">// Hiba</span>
            x = <span class="hljs-number">3</span>;       <span class="hljs-comment">// Hiba</span>
            <span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;   <span class="hljs-comment">// Hiba</span>
            <span class="hljs-keyword">let</span> x = <span class="hljs-number">3</span>;   <span class="hljs-comment">// Hiba</span>
            {
              <span class="hljs-keyword">const</span> x = <span class="hljs-number">2</span>;   <span class="hljs-comment">// Rendben</span>
              <span class="hljs-keyword">const</span> x = <span class="hljs-number">3</span>;   <span class="hljs-comment">// Hiba</span>
              x = <span class="hljs-number">3</span>;         <span class="hljs-comment">// Hiba</span>
              <span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;     <span class="hljs-comment">// Hiba</span>
              <span class="hljs-keyword">let</span> x = <span class="hljs-number">3</span>;     <span class="hljs-comment">// Hiba</span>
            }</code></pre><p></p><p>Ezt jól jegyezd meg!</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_const.asp" rel="noopener noreferrer" target="_blank">JS const</a></p></div>

            <h2>A függvényekkel bővített kód bemutatása</h2>

            <p>Szép munka.</p>

            <h2>A házhozszállítással kiegészített űrlap átadása</h2>

            <p>A puding próbája az evés.</p>

    <h1>Időjárás-előrejelzés</h1>

    <h2>Időjárás-előrejelzés készítésével kapcsolatos igények megfogalmazása</h2>

    <p>Tamás világosan fogalmaz.<br>A kérdés, hogy a rendszeren át tud-e úgy menni az info, hogy ne torzuljon?</p>

    <h2>1. feladat - Időjárás-előrejelzés elkészítése</h2>

    <div class="content"><h2>Feladat</h2><p>Készíts egy időjárás widgetet a hamburgerező weboldalának tetejére! A widget egy JavaScript fájlban eltárolt hőmérsékleti adatokból jeleníti meg a kiválasztott naphoz tartozó hőmérsékletet.</p><ol class="list-strong"><li><span>Készíts egy HTML szakaszt az <strong>order-form.html</strong> lap tetejére, amelyben egy legördülő lista, egy gomb és egy a hőmérséklet megjelenítésére alkalmas rész van! A legördülő listával a hét napjai közül lehessen választani. A napokhoz társított érték a nap sorszáma legyen 0-tól 6-ig! A szakaszban jelenítsd meg az "Időjárás" szöveget is!</span></li><li><span>Készíts egy JavaScript fájlt, amelyben egy globális tömb típusú változóban eltárolod a hét hőmérsékleti adatait!</span></li><li><span>Írj egy olyan függvényt, amely kiolvassa a legördülő listából a kiválasztott értéket, és ez alapján megjeleníti az adott napi hőmérsékletet! Ahhoz, hogy működjön, a gomb lenyomására futtasd le a függvényt! A gombban állítsd be az <code>onclick</code> attribútum értékének a függvényed nevét zárójelekkel! (Például ha a függvényed neve weatherWidget, akkor a HTML fájlba a gombba ez kerül: <code>onclick="weatherWidget()"</code>.)</span></li><li><span>Formázd meg a widgetet, hogy megjelenésében illeszkedjen az oldalhoz!</span></li><li><span>Illeszd be az elkészült widgetet az összes oldal tetejére!</span></li></ol></div>

    <h2>A tömbök áttekintése</h2>

    <div class="content"><h2>Listák és Tömbök</h2><p>Amikor a számítógépet kifejlesztették, nem játszottak rajta, nem rajzoltak vagy cseteltek, egész nap óriási listákat dolgoztak fel. A mai napig a programozás egyik alapvető feladata az adatokkal való munka. Az adathalmazokat a programok gyakran tömbökben tárolják, amelyek értékek listái.</p></div>

    <h2>A tömbök megismerése</h2>

    <div class="content"><h2><code>Array</code> - tömbösítsünk!</h2><p>Értékek indexelt halmaza. Ez a tömb. Úgy kell elképzelni, mint egy polc, ahová felpakoljuk a dolgokat.</p><p>Az index az a mutató, amivel eléred a tömb egyes elemeit. Tehát minden elemnek van egy száma a tömbön belül, amivel le tudod kérni az értékét, vagy módosítani tudod.</p><p>A tömbökbe szabadon elhelyezhetsz <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Object</code> sőt akár <code>Array</code> típusú elemeket is. Ha tömbbe tömböt teszel, akkor azt <strong>többdimenziós</strong> tömbnek is nevezik.</p><h2>Dinamikus</h2><p>JavaScript esetén a tömb dinamikus, ami azt jelenti, hogy bármikor vehetsz fel új elemet, vagy törölhetsz meglévőket. Ez nem minden programnyelv esetén van így, a legtöbbször előre meg kell adnod a tömböd hosszát. De szerencsére mi js-ben dolgozunk, úgyhogy ez legyen a Java-sok és a C#-osok gondja! :)</p><h2>Mixed</h2><p>Másik különbség például a Java nyelvvel szemben, hogy lehet mixelt a tömb, azaz egy tömbön belül különböző típusú elemeket is tárolhatsz.</p><h2>Tömb létrehozása</h2><p>Új tömböt legegyszerűbben a szögletes zárójelek használatával hozhatsz létre. Az alábbi példában egy három elemű tömböt definiálok:</p><p><img class="shadow" src="./resources/variable_types_array_definition.gif" alt="Array definíció"></p><h2>Hozzáférés a tömb elemeihez, az index</h2><p>Amikor elemeket adsz a tömbhöz, a JavaScript értelmező automatikusan megszámozza azokat.
        JavaScriptben a tömb indexek csak számok lehetnek.</p><blockquote><strong>FONTOS: az index mindig 0-val kezdődik!</strong><br>Azaz a tömb első elemének indexe 0, és nem 1.</blockquote><p>A példa azt mutatja meg, hogy egy tömb elemeit hogyan éred el és hogyan módosíthatod az indexük segítségével:</p><p><img class="shadow" src="./resources/variable_types_array_index.gif" alt="Array definíció"></p><h2>Többdimenziós tömbök</h2><p>Ezeknél egy tömböt egy másik tömbbe ágyaznak. Úgy képzeld el, mint egy Excel táblát, ahol a sorok a külső tömb elemei, a belső tömbök pedig a cellákat tartalmazzák.</p><p>Például:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> arr = [<span class="hljs-literal">true</span>, [<span class="hljs-string">'elso'</span>, <span class="hljs-string">'masodik'</span>, <span class="hljs-string">'harmadik'</span>], <span class="hljs-string">'Joe'</span>];</code></pre><p></p><p>A példában a tömb második eleme szintén egy tömb.<br>A beágyazott tömb második elemének elérése:</p><p></p><pre><code class="javascript hljs">arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]</code></pre><p></p><h2><code>isArray()</code>, tömb azonosítása</h2><p>A munkád során előfordul, hogy meg kell állapítanod egy változóról, hogy <code>Array</code> típusú-e?
        A <code>typeof</code> utasítás a tömböket <code>Object</code> típusúnak ismeri fel, ezért nem alkalmas az azonosításukra. Erre a célra az <code>Array</code> objektum <code>isArray</code> metódusa szolgál. Ha megadsz neki egy változót, akkor megállapítja, hogy tömb-e?</p><p>A példában a tömb esetén <code>true</code> értéket kapsz vissza, ami azt jelenti hogy igaz - azaz tömbbel van dolgod. Ellenkező esetben az eredmény <code>false</code> - hamis - azaz nem tömböt adtál át az <code>isArray</code> metódusnak:</p><p><img class="shadow" src="./resources/variable_types_array_isarray.gif" alt="Array definíció"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener noreferrer" target="_blank">Array</a></p></div>

    <h2>A tömbök metódusai</h2>

    <div class="content"><h2><code>Array</code> metódusok</h2><p>A tömbök esetén számos metódus áll rendelkezésre az adatok kereséséhez, ellenőrzéséhez, a tömbök vágásához vagy egyesítéséhez. Most csak a legalapvetőbbeket mutatom meg, később a függvények megismerése után visszatérünk még a magasabb szintű metódusokra is.</p><h2><code>push()</code></h2><p>Segítségével új elemet tudsz felvenni a tömb végére. Azaz az így felvett elem a tömböd utolsó eleme lesz. Fontos, hogy ez a metódus megváltoztatja az eredeti tömböt, azaz nem kell felüldefiniálnunk ahhoz, hogy a módosítások érvénybe lépjenek. Miután a metódus lefutott, a tömb új hosszát adja vissza.</p><blockquote><strong>FONTOS: módosítja az eredeti tömböt.</strong></blockquote><h2><code>pop()</code></h2><p>A <code>push()</code>-tól eltérően nem hozzáad, hanem elvesz egy elemet a tömb végéről.
        A törölt elemet adja vissza, és szintén azonnal módosul az eredeti tömb.</p><blockquote><strong>FONTOS: módosítja az eredeti tömböt.</strong></blockquote><p>A példában a <code>push()</code> és a <code>pop()</code> működését is bemutatjuk:</p><p><img class="shadow" src="./resources/variable_types_array_methods_push_pop.gif" alt="Array push pop"></p><h2><code>unshift()</code></h2><p>A <code>push()</code>-hoz hasonlóan működik, csak a tömb elejére ad hozzá új elemet, azaz eggyel hátrébb tolja az elemeket. Hatására minden meglévő tömbelem indexe eggyel nőni fog.</p><blockquote><strong>FONTOS: módosítja az eredeti tömböt.</strong></blockquote><h2><code>shift()</code></h2><p>Ez pedig a <code>pop()</code> párja, egy elemet kivesz a tömb elejéről, és a többit eggyel előre tolja. Hatására minden meglévő tömbelem indexe eggyel csökkenni fog.</p><blockquote><strong>FONTOS: módosítja az eredeti tömböt.</strong></blockquote><p>A példában az <code>unshift()</code> és a <code>shift()</code> működését is megmutatom neked:</p><p><img class="shadow" src="./resources/variable_types_array_methods_unshif_shift.gif" alt="Array shift unshift"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Methods" rel="noopener noreferrer" target="_blank">Array methods</a></p></div>

        <h2>A tömbök vágása és összeillesztése</h2>

        <div class="content"><h2>Tömbök vágása</h2><p>A tömbök több ezer vagy millió elemmel is rendelkezhetnek. Hasznos ha hatékonyan tudod őket vágni, vagy adott helyre új elemeket tudsz beilleszteni. Most erről lesz szó.</p><h2><code>slice()</code></h2><p>A tömböt vágja. Két számot vár, start és end a nevük.</p><ul><li><strong>start:</strong> azt adja meg, hogy hol kezdje a vágást. Ha 0, akkor a tömb elején kezdi, ha mínusz szám, akkor hátulról fogja számolni.</li><li><strong>end:</strong> azt adja meg hogy melyik elemnél fejezze be a vágást. Ugyanazok igazak rá, mint a startra.</li></ul><blockquote><strong>FONTOS: nem módosítja az eredeti tömböt, hanem egy új tömbbel tér vissza.</strong></blockquote><p><img class="shadow" src="./resources/variable_types_array_methods_slice.gif" alt="Boolean definíció"></p><h2><code>splice()</code></h2><p>A <code>slice</code>-szal ellentétben nem csak kivenni lehet elemeket vele, hanem hozzá is lehet adni a tömbhöz.</p><p>A szintaxisa a következő:</p><p></p><pre><code class="javascript hljs">array.splice(index, howmany, item1, ....., itemX)</code></pre><p></p><p>Paraméterei:</p><ul><li><strong>index:</strong> kötelező, azt adja meg hogy honnan induljon a vágás, olyan mint a <code>slice</code> esetén.</li><li><strong>howmany:</strong> azt adja meg, hogy hány elemet akarsz eltávolítani.</li><li><strong>item1, ..., itemX:</strong> azok az elemek, amiket az eltávolított elemek helyére akarsz tenni. Nem kötelező megadni, akkor csak eltávolítás lesz, hozzáadás nem.</li></ul><blockquote><strong>FONTOS: nem módosítja az eredeti tömböt, hanem egy új tömbbel tér vissza.</strong></blockquote><p><b>Megjegyzés: </b> a splice művelet után a <code>fruits</code> tömb így fog kinézni: <code>["Banana","Orange","Lemon","Kiwi","Apple","Mango"</code>].
            Azért mert nem vettünk ki egy elemet sem és a 2 indexűtől (azaz a harmadiktól), "Lemon"-tól kezdődően beszúrtam két új elemet.</p><h2><code>join()</code></h2><p>A tömbből <code>String</code>-et készít, az elemeket vesszővel elválasztva fűzi egymás után.</p><blockquote><strong>FONTOS: nem módosítja az eredeti tömböt, hanem egy új <code>String</code>-gel tér vissza.</strong></blockquote><p><img class="shadow" src="./resources/variable_types_array_methods_join.gif" alt="Array join"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Methods" rel="noopener noreferrer" target="_blank">Array methods</a></p></div>

    <h2>Paraméterek átadása</h2>

    <div class="content"><h2>Paraméterek átadása</h2><p>Amikor paramétereket adsz át egy függvénynek, akkor érdekes dolgok történnek a háttérben, ezért nem árt tisztában lenni azzal, hogy a függvények mit kezdenek a nekik átadott adatokkal.</p><h2>Primitívek átadása érték szerint</h2><p>Kis ismétlés:</p><p><b>Primitív változó típusok:</b> <code>Boolean</code>, <code>Number</code>, <code>String</code>, <code>Undefined</code>, <code>Null</code>.</p><p>Tehát a következő szabályok rájuk vonatkoznak.</p><p><b>Paraméter átadás érték szerint:</b> a primitív típusokat másolja a js. Azaz, amikor átadsz egy ilyen változót a függvénynek, akkkor egy másolatot készít az eredetiről és azzal dolgozik.</p><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callByValue</span>(<span class="hljs-params">varOne, varTwo</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"A függvényen belül"</span>);
        varOne = <span class="hljs-number">100</span>;
        varTwo = <span class="hljs-number">200</span>;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"varOne ="</span> + varOne +<span class="hljs-string">"varTwo ="</span> +varTwo);
      }
      
      <span class="hljs-keyword">let</span> varOne = <span class="hljs-number">10</span>;
      <span class="hljs-keyword">let</span> varTwo = <span class="hljs-number">20</span>;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"A függvény hívása előtt"</span>);
      
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"varOne ="</span> + varOne +<span class="hljs-string">"varTwo ="</span> +varTwo);
      callByValue(varOne, varTwo);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"A függvény hívása után"</span>);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"varOne ="</span> + varOne +<span class="hljs-string">" varTwo ="</span> +varTwo);</code></pre><p></p><p><b>Na, kitalálod mi lesz ennek a kimenete? Nem kell, én megmondom:</b></p><ul><li>A függvény hívása előtt: <code>varOne = 10, varTwo = 20</code></li><li>A függvényen belül: <code>varOne = 100, varTwo = 200</code></li><li>A függvény hívása után: <code>varOne = 10, varTwo = 20</code></li></ul><p><b>Miért ez a kimenet?</b></p><ul><li>Létrehoztam a <code>varOne</code> és <code>varTwo</code> változókat 10 és 20 értékekkel.</li><li>Amikor átadtam őket a függvénynek, akkor kiolvasta az értéküket, és ahogy a paraméterlistában megadtam <code>callByValue(varOne, varTwo)</code> azon a néven létrehozott két lokális változót a függvényben és az eredeti értékeket bemásolta ebbe az két új változóba. Amikor kiíratom a függvényben az értékeket, látszik hogy megváltoztak.</li><li>Mégis amikor az eredeti értékeket újra kiíratom a függvényhívás után, azok változatlanok maradnak. Azért <strong>mert nem az eredeti változókkal dolgozik a függvény, csak a másolatukkal</strong>.</li></ul><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_function_parameters.asp" rel="noopener noreferrer" target="_blank">Function parameters</a></p></div>

      <h2>Objektumok átadása referencia szerint</h2>

      <div class="content"><h2>Paraméterek átadása</h2><p>Amikor paramétereket adsz át egy függvénynek, akkor érdekes dolgok történnek a háttérben, ezért nem árt tisztában lenni azzal, hogy a függvények mit kezdenek a nekik átadott adatokkal.</p><h2>Objektumok átadása referencia szerint</h2><p>Mit nevezek itt objektumoknak? Azokat a változókat, amelyek nem primitív típusok. Itt elsősorban a már tanult tömbökre gondolok és lesznek még az Object típusok, amelyeket hamarosan megismersz.</p><p>Tehát a következő szabályok rájuk vonatkoznak.</p><p><b>Paraméter átadás referencia szerint:</b> az objektumokat nem másolja a js. Minden változónak van egy címe a memóriában. Amikor egy objektumot kap a függvény, akkor létrejön egy új név a lokális váltoozónak, de a memóriacím ahova mutat, az ugyanaz lesz. Tehát két különböző néven ugyanazt a változót éred el.</p><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callByReference</span>(<span class="hljs-params">arr</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Érték a függvényen belül"</span>);
        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;
        <span class="hljs-built_in">console</span>.log(arr);
      }
      
      <span class="hljs-keyword">let</span> varArray = [<span class="hljs-number">10</span>];
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Függvényhívás előtt"</span>);
      <span class="hljs-built_in">console</span>.log(varArray);
      callByReference(varArray);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Függvényhívás után"</span>);
      <span class="hljs-built_in">console</span>.log(varArray);</code></pre><p></p><p><b>Na, kitalálod mi lesz ennek a kimenete? Nem kell, én megmondom:</b></p><ul><li>Függvényhívás előtt: <code>[10</code>]</li><li>Érték a függvényen belül: <code>[100</code>]</li><li>Függvényhívás után: <code>[100</code>]</li></ul><p><b>Miért ez a kimenet?</b></p><ul><li>Létrehoztam a <code>varArray</code> tömböt <code>[10</code>] értékkel.</li><li>Amikor átadtam a függvénynek, szándékosan más nevet választottam a lokális változónak: <code>arr</code>, mivel az teljesen mindegy, hogy mi a neve a függvényen belül. A függvényben megváltoztattam a 0 indexű elemet és kiírtam. Látszik, hogy meg is változott.</li><li>Most jön a meglepetés: amikor az eredeti tömböt újra kiíratom a függvényhívás után, is megváltozott. Azért <strong>mert az eredeti változó refernciájával dolgozik, tehát ugyanazt a helyet módosítja a memóriában</strong>.</li></ul><p><b>Előnyei:</b></p><ul><li>A függvényre nézve globális objektumokat is könnyen tudsz módosítani.</li><li>Takarékoskodik a memóriával, mivel nem foglal új memóriaterületet mint a másolásnál.</li></ul><p><b>Hátrányai:</b></p><ul><li>Az átadott objektumokat akaratodon kívül módosíthatod.</li></ul><h2>Összefoglalva</h2><p>Ez a különbség a referencia és az érték szerinti átadás között :)</p><p><img class="shadow" src="./resources/pass-by-reference-vs-pass-by-value-animation.gif" alt="Value vs. Reference"></p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_function_parameters.asp" rel="noopener noreferrer" target="_blank">Function parameters</a></p></div>

      <h2>Az elkészített időjárás-előrejelzés bemutatása</h2>

      <p>Mindegy, hogy a közönség sír vagy nevet, csak ne köhögjön.</p>

      <h2>2. feladat - Aktuális ajánlatok megjelenítése</h2>

      <div class="content"><h2>Feladat</h2><p>Egészítsd ki az időjárás widgetet úgy, hogy hőmérséklettől függően különböző ajánlatokat is jelenítsen meg!</p><p>A hamburgerező úgy döntött, hogy hőmérséklettől függően minden nap más ajánlattal várja a vendégeket. Ezek a következők:</p><ul><li>0 °C alatt: forró csoki</li><li>0 °C&nbsp;- 15 °C: meleg tea</li><li>15 °C&nbsp;- 20 °C: finom süti</li><li>20 °C&nbsp;- 25 °C: fagyi</li><li>25 °C-tól: jéghideg limonádé</li></ul><ol class="list-strong"><li><span>Vegyél fel két új tömböt a JavaScript fájlodba! Az első tartalmazza a hőmérséklet kategóriák felső határait, a második a megjelenítendő ajánlatokat. Ez utóbbiakat tedd vendégcsalogató mondatokba!</span></li><li><span>A hőmérséklet alatt jelenítsd meg az adott napi hőmérséklethez tartozó ajánlatot!</span></li></ol></div>

      <h2>A for ciklus működése</h2>

      <div class="content"><h2>Ciklusok</h2><p>Folyamatosan ismétlődő programrészletek. Egy ciklus mindaddig ismétlődik amíg a feltétele igaz. Olyan, mintha azt mondanánk, addig csináld ezt, amíg igaz, hogy ...</p><h2>For</h2><p>A for ciklus minden programnyelvben megtalálható.</p><p>Három paramétere van:</p><ul><li>ciklusváltozó: egy <code>Number</code> típusú változó, minden futás után módosítod az értékét.</li><li>feltétel: <code>Boolean</code>, amíg ez a feltétel igaz (a ciklusváltozó értékvizsgálata), addig fut a ciklus.</li><li>léptetés: minden ciklus végén lefut, itt kell a ciklusváltozót növelni/csökkenteni.</li></ul><p><strong>Ciklusmag:</strong> az az utasítás vagy utasítások, amelyek a feltétel teljesülése esetén lefutnak.</p><p>Az alábbi példa egy for ciklust mutat be:</p><p><img class="shadow" src="./resources/loops_for.gif" alt="For loop"></p><h2>Elöltesztelős ciklus</h2><p>Először megvizsgálod, hogy a feltételed igaz-e, és ha igen, akkor lefut a ciklusmag.
        Tehát a for egy tipikusan elöltesztelős ciklus.</p><p>Fontos megjegyezni, hogy egy for ciklust bármikor átírhatsz while ciklusba. Tehát amit forral megvalósíthatsz azt while-lal is, csupán a szintaxis más. A while ciklussal később majd foglalkozunk, addig is a legtöbb feladatra tökéletes lesz a for.</p><h2>Tömb bejárása ciklussal</h2><p>Ha szeretnéd egy kollekció összes elemét végigjárni, és valamilyen vizsgálatot vagy műveletet végezni velük, akkor általában az első elemtől indulsz, lefut a ciklusmag, és növeled az iterátort. Ezt mindaddig kell ismételned, amíg a kollekció végére nem érsz, tehát ismerned kell hozzá a hosszát.</p><p>Tömb bejárása for ciklussal:</p><p><img class="shadow" src="./resources/loops_for_over_array.gif" alt="For over array"></p><h2><code>continue</code> és <code>break</code></h2><p><code>continue</code> : ha valamiért úgy döntesz, hogy mégsem akarod lefuttatni a teljes ciklusmagot, akkor a <code>continue</code> utasítással tovább tudsz ugrani a következő iterációra.</p><p><code>break</code> : a <code>break</code> utasítás nem a következő iterációra ugrik, hanem megszakítja a ciklust, azaz a ciklusmag többet nem kerül végrehajtásra, úgy is mondhatnánk, a program továbbmegy.</p><p>Continue és break használata:</p><p><img class="shadow" src="./resources/loops_for_continue_break.gif" alt="Objektum kulcsok"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener noreferrer" target="_blank">For ciklus</a></p></div>


        <h2>Összetett operátorok</h2>

        <div class="content"><h2>Compound operators</h2><p>Ez azt jelenti, hogy összetett operátorok. Itt arra utalnak, hogy a több operátort raksz egymás után és ezzel gyorsítod a kódolást.</p><h2>Lista</h2><p><img class="shadow" src="./resources/compound-operators.jpg" alt="Compound operators"></p><h2>A fontosak, amiket gyakran használsz majd</h2><ul><li>Hozzáadás: <code>x = x + 10&nbsp;</code> helyett <code>x += 10</code></li><li>Kivonás: <code>x = x - 10&nbsp;</code> helyett <code>x -= 10</code></li><li>Osztás: <code>x = x / 2</code> helyett <code>x /= 2</code></li><li>Modulus (maradék): <code>x = x % 2</code> helyett <code>x %= 2</code></li><li>Szorzás: <code>x = x * 10&nbsp;</code> helyett <code>x *= 10</code></li></ul><h2>Exotikum (nem kötelező tudni, csak agybővítésre)</h2><p>Nézzünk egy példát a bitwise azaz bitenkénti és műveletekre. Át kell váltani 2-es számrendszerbe és 32 biten ábrázolni a számokat majd elvégezni rajtuk az and <code>&amp;</code> műveletet:</p><ul><li>a 9: 00000000000000000000000000001001</li><li>a 14: 00000000000000000000000000001110</li><li>ott lesz egy, ahol mindkettőben egy van: 00000000000000000000000000001000</li><li>ha ezt visszaváltod 10-es számrendszerbe akkor az eredmény: 8</li><li>leírva ha x = 9 és y = 14: <code>x &amp;= y</code> az 8 lesz. Ennyi.</li></ul><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_operators.asp" rel="noopener noreferrer" target="_blank">JS operators</a></p></div>

        <h2>A ternary operátor</h2>

        <div class="content"><h2>Egyszerűsítsünk!</h2><p>Ha már az értékadásnál összevontuk az operátorokat, miért ne vonnánk össze az if...else esetén is?</p><h2>Ternary operator</h2><p>Ezt magyarul három operandusos kifejezésnek is szokták hívni.</p><h3>Szintaxis:</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> variablename = (condition) ? value1: value2</code></pre><p></p><p>Szóval ha a kondíció igaz, akkor az első, ha nem akkor a második érték kerül bele a változóba.</p><h3>Részei</h3><ul><li><b>változó neve:</b> a változó neve</li><li><b>értékadás:</b> <code>=</code> ezt ismered, értéket adunk egy változónak</li><li><b>feltétel:</b> <code>4 &gt; 5</code> lehet bármilyen kifejezés, amit Boolean-ként ki lehet értékelni</li><li><b>?</b> a kérdőjel után jön az az érték, ami a kifejezés <code>true</code> értékéhez tartozik</li><li><b>:</b> a kettőspont után épedig az, ami a <code>false</code> értékhez tartozik</li></ul><h2>Példák</h2><h3>Hagyományos if...else módszerrel</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> age = <span class="hljs-number">33</span>;
            <span class="hljs-keyword">let</span> voteable;
            <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) {
                voteable = <span class="hljs-string">"Too young"</span>;
            } <span class="hljs-keyword">else</span> {
                voteable = <span class="hljs-string">"Old enough"</span>;
            }
            <span class="hljs-built_in">console</span>.log( voteable );</code></pre><p></p><h3>Ternary operátorral</h3><p>Az értékadás 5 sor helyett kemény 1 lett:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> age = <span class="hljs-number">33</span>;
            <span class="hljs-keyword">let</span> voteable = (age &lt; <span class="hljs-number">18</span>) ? <span class="hljs-string">"Too young"</span>: <span class="hljs-string">"Old enough"</span>;
            <span class="hljs-built_in">console</span>.log( voteable );</code></pre><p></p><p>Azt fogja visszaadni, hogy "Old enough" azaz elég idős. Azért, mert az age nem kisebb mint 18, a feltétel nem igaz és így a második érték kerül a <code>voteable</code> változóba.</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/jsref/jsref_operators.asp" rel="noopener noreferrer" target="_blank">JS operators</a></p></div>

    <h2>Az aktuális ajánlatok bemutatása</h2>

    <p>A jól végzett munka után jön a megérdemelt dicséret.</p>

    <h2>3. feladat - Statisztikai adatok megjelenítése</h2>

    <div class="content"><h2>Feladat</h2><p>Módosítsd az időjárás widgetet úgy, hogy jelenítse meg a heti hőmérsékletek minimumát, maximumát és átlagát is!</p><ol class="list-strong"><li><span>Vegyél fel a <strong>contact.html</strong> fájlban három új bekezdést a widgetbe, amelyekben megjelenítheted a hőmérsékleti statisztikákat.</span></li><li><span>A JavaScript fájlban a három számítást három külön függvényben készítsd el, majd a megjelenítésnél ezeket a függvényeket hívd meg!</span></li><li><span>A másik három oldalon is módosítsd a widgetet!</span></li></ol></div>

    <h2>Ismerkedés az algoritmusokkal</h2>
    
    <div class="content"><h2>Algoritmus, avagy al-Hvárizmi kicsit félrefordítva</h2><p>Az algoritmus egy feladat, probléma megoldásához vezető lépések, utasítások sorozata. Például egy recept is egy algoritmus, leírja lépésenként, hogyan kell elkészíteni egy ételt. Ha követed pontosan az utasításokat, akkor valószínűleg sikerül neked is az asztalra varázsolni a vacsorát. Ez persze függ attól is, mennyire részletesen tartalmazza a recept az adott étel elkészítéséhez tartozó lépéseket. Egy kezdőnek természetesen minden apró mozzanatot el kell magyarázni, míg egy gyakorlott séfnek elegendő egy nagyobb léptékű leírás. Ebből is látszik, hogy egy problémát nem csak egyféle algoritmussal oldhatsz meg. Nemcsak a lépések mélységében különbözhetnek ezek az algoritmusok, hanem akár teljesen más lépésekből is állhatnak, és a végeredmény mégis ugyanaz.</p><h2>Az algoritmus jellemzői</h2><p>Az egyszerű algoritmusokon túl lehetnek akár igen bonyolultak is, mint pl. egy nagy forgalmú reptér irányítása. Az algoritmussal szemben ezért is állítottak néhány követelményt:</p><ul><li><strong>Véges:</strong> véges számú lépésből áll.</li><li><strong>Egyértelmű:</strong> a megoldáshoz vezető lépéssorozat tisztán, egyértelműen van megadva, és szigorúan követhető, nem hagy kétségeket.</li><li><strong>Elvégezhető:</strong> elvárjuk, hogy az algoritmust végre lehessen hajtani, vagyis a lépések elég egyszerűek legyenek, hogy pontosan végre lehessen hajtani.</li></ul><h2>Algoritmusleíró eszközök</h2><div class="grid-x grid-margin-x"><div class="cell medium-7"><p>Az algoritmus leírásának módja több tényezőtől függ, például a megoldandó problémától, a célközönségtől. Egy egyszerű algoritmust akár <strong>szövegesen</strong> is leírhatsz pár mondatban röviden, pl. a reggeli kávé elkészítése:</p><ul><li>Bekapcsolom a kávéfőző gépet.</li><li>Ellenőrzőm van-e elég kávé és víz a gépben.</li><li>Amikor felmelegedett, odateszem a csészét és megnyomom az espresso gombot.</li></ul><p>Előfordulhat, hogy <strong>képeket</strong> használnak az algoritmus bemutatására vagy önállóan, vagy a szöveges leírás mellé kiegészítésképpen. Gondolj csak a repülőgépeken a Safety On Board leírásokra (ne legyen rá szükséged), például mi a teendő, ha fogy az oxigén az utastérből.</p><p>Amíg csak utasításokat kell sorrendben egymás után sorolnom, addig ezek a módszerek teljesen megfelelnek. Viszont amikor már a szekvencián kívül más vezérlő szerkezetet is tartalmaz az algoritmus, akkor szerencsésebb lehet valami olyan leíró eszköz, ami szemléletesebb. A folyamatábra például a folyó szövegnél sokkal kifejezőbb ezekben az esetekben.</p></div><div class="cell medium-5"><p><img class="shadow" src="./resources/flowchart.jpg" alt="Folyamatábra"></p></div></div><h2 class="margin-top-1">Vezérlési szerkezetek</h2><p>A szekvencián kívül két vezérlési szerkezetet használtunk a folyamatábrán.</p><ul><li>Az egyik az elágazás (szelekció), amikor feltételtől függően más-más irányba halad tovább a vezérlés.</li><li>A másik szerkezet az ismétlés (iteráció), amikor bizonyos esetben visszairányítjuk a vezérlést egy korábbi pontra, mint pl. amikor várakoztunk, amíg fel nem melegedett a gép.</li><li>Az elágazás és ciklus különböző fajtáiról majd a későbbiekben lesz szó.</li></ul><h2>Strukturált algoritmus</h2><p>Strukturált az algoritmus, ha csak az alap 3 vezérlőszerkezetet (szekvencia, szelekció, iteráció) használod. Ezeket egymásba is ágyazhatod, de minden ilyen egységnek csak egy kimenete lehet. Vagyis nem húzhatod a nyilakat bárhova.</p><h2>Pszeudo kód, a kis hamis</h2><p>Nézzünk egy másik algoritmusleíró módszert, a pszeudo kódot, ami nagyon hasonlít már a programkódra, de nyelvfüggetlen.</p><p></p><pre><code class="plaintext hljs">KÁVÉFŐZŐ BEKAPCSOLÁSA
IF NINCS ELÉG KÁVÉ THEN
  KÁVÉ HOZZÁADÁSA
ENDIF

IF NINCS ELÉG VÍZ THEN
  VÍZ HOZZÁADÁSA
ENDIF

WHILE NEM MELEGEDETT FEL
  10 MP VÁRAKOZÁS
ENDWHILE

CSÉSZE ODAHELYEZÉSE
GOMB MEGNYOMÁSA</code></pre><p></p><p>Ebben a pszeudo kódban az angol kifejezéseket használtam, de természetesen megengedett a magyar nyelvű változat is.</p><p>Nagyon fontos az indentálás (beljebb kezdés), hogy lásd az algoritmus szerkezetét, ezáltal látod az alapstruktúrák egymásba ágyazását.</p><p>A pszeudo kódban könnyebb betartani, hogy strukturált algoritmust írj, a folyamatábrán könnyű a nyilakat úgy húzni, hogy elveszítsd a strukturáltságot. Napjainkban is van azért helye, például az UML-ben (Unified Modeling Language) is találunk a folyamatábrához hasonlót, csak ott aktivitás diagramnak nevezik. Az UML tulajdonképpen egy vizuális modellező nyelv, ami nagyon hasznosnak bizonyul a szoftverek készítésének folyamatában, leginkább a kezdeti analizáló és tervező fázisban. Az objektum orientált programozás tanulásakor használunk majd osztálydiagramot is, ami szintén az UML része.</p><p>Természetesen az itt bemutatottakon kívül még más algoritmusleíró eszközök is léteznek, pl. a struktogram, de ezeket most hagyjuk pihenni.</p><h2>Használandó vezérlési szerkezetek a programkódban</h2><p>Mivel minden algoritmus felépíthető három vezérlési szerkezet használatával, a programkódban is csak ezeket kell most használnod:</p><ul><li>szekvencia,</li><li>szelekció,</li><li>iteráció.</li></ul><p>Van még az ugrás, de arra most nincs szükség.</p></div>

<h2>Elemi algoritmusok</h2>

<div class="content"><h2>Elemi algoritmusok</h2><p>Van néhány olyan folyamat a programozás során, amire az idők során kialakultak a hatékony technikák. Most ezeket mutatom meg.</p><p><b>Ismétlés:</b> Az algoritmus azon lépések sorozata, amelyek egy probléma megoldásához vezetnek.</p><h2>Az algoritmus</h2><p>Tehát mindig úgy kezdődik, hogy van egy problémád. Ezt a problémát általában sokféleképpen meg lehet oldani, így ahány féle megoldás létezik, annyi algoritmus van hozzá. Jöjjön egy példa!</p><p><b>Algoritmus bankkártyás fizetésre:</b> milyen lépésekből áll amikor kártyával fizetsz a boltban?</p><ol><li>Előveszed a bankkártyát.</li><li>Ellenőrzöd az összeget a kijelzőn.</li><li>Hozzáérinted a kártyát a terminálhoz.</li><li>Megvárod a hangjelzést.</li><li>Elteszed a kártyát.</li></ol><p>Ez az öt lépés gyakorlatilag egy algoritmus. A minimálisan szükséges lépéseket tartalmazza a megoldáshoz. Most olyan mélységben nem megyünk bele a dologba, hogy közben lélegezni is kell, mert arra nyilván van egy létfenntartást szolgáló másik algoritmus. :) Ki lehetne terjeszteni a teljes vásárlás folyamatára is, de abban az esetben olyan lépések is lennének benne, mint mondjuk betesszük a terméket a kosárba, vagy távozunk a boltól.</p><h2>Nevezetes algoritmusok</h2><p>Azért hívják őket nevezetesnek, mert gyakran kell őket használni. Olyan programozási folyamatokat írnak le, amelyek nagyon gyakoriak a hétköznapi munka során. Most csak röviden áttekintjük őket, de részletesen is foglalkozunk majd velük, illetve begyakoroljuk őket.</p><h2>Pszeudokód</h2><p>Mielőtt azonban tanulmányoznánk az algoritmusokat, ismerkedjünk meg a pszeudokód fogalmával! Itt az egyes lépéseket egyszerű, beszélt nyelven írjuk le. Azért jó, mert csak az algoritmust adjuk meg, és utána gyakorlatilag bármilyen programozási nyelven el tudjuk készíteni a végleges kódot. Azaz nyelvfüggetlen. Például így néz ki egy ciklus, amellyel sokat fogunk még dolgozni:</p><p></p><pre><code class="plaintext hljs">CIKLUS AMÍG van még szám, ADDIG
    szám = következő elem
    KI: szám
  CIKLUS VÉGE</code></pre><p></p><p>Ha elemzed a fenti kódot, azt látod, hogy addig fog a ciklus futni, amíg nem ér végig a számokon, amik mondjuk egy tömbben is lehetnek. Minden ciklusmagban beállítja a számot és kiírja az értékét, azaz lényegében kiírja a tömb vagy lista elemeit.</p><h2>Összegzés tétele</h2><p>A feladat egyszerű, egy sorozat elemeit kell összesíteni. A pszeudokód:</p><p></p><pre><code class="plaintext hljs">összeg = 0
  CIKLUS AMÍG van még szám, ADDIG
    szám = következő elem
    összeg = összeg + szám
  CIKLUS VÉGE
  </code></pre><p></p><h2>Számlálás tétele</h2><p>Itt össze kell számolni, hogy egy bizonyos feltétel hány elemre igaz.</p><p></p><pre><code class="plaintext hljs">db = 0
  CIKLUS AMÍG van még szám, ADDIG
    szám = következő elem
    HA igaz a feltétel szám-ra, AKKOR
      db = db + 1
    FELTÉTEL VÉGE
  CIKLUS VÉGE
  </code></pre><p></p><h2>Szélsőérték keresése (maximum vagy minimum)</h2><p>A dolog egyszerű. Van mondjuk egy számsorozatod, és meg kell mondanod, hogy melyik a legkisebb vagy legnagyobb szám, azaz a szélsőértékeket keresed.</p><p></p><pre><code class="plaintext hljs">legnagyobb = első elem
  CIKLUS AMÍG van még szám, ADDIG
    szám = következő elem
    HA szám &lt; legnagyobb, AKKOR
      legnagyobb = szám
    FELTÉTEL VÉGE
  CIKLUS VÉGE
  </code></pre><p></p><h2>Eldöntés tétele</h2><p>Megvizsgálod, szerepel-e olyan elem a sorozatban, melyre igaz a feltétel. Például: prímszám-e. Ahogy találsz egy osztót, ami nem önmaga és nem 1, tudod hogy nem az.</p><p></p><pre><code class="plaintext hljs">találat = HAMIS
  CIKLUS AMÍG van elem ÉS NEM találat
    szám = következő elem
    HA igaz a feltétel szám-ra, AKKOR
      találat = IGAZ
    FELTÉTEL VÉGE
  CIKLUS VÉGE
  </code></pre><p></p><h2>Egyéb algoritmusok</h2><p>A későbbiekben más algoritmusokkal is foglalkozunk majd, de a fenti négy képezi a programozási elmélet egyik alapkövét, ezért ezeket addig nyomjuk amíg a véreddé és a húsoddá fognak válni :)))</p><h2>Dokumentáció</h2><p><a href="https://hu.wikipedia.org/wiki/Algoritmus" rel="noopener noreferrer" target="_blank">Az algoritmus</a></p></div>

  <h2>Összegző és számláló algoritmusok</h2>

  <div class="content"><h2>Összegző és számláló algoritmusok</h2><p>Itt a nevezetes algoritmusok vagy programozási tételek közül az első kettő kerül terítékre. Nem lesz bonyolult, de kicsit hivatalosabban fogalmazok majd, ne ijedj meg.</p><h2>Összegzés</h2><p>Először az elméletet. Így nézett ki a pszeudokód:</p><p></p><pre><code class="plaintext hljs">összeg = 0
    CIKLUS AMÍG van még szám, ADDIG
      szám = következő elem
      összeg = összeg + szám
    CIKLUS VÉGE</code></pre><p></p><h3>Alapvető megállapítások</h3><ul><li>Az "akkumulátor" változó az, amelyikben összegyűlik, akkumulálódik az eredmény, ezt most összeg néven tüntettük fel. Ezt először nulláznod kell, utána minden feldolgozott számot hozzá kell adnod. Minden iteráció végén az addig látott számok összegét fogja így tartalmazni. Ha esetleg egyszer sem hajtódott volna végre a ciklus, akkor pedig nullát.</li><li>A ciklus ebben az esetben a teljes sorozaton végig kell hogy iteráljon, mivel az összes számot össze szeretnéd adni.</li><li>A pszeudokódban külön kiemelheted a következő számot egy változóba szám néven, majd ezt adod hozzá az összeghez. Ez a konkrét implementációnál, azaz amikor valamilyen nyelven lekódolod a példát, már egy sorban is könnyen megoldható.</li></ul><h3>JavaScript kód</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> numericArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
    <span class="hljs-keyword">var</span> amount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numericArray.length; i++) {
      amount += numericArray[i];
    }
    <span class="hljs-built_in">console</span>.log(amount);</code></pre><p></p><h3>A kód magyarázata</h3><ul><li>Az első és utolsó sor, azaz a tömb létrehozása és a console-ra való kiírás nem volt benne a pszeudokódban, ezek a konkrét implementáció során már szükségesek.</li><li>Az algoritmus megvalóstása négy sor csupán, a konkrét implementáció általában rövidebb a pszeudokódnál.</li><li>Az akkumulálásra, azaz az összeg összegyűjtésére az "amount" nevű változót definiáltam, hoztam létre.</li><li>A ciklus egy egyszerű for ciklus. Azért választottam ezt, mert szinte az összes nyelvben ez a szintaxisa. Az iterációk száma megegyezik a tömb elemeinek a számával.</li><li>A ciklusmagban a "+=" rövidítést használtam, ez az összetett operátor mindig a jobb oldalon álló értékkel növeli a változó értékét.</li></ul><blockquote><b>Fontos:</b> Az akkumulátor változót mindig a cikluson kívül hozzuk létre és inicializáljuk!</blockquote><h2>Számlálás</h2><p>Itt is jöjjön az elmélet:</p><p></p><pre><code class="plaintext hljs">db = 0
    CIKLUS AMÍG van még szám, ADDIG
      szám = következő elem
      HA igaz a feltétel szám-ra, AKKOR
        db = db + 1
      FELTÉTEL VÉGE
    CIKLUS VÉGE</code></pre><p></p><h3>Alapvető megállapítások</h3><ul><li>Nagyon hasonló az összegzéshez, két dologban különbözik tőle.</li><li>A db nevű változó nem az összeget tartalmazza, hanem az elemek számát.</li><li>Csak azokat az elemeket számolja bele az eredménybe, amelyekre egy adott feltétel igaz.</li></ul><h3>JavaScript kód</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> numericArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numericArray.length; i++) {
      <span class="hljs-keyword">if</span> (numericArray[i] &gt; <span class="hljs-number">3</span>) {
        count++;
      }
    }
    <span class="hljs-built_in">console</span>.log(count);</code></pre><p></p><h3>A kód magyarázata</h3><ul><li>A megfelelő elemek számát a "count" nevű változóba gyűjtöttem.</li><li>Az összes elemen végig iterál a ciklus.</li><li>Ha az adott elem értéke nagyobb, mint 3, akkor növeli a "count" változó értékét eggyel.</li></ul></div>

    <h2>Szélsőértékek keresése</h2>

    <div class="content"><h2>Szélsőérték és eldöntés algoritmusa</h2><p>Most pedig megmutatom a szélsőérték keresés és az eldöntés algoritmusát.</p><h2>Szélsőérték</h2><p>Ha van egy nem üres sorozat, akkor két szélső érték lesz benne, a legkisebb és a legnagyobb. Szokták maximum vagy minimum kiválasztásnak is hívni ezt az eljárást. Előfeltétele, hogy az elemek egymással összehasonlíthatóak legyenek, azaz el tudjuk dönteni, hogy két elem közül melyik a nagyobb. Először a pszeudokód:</p><p></p><pre><code class="plaintext hljs">legnagyobb = első elem
        CIKLUS AMÍG van még elem, ADDIG
          elem = következő elem
          HA elem &gt; legnagyobb, AKKOR
            legnagyobb = elem
          FELTÉTEL VÉGE
        CIKLUS VÉGE</code></pre><p></p><h3>Alapvető megállapítások</h3><ul><li>A szélsőérték keresés során mindig azt feltételezzük, hogy az első elem a kiválasztott, azaz a legkisebb vagy legnagyobb, attól függően, hogy melyiket keressük. Ezt jelenti, hogy a legnagyobb az első elem.</li><li>Ha nem rendezett az elemek listája, akkor minden elemen végig kell iterálnunk egy ciklussal, mivel nem tudjuk, hogy vannak-e még nagyobb vagy kisebb elemek a listában.</li><li>Az eldöntés tételéhez nagyon hasonlóan, itt is van egy feltétel a ciklusmagban. Ez a feltétel azt vizsgálja, hogy a legutóbb maximumnak tartott értékhez képest a jelenlegi érték nagyobb-e. Ha igen, akkor a jelenlegi értéket állítja be legnagyobb értéknek.</li><li>A minimum kiválasztás gyakorlatilag megegyezik ezzel, csupán a relációs jelet kell megfordítanunk a ciklusmagban, amikor vizsgáljuk a feltételt.</li></ul><h3>JavaScript kód</h3><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> numericArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
        <span class="hljs-keyword">let</span> biggest = numericArray[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numericArray.length; i++) {
          <span class="hljs-keyword">if</span> (numericArray[i] &gt; biggest) {
            biggest = numericArray[i];
          }
        }
        <span class="hljs-built_in">console</span>.log(biggest);</code></pre><p></p><h3>A kód magyarázata</h3><ul><li>Feltételezzük, hogy az első elem a legnagyobb, ezért be is állítjuk a tömb első elemét a "biggest" értékeként.</li><li>A ciklussal a teljes tömbön végig iterálunk.</li><li>Ha az adott elem nagyobb, mint a feltételezett legnagyobb, azaz a "biggest", akkor a "biggest"-et felülírjuk az elemre.</li><li>Végül logoljuk az eredményt.</li></ul><h2>Eldöntés</h2><p>Itt is kezdjük az elmélettel! Az alapfeladat kétféle lehet. Vagy azt akarjuk eldönteni, hogy egy sorozatban van-e valamilyen tulajdonsággal rendelkező elem, vagy azt, hogy minden elem rendelkezik-e az adott tulajdonsággal. Mindkét esetben logikai érték lesz a válasz. Lássuk először az első esetet:</p><p></p><pre><code class="plaintext hljs">találat = HAMIS
        CIKLUS AMÍG van elem ÉS NEM találat
          elem = következő elem
          HA keresett tulajdonságú az elem, AKKOR
            találat = IGAZ
          FELTÉTEL VÉGE
        CIKLUS VÉGE</code></pre><p></p><h3>Alapvető megállapítások</h3><ul><li>A "találat" változót hamis értékkel definiáljuk, azaz azt felételezzük, hogy nincs találat.</li><li>A ciklus feltételében nem csak az elemek szerepelnek, azt is vizsgáljuk, hogy van-e találat. Így ha már van találat, akkor a ciklus nem fog többet lefutni.</li><li>Ha az aktuális elem a keresett tulajdonságú, akkor a "találat" igazzá válik, és a ciklus futása leáll.</li><li>Ha egyetlen elemre sem igaz a feltétel, akkor a ciklus az összes elemet bejárja, és utána a "találat" változó hamis marad.</li></ul><h3>JavaScript kód</h3><p>Lássunk egy példát: arra keressünk a választ, hogy a számok sorozatában van-e hatos.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> numericArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
        <span class="hljs-keyword">let</span> find = <span class="hljs-number">6</span>;
        <span class="hljs-keyword">let</span> found = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numericArray.length &amp;&amp; !found; i++) {
          <span class="hljs-keyword">if</span> (numericArray[i] == find) {
            found = <span class="hljs-literal">true</span>;
          }
        }
        <span class="hljs-built_in">console</span>.log(found);</code></pre><p></p><h3>A kód magyarázata</h3><ul><li>Az "i" változó fogja tárolni, hogy éppen hol járunk a tömb iterálása során.</li><li>A "find" tartalmazza a keresett értéket.</li><li>A "found" változó tárolja, hogy megtaláltuk-e a keresett értéket.</li><li>Ha a vizsgálat igaz, azaz a tömb aktuálisan vizsgált elemének értéke megegyezik a keresett értékkel, akkor a "found" változót true értékre állítjuk. Ennek hatására a ciklus nem fog többet lefutni, mivel a feltétele hamissá válik.</li><li>Végül logoljuk az eredményt.</li></ul><hr><p>Most nézzük meg azt az esetet, amikor az a kérdés, hogy minden elem rendelkezik-e az adott tulajdonsággal. Ha az éppen vizsgált elem megfelelő, az még nem ad nekünk választ, tovább kell vizsgálódnunk. Ha az aktuális elem nem megfelelő, akkor viszont biztosak lehetünk benne, hogy a válasz hamis, azaz nem minden elem rendelkezik az adott tulajdonsággal. Ez alapján a módosított algoritmus a következő:</p><p></p><pre><code class="plaintext hljs">mind = IGAZ
        CIKLUS AMÍG van elem ÉS mind
          elem = következő elem
          HA nem a keresett tulajdonságú az elem, AKKOR
            mind = HAMIS
          FELTÉTEL VÉGE
        CIKLUS VÉGE</code></pre><p></p><h3>Alapvető megállapítások</h3><ul><li>A "mind" változót igaz értékkel definiáljuk, azaz azt felételezzük hogy minden elem megfelelő.</li><li>A ciklus feltételében azt is vizsgáljuk, hogy még mindig igaz-e mindre. Így ha már valamelyik elem nem volt megfelelő, akkor a ciklus nem fog többet lefutni.</li><li>Ha az aktuális elem nem az adott tulajdonságú, akkor a "mind" hamissá válik, és a ciklus futása leáll.</li><li>Ha minden elemre igaz a feltétel, akkor a ciklus az összes elemet bejárja, és utána a "mind" változó igaz marad.</li></ul><h3>JavaScript kód</h3><p>Lássunk egy példát: arra keressünk a választ, hogy számok sorozatában mind pozitív-e.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> numericArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
        <span class="hljs-keyword">let</span> all = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numericArray.length &amp;&amp; all; i++) {
          <span class="hljs-keyword">if</span> (numericArray[i] &lt;= <span class="hljs-number">0</span>) {
            all = <span class="hljs-literal">false</span>;
          }
        }
        <span class="hljs-built_in">console</span>.log(all);</code></pre><p></p><h3>A kód magyarázata</h3><ul><li>Az "i" változó fogja tárolni, hogy éppen hol járunk a tömb iterálása során.</li><li>Az "all" változó tárolja, hogy mind pozitív-e.</li><li>Ha a vizsgálat igaz, azaz a tömb aktuálisan vizsgált elemének értéke nem pozitív, akkor az "all" változót false értékre állítjuk. Ennek hatására a ciklus nem fog többet lefutni, mivel a feltétele hamissá válik.</li><li>Végül logoljuk az eredményt.</li></ul></div>

    <h2>Debugging</h2>

    <div class="content"><h2>Debugging</h2><p>Sok fejfájást okoz hogy megtaláld a hibát a kódodban. Szerencsére erre vannak fejlett eszközök, ezeket debuggereknek vagy hibakeresőknek szokták nevezni. Én most a Google Chrome beépített debuggerét mutatom meg neked.</p><p><img class="shadow" src="./resources/mistake.jpg" alt="mistake"></p><h2>Chrome debugger</h2><p>Mivel JavaScript nyelven dolgozunk és böngészőben, adja magát hogy a böngésző beépített debuggerét használjuk.</p><ul><li><kbd>F12</kbd> gombbal nyisd meg a fejlesztői eszköztárat.</li><li>A <b>Sources</b> fülre navigálj az eszköztáron belül. Itt szépen csoportosítva látod az összes fájlt, képet, JavaScript-et amit az oldal használ:</li></ul><p><img class="shadow" src="./resources/debug-1.jpg" alt="mistake"></p><ul><li>Válassz ki egy JavaScript fájlt és ekkor megjelenik a jobb oldali ablakban a fájl tartalma. Ez gyakorlatilag az a script amit a böngésző futtat. Származhat harmadik féltől is, vagy lehet a magad által készített kód:</li></ul><p><img class="shadow" src="./resources/debug-2.jpg" alt="mistake"></p><ul><li>Ha a sorok számára kattintasz a bal oldalon, akkor megjelenik egy kék nyíl, és ezzel létrehozol egy úgynevezett töréspontot (breakpoint), ahol a kód futtatása során meg fog állni a böngésző és addig nem megy tovább, amíg nem avatkozol be:</li></ul><p><img class="shadow" src="./resources/debug-3.jpg" alt="mistake"></p><ul><li>Ezután egyszerűen frissítsd le az oldalt. Ha a végrehajtás rákerül arra a sorra amit kijelöltél, akkor a böngésző megállítja a kód futtatását és meg tudod vizsgálni a változók tartalmát. Ha nem kerül a végrehajtás arra a sorra, annak az lehet az oka, hogy valamilyen esemény hatására fut le a kódrészlet, vagy esetleg olyan feltételhez van kötve a futtatás ami nem teljesül:</li></ul><p><img class="shadow" src="./resources/debug-4.jpg" alt="mistake"></p><ul><li>Látszik a képen, hogy a <code>currentLessons</code> egy <code>NodeList</code> 106 elemmel, és az <code>i</code> változó pillanatnyi értéke épp 1. Mivel rávittem az egeret a <code>this.value</code> változóra, ami egy input mező értéke, így azt is szépen megmutatja a Chrome egy szövegbuborékban.</li><li>Miután befejezted a kód vizsgálatát, a bal alsó sarokban vagy a képernyő közepén megjelenő kék léptető gombbal tudsz továbblépni a következő töréspontra vagy ennek hiányában befejezni a debuggolást:</li></ul><p><img class="shadow" src="./resources/debug-5.jpg" alt="mistake"></p><h2>Hiba esetén mit tegyünk?</h2><ol class="list-strong"><li><span>Ne essünk kétségbe. Csak az nem hibázik aki nem dolgozik. Sokkal jobb, ha mi vesszük észre a hibát mintha a megrendelő.</span></li><li><span>Nyissuk meg a fejlesztői eszköztárat és nézzük meg a konzolt. Ha ott piros hibaüzenetet látunk, akkor általában egy hivatkozás is van, hogy melyik fájl hányadik sorában keletkezett a hiba. Itt már elhelyezhetünk ízlés szerint töréspontokat a megfelelő sorokba, amennyiben szükséges.</span></li><li><span>Erre a hivatkozásra kattintva egyből a <code>Sources</code> panel adott sorára ugrik az eszköztár. Itt megnézhetjük a kódot és ellenőrizhetjük hogy mi váltotta ki a hibát.</span></li><li><span>Ne felejtsük bent a töréspontokat miután a hibát kijavítottuk és ellenőriztük a helyes futást.</span></li></ol><p><img class="shadow" src="./resources/mistake-done.jpg" alt="mistake"></p><h2>Dokumentáció</h2><p><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/" rel="noopener noreferrer" target="_blank">Debuggolási alapok</a></p></div>

    <h2>A megjelenített statisztikai adatok bemutatása</h2>

    <p>Itt már sikerült megizzasztani Kristófot, de állja a sarat.</p>

    <h2>Az időjárás-előrejelzés átadása</h2>

    <p>Eddig ez volt a legkomplexebb feladat, de nyugi, a java még hátravan.</p>

    <h1>Objektumok</h1>

    <h2>Pontosabb időjárásadatok használata</h2>

    <p>Netszerte sok API van, amelyek különböző adatokat szolgáltatnak.<br>Az időjárásra is van több megoldás, ami pontos adatokat ad nekünk.</p>

    <h2>1. feladat - Adatok használata egy kapott objektumból</h2>

    <p>Amikor egy harmadik fél által készített szolgáltatást kezdesz használni, sokszor azzal megy el a legtöbb idő, míg megérted a készítők logikáját.<br>Utána már általában gyorsan lehet vele haladni.</p>

    <h2>Az objektumok áttekintése</h2>

    <div class="content"><h2>Az objektum - rugalmas adattárolás</h2><p>Adatok tárolása kulcs-érték párok segítségével. Ez az objektum. Abban a tekintetben hasonlít a tömbökre, hogy egy kollekció, amiben bármilyen típusú adatot tárolhatsz, akár tömböket vagy másik objektumokat is. Más programnyelvekben nem így hívják ezt az adattípust, de mindegyikben van megfelelője.</p></div>

    <h2>Rugalmas adattárolás objektumok segítségével</h2>

    <div class="content"><h2>Key - kulcs</h2><p>Az objektumok esetén nem automatikusan indexelődnek az elemek mint a tömb esetén, hanem mi határozzuk meg a kulcs-érték párokat.
        A kulcsoknak minden esetben <code>String</code> típusúaknak kell lenniük.</p><h2>Value - érték</h2><p>A kulcsokkal jelölt értékeket tulajdonságoknak is nevezik. Az alábbi példában egy egyszerű objektum létrehozását láthatod. Figyeld meg, hogy az objektumot kapcsos zárójelek határolják, a kulcs-érték párokat vesszők, a kulcsot pedig kettőspont választja el az értéktől:</p><p><img class="shadow" src="./resources/variable_types_object_definition.gif" alt="Objektum létrehozása"></p><h2><code>Object.keys()</code> - az objektum kulcsai</h2><p>Az objektumok esetén fontos, hogy tudd mit tárolsz bennük. Mivel az objektum elemeit a kulcsok segítségével éred el, ezért nem árt tudni, hogy milyen kulcsok vannak egy objektumban. Ezeket a kulcsokat pedig az <code>Object.keys</code> metódus adja vissza.</p><p>Az <code>Object.keys</code> metódus tömb formában adja vissza a kapott objektum kulcsait.</p><p>Az objektum tulajdonságait úgy tudod elérni, hogy az objektum neve után ponttal elválasztva megadod a kiválasztott tulajdonság kulcsát, vagy szögletes zárójelek között
        <code>[]</code>
        String-ként adod meg:</p><p><img class="shadow" src="./resources/variable_types_object_methods_keys.gif" alt="Objektum kulcsok"></p><h2>Az objektum hossza</h2><p>Az objektumoknak nincs <code>length</code> tulajdonsága, mint a tömböknek, ezért más módszerhez kell folyamodnod, ha szeretnéd megtudni az elemeiknek a számát. Erre a legegyszerűbb módszer, ha nem az elemeiket, hanem a kulcsaikat számolod meg.</p><blockquote><b>Figyelem:</b> a példában láncolt metódus hívást alkalmazunk.</blockquote><p>Ennek lényege, hogy egy függvény által visszaadott típusra azonnal meghívod annak szabványos metódusát vagy lekéred egy adott tulajdonságát, jelen esetben a tömb elemeinek számát, azaz a tömb hosszát.</p><p>Az <code>Object.keys</code> tömböt ad vissza, majd annak le is kérheted azonnal a <code>length</code> tulajdonságát:</p><p><img class="shadow" src="./resources/variable_types_object_length.gif" alt="Objektum kulcsok"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener noreferrer" target="_blank">Objektum referencia</a></p></div>

    <h2>Konstans objektumok használata</h2>

    <div class="content"><h2>Constant</h2><p>Arról már beszéltünk, hogy nem lehet új értéket adni a <code>const</code> kulcsszóval létrehozott változóknak. De tömbök és objektumok esetén van egy kiskapu. Hogy mi az, mindját megtudod, figyelj jól ...</p><h2><code>const</code></h2><p>Mi is történik, amikor egy változót a <code>const</code> kulcsszóval hozol létre?</p><p><strong>READ ONLY:</strong> csak olvasható referenciát hoz létre az értékre. Tehát rámutat, referenciát jelent egy memória területre ahol az értéke van. De nem lehet rajta keresztül a memória terület tartalmát módosítani.</p><h2>Mutable - Immutable</h2><p>A szavak jelentése nagyon érdekes.</p><p><strong>Mutable:</strong> az adott változó értéke meg tud változni, tud mutálódni. Ez zombi apokalipszis estén nem túl hasznos tulajdonság, mivel ott az a jó, ha valaki vagy valami nem mutálódik :(</p><p><strong>Immutable:</strong> értelemszerűen az előbbi ellentéte. Tehát az ilyen változót vagy értéket lehet olvasni, de írni - változtatni nem. Az előbb említett világvége esetén bennük jobban meg lehet bízni :)</p><h2><code>const</code> és <code>Object</code></h2><p>Először készítek egy objektumot a <code>let</code> kucsszóv használatával és módosítom egy másikra, mert <strong>mutable</strong>, azaz meg lehet változtatni az értékét:</p><p></p><pre><code class="javascrupt hljs javascript"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John Doe"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">33</span> };
        user = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Black Jack"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">100</span> };</code></pre><p></p><p>Nem történt semmi probléma, a kód lazán lefutott. A <code>user</code> azonosító egy értékre mutat a memóriában. Amikor felülírom nincs semmi baj, az azonosító onnan kezdve egy másik értékre fog mutatni.</p><p>Most ugyanezt megpróbálom <code>const</code> kulcsszóval is, ami <strong>immutable</strong> adatkötést hoz létre:</p><p></p><pre><code class="javascrupt hljs javascript"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John Doe"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">33</span> };
        user = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Black Jack"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">100</span> };
        <span class="hljs-comment">// Uncaught TypeError: Assignment to constant variable.</span></code></pre><p></p><p>Az lett amire számítottam, nem megy a dolog. Nem lehet hozzárendelni új értéket a <code>const</code> változóhoz.</p><p><strong>Constant property change:</strong></p><p></p><pre><code class="javascrupt hljs javascript"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Jack"</span> };
        user.name = <span class="hljs-string">"Bob"</span>;
        <span class="hljs-keyword">const</span> jobs = [<span class="hljs-string">"programmer"</span>, <span class="hljs-string">"chef"</span>, <span class="hljs-string">"builder"</span>, <span class="hljs-string">"movie star"</span>];
        jobs[<span class="hljs-number">2</span>] = <span class="hljs-string">"tester"</span>;</code></pre><p></p><blockquote><strong>A <code>const</code> kulcsszóval definiált objektumok és tömbök tulajdonságait / elemeit meg tudom változtatni!</strong></blockquote><p>Miért? Azért, mert az objektum és a tömb különálló változókat tárol a memóriából és csak összefogja őket. Amikor az objektum egy tulajdonságát megváltoztatom, azzal az objektum kötése az azonosítóhoz nem fog megváltozni, csupán az egyik tulajdonságát módosítottam.</p><h2>Memory snapshot</h2><p>A Google Chrome lehetővé teszi, hogy pillanatfelvételt készíts a memóriáról.</p><ul><li>Létrehoztam egy <code>const</code> objektumot <code>Acar</code> néven.</li><li>Készítettem egy memória pillanatfelvételt (snapshot) és kikerestem benne a változómat.</li><li>Minden változó mellett ott van a memóriacíme, azaz hol található a memóriában.</li><li>Jól nézd meg a képet: az <code>Acar</code> objektum és a <code>man</code> és <code>model</code> String-ek, amelyek a tulajdonságai, más és más memória címeken vannak. Ezért ha azokat módosítjuk, azzal az <code>Acar</code> memóriacíme nem módosul.<br></li></ul><p><img class="shadow" src="./resources/memory-snapshot.jpg" alt="Memory snapshot"></p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_const.asp" rel="noopener noreferrer" target="_blank">JS const</a></p></div>

    <h2>A for in ciklus</h2>

    <div class="content"><h2>For in ciklus</h2><p>Több dologban különbözik a for ciklustól.</p><ul><li>Nincs benne iterátor változó.</li><li>A megadott Array vagy objektum kulcsait járja be.</li></ul><h2>Használata</h2><p>Paraméterei:</p><ul><li><strong>kulcs változó:</strong> ebben tárolja mindig az aktuális kulcsot.</li><li><strong>kollekció:</strong> az a tömb vagy objektum, amelyet bejár a ciklus.</li></ul><p></p><h2>Egy egyszerű  <code>for...in</code> ciklus</h2><p>A k változó a key rövidítése, ez tárolja az aktuális kulcsot.
        Külön ki is írtam neked a kulcsot és az értéket.</p><p><img class="shadow" src="./resources/loops_forin.gif" alt="Objektum kulcsok"></p><h2>Tömbre és objektumra is</h2><p>Nagy előnye az alap for ciklussal szemben, hogy tömbre és objektumra is alkalmazható, nem kell hozzá külön változó, hogy végig tudd járni az objektumok kulcsait.</p><p>A példában ugyanazt a ciklust használom fel tömbhöz és objektumhoz is:</p><p><img class="shadow" src="./resources/loops_forin_array_and_object.gif" alt="Objektum kulcsok"></p><h2>Előnyei</h2><ul><li>Tömbre és objektumra is működik.</li><li>Egyszerűbb szintaxis.</li></ul><h2>Hátránya</h2><ul><li>Nehezebb a futását limitálni, mert nincs külön iterátora.</li></ul><p>A <code>for...in</code> ciklus esetén is használható a <code>continue</code> és a <code>break</code> utasítás.</p><p><img class="shadow" src="./resources/loops_forin_continue_break.gif" alt="Objektum kulcsok"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" rel="noopener noreferrer" target="_blank">For...in ciklus</a></p></div>
    
    <h2>A for of ciklus</h2>
    <div class="content"><h2>Iteráció</h2><p><strong>Az iteráció egy függvény ismételt végrehajtása az előző függvényértéken.</strong>
        Magyarul, az iteráció azt jelenti, hogy egy sorozat elemeit végigjárom és mindegyiken végrehajtok egy műveletet, és ez a végigjárás valamilyen sorban történi, azaz nem összevissza ugrálok a sorban található elemeken.</p><h2>For...of</h2><p>Ezt a fajta ciklust az ES2015 szabvány hozta be a js-be. A for...of ciklus hasonló a for...in-hez, de vannak különbségek.</p><ol class="list-strong"><li>Nem a kulcsokon, hanem az értékeken megy végig</li><li>Array-like, tömb szerű változókon lehet alkalmazni</li></ol><p>Példa a használatára:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> iterable = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> iterable) {
          value += <span class="hljs-number">1</span>;
          <span class="hljs-built_in">console</span>.log(value);
        }</code></pre><p></p><p>Azt írja ki, hogy 11, 21, 31. A tömb az iterálható, azt be tudja járni a for...of ciklus és egyesével kiolvassa az elemeit. Ezután növeltem eggyel az értékeket és kiírtam a console-ra.</p><h2>String bejárása for...of ciklussal</h2><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> iterable = <span class="hljs-string">'boo'</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> iterable) { <span class="hljs-built_in">console</span>.log(value); }</code></pre><p></p><p>Azonosan tudod elvégezni, mint a tömb esetén. Emlékszel, a String nagyon hasonlóan viselkedik, mint az Array. A kimenet "b", "o", "o" lesz.</p><h2>Objektum bejárása for...of ciklussal - ha NEM kell a kulcs</h2><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Kiss Ramóna"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">22</span> };
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.values(user) ) { <span class="hljs-built_in">console</span>.log(value); }</code></pre><p></p><p>Nem konkrétan az objektumot járja be a példában a ciklus, hanem kiolvasom az objektumból az értékeket, amit az <code>Object.values()</code> metódus egy tömbben ad vissza. Ezt a tömböt már be tudom járni, mert az Array az iterálható. Így viszont elveszítem a kulcsokat és csak az értékekkel tudok dolgozni a ciklusban. Ennek akkor van veszélye, ha nem abban a sorrendben vannak az adatok az objektumban, ahogy én arra számítottam.</p><h2>Objektum bejárása for...of ciklussal - ha kell a kulcs</h2><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Kiss Ramóna"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">22</span> };
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(user) ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`<span class="hljs-subst">${entry[<span class="hljs-number">0</span>]}</span>: <span class="hljs-subst">${entry[<span class="hljs-number">1</span>]}</span>`</span> );
        }</code></pre><p></p><p>És itt az egész példa kimenettel:</p><p><img class="shadow" src="./resources/forof.jpg" alt="For of example"></p><p>Miért érdekes ez? Mert ha meghívod az <code>Object.entries()</code> metódust és átadsz neki egy objektumot, akkor egy tömböt ad vissza, amiben al-tömbökben az egyes tulajdonságok
        <code>[key, value]</code>
        formában benne vannak. Az egyes bejegyzések <code>entry</code> első eleme tehát a kulcs, a második az érték.</p><h3>Dokumentáció</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener noreferrer" target="_blank">For...of cycle</a></p></div>

    <h2>A refaktorált időjárás-előrejelző bemutatása</h2>

    <p>Na így már sokkal profibb lett.</p>

    <h2>2. feladat - A hőmérsékleti adatok átszámítása</h2>

    <p>Az átváltás ugyan egy egyszerű matematikai művelet, de figyelembe kell venni a használt programnyelv sajátosságait is.</p>

    <h2>Metódusok</h2>

    <div class="content"><h2>Metódus</h2><p>A metódus (angolul method) azt jelenti, hogy egy dolgot hogyan csinálunk meg? Azaz a kivitelezés módját.
        Az objektumoknak vannak tulajdonságai, ha egy objektum egy embert jelent, akkor például a magassága vagy a haja színe. De vannak metódusai is, azaz amit tudnak csinálni. Ilyen lehet hogy tudnak beszélni, sétálni, futni, stb. Tehát a metódus azt írja le, hogy egy adott ovjektum egy dolgot hogyan csinál?</p><h2>Beépített metódusok</h2><p>Találkoztál már metódusokkal, amiket bizonyos objektumokra meg lehet hívni. <code>Array.isArray()</code>, <code>Object.keys()</code>, <code>Object.etries()</code> ismerősek? Ezek tipikus metódusok, amelyek már alapból meg vannak írva és használhatod őkat. A metódus gyakorlatilag egy függvény, ami egy objektumhoz van kötve és nem csk úgy "lóg a levegőben".</p><h2>Saját metódusok</h2><p>De te is bármikor késztíthetsz egy metódust, most megmutatom hogyan. Egy objektum metódussal:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> product = {
          <span class="hljs-attr">price</span>: <span class="hljs-number">1000</span>,
          <span class="hljs-attr">desc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">"This is an awesome product."</span>;
          }
        }
        
        <span class="hljs-built_in">console</span>.log( product.desc() );
        </code></pre><p></p><h2>Pár érdekes dolog</h2><ul><li>A <code>product</code> objektum egyik tulajdonsága egy függvény. Ezt metódusnak hívjuk.</li><li>A metódus kulcs (neve) <code>desc</code>.</li><li>Ha meg akarod hívni, akkor így tudod: <code>product.desc()</code>.</li><li>Fontosak a zárójelek, csak akkor fog lefutni, ha van utána kettő. Tudod, <code>invocation</code> azaz a metódus meghívása.</li><li>És amit a <code>desc</code> metódus visszaad, azt ki is írathatod mondjuk egy <code>console.log</code>-gal.</li></ul><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index" rel="noopener noreferrer" target="_blank">Az összes beépített metódus</a></p></div>

    <h2>A this titkai és felhasználási módja</h2>

    <div class="content"><h2>This</h2><p>Ezt a szót az angolok akkor használják, ha rá akarnak mutatni valamire. Ez. Mindig egy adott objektumot jelent. A kérdés, hogy mikor melyiket?</p><h2>Mikor mi a <code>this</code>?</h2><p><strong>A globalis objektumot jelenti, ami álatalában a window:</strong><br><b>Hol:</b> a js fájl gyökerében, függvényekben.</p><p></p><pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span> ); <span class="hljs-comment">// window</span></code></pre><p></p><p>Szóval ha csak úgy simán lekéred a js dokumentum gyökeréban akkor a legfelső szintű objektum lesz, ami a böngészőben a <code>window</code>.</p><p><strong>A szülő objektumot jelenti:</strong><br><b>Hol:</b> metódusban.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> product = {
        <span class="hljs-attr">price</span>: <span class="hljs-number">2000</span>,
        <span class="hljs-attr">showPrice</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.price}</span> Ft`</span>;
        }
      }</code></pre><p></p><p><strong>Azt az elemet jelenti, amelyre végbement az esemény:</strong><br><b>Hol:</b> az eseménykezelő függvényben.</p><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"this.style.display='none'"</span>&gt;</span> Click to Remove Me! <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><p></p><p>Itt a this a button lesz.</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_this.asp" rel="noopener noreferrer" target="_blank">A csodálatos this</a></p></div>

    <h2>Egy user objektum létrehozása</h2>

    <div class="content"><h2>Objektumok</h2><p>Már elég sokrszor leírtam, de nem lehet elégszer: az objektumok a való világban létező dolgokat jelentik. Lehet objektum egy ember, állat, autó, ingatlan és még sok más is. Az objektum nem jeleníti meg az összes tulajdonságát a dolgoknak, csak azokat amelyek számunkra fontosak.</p><h2>Tipikus <code>user</code></h2><p>Alapvető objektum szokott lenni a <code>user</code>. Egy programot emberek használnak, akik belépnek, kilépnek, adatokkal dolgoznak. Nagyon jó alanyok lesznek most egy kis objektum készítéshez:</p><h2>Egy durva <code>user</code> objektum felépítése</h2><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> user = {
        <span class="hljs-string">"_id"</span>: <span class="hljs-string">"5cda967e7dc7132184fca4c7"</span>,
        <span class="hljs-string">"index"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-string">"guid"</span>: <span class="hljs-string">"12f9f283-c1fb-475e-9e4d-fdddb30c970c"</span>,
        <span class="hljs-string">"isActive"</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-string">"balance"</span>: <span class="hljs-string">"$1,241.29"</span>,
        <span class="hljs-string">"picture"</span>: <span class="hljs-string">"http://placehold.it/32x32"</span>,
        <span class="hljs-string">"age"</span>: <span class="hljs-number">38</span>,
        <span class="hljs-string">"eyeColor"</span>: <span class="hljs-string">"green"</span>,
        <span class="hljs-string">"name"</span>: {
          <span class="hljs-string">"first"</span>: <span class="hljs-string">"Imelda"</span>,
          <span class="hljs-string">"last"</span>: <span class="hljs-string">"Compton"</span>
        },
        <span class="hljs-string">"company"</span>: <span class="hljs-string">"ENERVATE"</span>,
        <span class="hljs-string">"email"</span>: <span class="hljs-string">"imelda.compton@enervate.name"</span>,
        <span class="hljs-string">"phone"</span>: <span class="hljs-string">"+1 (949) 487-3823"</span>,
        <span class="hljs-string">"address"</span>: <span class="hljs-string">"120 Norwood Avenue, Canoochee, Washington, 6049"</span>,
        <span class="hljs-string">"about"</span>: <span class="hljs-string">"Ullamco consequat sit Lorem aute voluptate reprehenderit enim ut tempor amet. Ea nostrud deserunt ullamco veniam eu incididunt id exercitation ipsum consequat in ullamco occaecat do. Reprehenderit culpa magna cillum sint aliqua. Tempor sunt qui incididunt culpa mollit et cupidatat sunt amet duis. Esse est nisi Lorem eu cupidatat sint dolor proident do sit."</span>,
        <span class="hljs-string">"registered"</span>: <span class="hljs-string">"Sunday, September 23, 2018 2:35 AM"</span>,
        <span class="hljs-string">"latitude"</span>: <span class="hljs-string">"8.539048"</span>,
        <span class="hljs-string">"longitude"</span>: <span class="hljs-string">"-42.045441"</span>,
        <span class="hljs-string">"tags"</span>: [
          <span class="hljs-string">"voluptate"</span>,
          <span class="hljs-string">"ipsum"</span>,
          <span class="hljs-string">"quis"</span>,
          <span class="hljs-string">"consectetur"</span>,
          <span class="hljs-string">"elit"</span>
        ],
        <span class="hljs-string">"friends"</span>: [
          {
            <span class="hljs-string">"id"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"Malone Owens"</span>
          },
          {
            <span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>,
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"Schultz Morales"</span>
          },
          {
            <span class="hljs-string">"id"</span>: <span class="hljs-number">2</span>,
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"Suzanne Stephenson"</span>
          }
        ],
        <span class="hljs-string">"greeting"</span>: <span class="hljs-string">"Hello, Imelda! You have 7 unread messages."</span>,
        <span class="hljs-string">"favoriteFruit"</span>: <span class="hljs-string">"apple"</span>
      };</code></pre><p></p><p>Ezt az objektumot egy olyan oldalon generáltattam, ahol lehet a programod teszteléséhez készíteni nagy JSON tömböket (link a doksiknál). Ez a tömb egyik eleme. De ez nem igazi objektum még, csak egy JSON string. Igaz, a js kompatibilis vele, tehát ha így egy az egyben bemásolnád a kódodba akkor tudnád használni.</p><h2>Metódusok</h2><p>Mit ér az objektum metódus nélkül (sokat de jobb ha van neki)? Átalakítok gyorsan néhány statikus tulajdonságot metódusra, hogy ez is legyen gyakorolva. (Nem írom ki a teljes kódot, csak a módosított részeket, tehát így egy az egyben nem lehet lefuttatni.)</p><h3>getBalance</h3><p></p><pre><code class="javascript hljs"><span class="hljs-string">"balance"</span>: <span class="hljs-number">1500</span>,
      <span class="hljs-string">"getBalance"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currency = <span class="hljs-string">"$"</span></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${currency}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.balance}</span>`</span>;
      }</code></pre><p></p><p>A <code>balance</code> tulajdonságot Number típusként adom meg, mert lehet hogy lesznek vele matematikai műveletek (csökkentés, növelés, stb...) és így praktikusabb. Ezért létrehozok egy <code>getBalance</code> metódust, ami formázva adja vissza a felhasználó egyenlegét. Sőt, felveszek egy <code>currency</code> paramétert is <code>$</code> alapértelmezett értékkel. Ha megadják a pénzenemet amikor meghívják a metódust akkor azt teszi elé, ha nem akkor dollár lesz.</p><h3>getFullname</h3><p></p><pre><code class="javascript hljs"><span class="hljs-string">"name"</span>: {  <span class="hljs-string">"first"</span>: <span class="hljs-string">"Imelda"</span>,  <span class="hljs-string">"last"</span>: <span class="hljs-string">"Compton"</span> },
      <span class="hljs-string">"getFullname"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.last}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.first}</span>`</span>;
      }</code></pre><p></p><p>Az előző metódushoz hasonló, azt teszi érdekessé, hogy a<code>name</code> az maga is objektum, tehát úgy érem el a vezeték és keresztnevet, hogy <code>this.name.last</code> és <code>this.name.first</code>.</p><h3>greeting</h3><p></p><pre><code class="javascript hljs"><span class="hljs-string">"greeting"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.first}</span>! You have 7 unread messages.";
      }</span></code></pre><p></p><p>Ez már csak ujjgyakorlat. A <code>greeting</code> metódus lett, és az objektum <code>name</code> tulajdonságából veszi a keresztnevet. Miért jó ez? Azért, mert ha megváltoztatod a nevet, akkor is jól fog működni. Mire gondolok? Ha kiadom ezt a parancsot: <code>user.name.first = "Maria"</code> akkor megváltozik a keresztnév. Igen ám, de ha nem a <code>this.name.first</code>-tel olvasom ki, akkor továbbra is azt fogja kiírni, hogy <code>Hello Imelda!...</code></p><h2>Dokumentáció</h2><p><a href="https://next.json-generator.com/" rel="noopener noreferrer" target="_blank">User generátor</a></p></div>

      <h2>Az arrow function</h2>

      <div class="content"><h2>Arrow Function</h2><p>Elérkeztünk a függvényekkel kapcsolatos újítások legzseniálisabb részéhez, azaz az <code>Arrow function</code>-ökhöz.</p><p>Nézzük meg mi is ez az új CSODA. Az előző leckékben már tettem rá említést, most a gyakorlatban is megmutatom, hogy is teszik egyszerűbbé az életünket az <code>arrow function</code>-ök.</p><p>Az <code>arrow function</code> segítségével egyszerűbben tudsz létrehozni függvényeket, mint függvény kifejezéssel.</p><p><b>Emlékszel még erre:</b></p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> people = [
        {
          <span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>,
          <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>
        },
        {
          <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Jane"</span>,
          <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>
        }
      ];
      <span class="hljs-keyword">let</span> template = <span class="hljs-string">`&lt;div&gt; <span class="hljs-subst">${people.map(<span class="hljs-keyword">function</span>(person) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;p&gt; <span class="hljs-subst">${person.firstName}</span> <span class="hljs-subst">${person.lastName}</span> &lt;/p&gt;`</span>;
      }</span>).join("")} &lt;/div&gt;`</span>;</code></pre><p></p><p><b>Egyszerűsítsük:</b></p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> people = [
        {
          <span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>,
          <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>
        },
        {
          <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Jane"</span>,
          <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>
        }
      ];
      <span class="hljs-keyword">let</span> template = <span class="hljs-string">`&lt;div&gt;
          <span class="hljs-subst">${people.map(person =&gt; <span class="hljs-string">`&lt;p&gt; <span class="hljs-subst">${person.firstName}</span> <span class="hljs-subst">${person.lastName}</span>&lt;/p&gt;`</span>)
          .join(<span class="hljs-string">""</span>)}</span> &lt;/div&gt;`</span>;
      <span class="hljs-built_in">console</span>.log(template); <span class="hljs-comment">/* &lt;div&gt; &lt;p&gt; John Doe &lt;/p&gt;&lt;p&gt; Jane Doe &lt;/p&gt; &lt;/div&gt; */</span></code></pre><p></p><p>Ugyanazt kapjuk a kimeneten. De mi is történt? A <code>callback</code> függvényünket átírtuk egy újfajta szintaxisra.</p><ul><li>Elhagytuk a <code>function</code> kulcsszót.</li><li>Az <code>arrow function</code> mindig anonim lesz.</li><li>A paraméter körüli zárójeleket töröltük (EZT CSAK AKKOR TEHETJÜK MEG HA 1 PARAMÉTER VAN!).</li><li>Elhagytuk a kapcsos zárójeleket (NEM MINDIG!).</li><li>Egy =&gt; jelet írunk a paramétere(k) után.</li><li>Elhagytuk a <code>return</code> kulcsszót.</li></ul><p><b>Nézzünk egy másik egyszerűbb példát is:</b></p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> languages = [<span class="hljs-string">"java"</span>, <span class="hljs-string">"php"</span>, <span class="hljs-string">"python"</span>];
      
      <span class="hljs-comment">// Ezt írjuk át:</span>
      <span class="hljs-keyword">let</span> scriptsOldStyle = languages.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">language</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${language}</span> script`</span>;
      });
      
      <span class="hljs-comment">// Erre:</span>
      <span class="hljs-keyword">let</span> scriptsNewStyle = languages.map(<span class="hljs-function"><span class="hljs-params">language</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${language}</span> script`</span>);</code></pre><p></p><p>A fenti példán is jól láthatók a szintaxisbeli különbségek. Nézzünk meg egy példát több paraméterrel:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> languages = [<span class="hljs-string">"java"</span>, <span class="hljs-string">"php"</span>, <span class="hljs-string">"python"</span>];
      <span class="hljs-keyword">let</span> languageRank = languages.map(<span class="hljs-function">(<span class="hljs-params">language, i</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${i + <span class="hljs-number">1</span>}</span>. <span class="hljs-subst">${language}</span> script`</span>);
      <span class="hljs-built_in">console</span>.log(languageRank); <span class="hljs-comment">//  ["1. java script", "2. php script", "3. python script"]</span></code></pre><p></p><p>Láthatjuk, hogy több paraméter esetén a zárójeleket ki KELL tennünk. Nézzünk egy példát egy összetettebb függvényre:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> alertMessage = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {
        alert(<span class="hljs-string">`Alert <span class="hljs-subst">${message}</span>`</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Alert <span class="hljs-subst">${message}</span>`</span>);
      };
      alertMessage(<span class="hljs-string">"Message"</span>);</code></pre><p></p><p>Tehát ahogy említettem, ha nem csak egy egyszerű utasításunk van a függvényben, a kapcsos zárójeleket kitesszük, illetve ha nincs kapcsos zárójel az azt jelenti, hogy visszatérési értékünk lesz. Nézzünk még egy érdekes példát arra az esetre, hogy ha a függvénynek egyáltalán nem lenne paramétere:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> infoMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Arrow function"</span>);
      infoMessage();</code></pre><p></p><p>Nézzünk még egy szép összetett real life példát funkcionális programozási szemléletmóddal így a végére:</p><p>Van egy webshopunk, és a html kódból meg kell mondanunk, hogy az általunk árult szerverek összesített ára mennyi:</p><p></p><pre><code class="html hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"hu"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Arrow Function Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"price-list"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>TV<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-company</span>=<span class="hljs-string">"Dell"</span>&gt;</span>Server<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-price</span>=<span class="hljs-string">"11.012,12"</span>&gt;</span>TV<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-price</span>=<span class="hljs-string">"23.243,55"</span>&gt;</span>Server<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-price</span>=<span class="hljs-string">"4.543,29"</span>&gt;</span>TV<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-price</span>=<span class="hljs-string">"230.323,32"</span>&gt;</span>Server<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-price</span>=<span class="hljs-string">"48.344,30"</span>&gt;</span>Server<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
          <span class="hljs-keyword">const</span> serverPrice = <span class="hljs-built_in">Array</span>.from(
            <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'#price-list li[data-price]'</span>))
            .filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.textContent.includes(<span class="hljs-string">'Server'</span>))
            .map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">parseFloat</span>(item.dataset.price.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">''</span>)
            .replace(<span class="hljs-string">','</span>, <span class="hljs-string">'.'</span>)))
            .reduce(<span class="hljs-function">(<span class="hljs-params">total, item</span>) =&gt;</span> total + item);
          <span class="hljs-built_in">console</span>.log(serverPrice);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p></p><p>Mindössze annyit teszünk, hogy használjuk a tömb metódusainkat, most már <code>Arrow function</code>-ökkel kombinálva. (Az <code>Array.from()</code> szintén hamarosan kifejtésre kerül, csakúgy, mint az <code>includes()</code>, ami leginkább az <code>indexOf()</code>-ra hasonlít)</p><ul><li>Kigyűjtjük egy konstansba a <code>price-list</code> id-jú elemen belül az összes li-t,aminek a <code>data-price</code> attribútuma meg van adva. (Az <code>Array.from()</code>-ról a későbbiekben részletesen.)</li><li>Leszűrjük az elemeket, hogy a "Server" szót tartalmazó elemek maradjanak, tehát csak a szerverek árai érdekelnek.</li><li>Tömböt készítünk ezen elemek áráról, mely érték már <code>float</code>-tá lesz alakítva (kiszedjük a pontot), és figyelünk a "," karakterekre is, melyeket "."-ra cserélünk.</li><li>A kapott összegeket összeadjuk.</li></ul><h2>Arrow function és a return utasítás</h2><p></p><pre><code class="javascript hljs"><span class="hljs-comment">// return: undefined</span>
      <span class="hljs-comment">// Üres blokk, implicit return</span>
      (<span class="hljs-function"><span class="hljs-params">firstName</span> =&gt;</span> {})()
      
      <span class="hljs-comment">// return: 'Hello John'</span>
      <span class="hljs-comment">// Nincs blokk, implicit return</span>
      (<span class="hljs-function"><span class="hljs-params">firstName</span> =&gt;</span> <span class="hljs-string">'Hello '</span> + firstName)(<span class="hljs-string">'John'</span>)
      
      <span class="hljs-comment">// return: undefined</span>
      <span class="hljs-comment">// explicit return kell a blokkon belül, de Hello hiányzik</span>
      (<span class="hljs-function"><span class="hljs-params">firstName</span> =&gt;</span> {<span class="hljs-string">'Hello '</span> + firstName})(<span class="hljs-string">'John'</span>)
      
      <span class="hljs-comment">// return: 'Hello John'</span>
      <span class="hljs-comment">// explicit return a blokkon belül</span>
      (<span class="hljs-function"><span class="hljs-params">firstName</span> =&gt;</span> {<span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + firstName})(<span class="hljs-string">'John'</span>)
      
      <span class="hljs-comment">// return: undefined</span>
      <span class="hljs-comment">// a block egy label-t tartalmaz. Nincs explicit return.</span>
      <span class="hljs-comment">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label</span>
      (<span class="hljs-function"><span class="hljs-params">firstName</span> =&gt;</span> {<span class="hljs-attr">name</span>: firstName})(<span class="hljs-string">'John'</span>)
      
      <span class="hljs-comment">// return: {name: 'John'}</span>
      <span class="hljs-comment">// implicit return a ( ) belül, ami egy objektum</span>
      (<span class="hljs-function"><span class="hljs-params">firstName</span> =&gt;</span> ({<span class="hljs-attr">name</span>: firstName}))(<span class="hljs-string">'John'</span>)
      
      <span class="hljs-comment">// return: name: 'John'</span>
      <span class="hljs-comment">// explicit return a blokkon belül, objektum</span>
      (<span class="hljs-function"><span class="hljs-params">firstName</span> =&gt;</span> {<span class="hljs-keyword">return</span> {<span class="hljs-attr">name</span>: firstName}})(<span class="hljs-string">'John'</span>)
      </code></pre><p></p><h2>Arrow function és a local binding</h2><p>A JavaScript fejlesztők élete nem csak játék és mese.
      Az <code>arrow function</code>-nél nincs <code>local binding</code>. Tehát nincs <code>arguments</code>, <code>this</code>, <code>super</code>, <code>new.target</code>. Ha a <code>arrow function</code>-ön belül megpróbáljuk elérni, akkor a <code>parent scope</code> lesz használva.</p><p>Nézzünk egy példát <code>this</code> esetére, és hogy mikor jó nekünk az <code>arrow function</code> e tulajdonsága:</p><p></p><pre><code class="javascript hljs"><span class="hljs-comment">/*
        A régi módszer, a this-t beletettük a that-be,
        hogy a setInterval-on belüli callback-ben is elérjük
      */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
        that.age = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">set</span><span class="hljs-title">Interval</span>(<span class="hljs-params">function setAge(</span>) {
          that.age = <span class="hljs-number">30</span>;
        }, <span class="hljs-number">1000</span>);
      }
      
      <span class="hljs-comment">// És most:</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PeopleWithAF</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.age = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">set</span><span class="hljs-title">Interval</span>(<span class="hljs-params">(</span>) =&gt; {
          <span class="hljs-keyword">this</span>.age = <span class="hljs-number">30</span>;
        }, <span class="hljs-number">1000</span>);
      }</code></pre><p></p><p>Ím látjuk, hogy ez szép, jó, és hasznos, szóval jöjjön is egy példa, hogy mikor NEM jó.</p><p>Ilyen esetben - objektum metódusban - érdemes kerülni a használatát:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> sampleObject = {
        <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,
        <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a, <span class="hljs-keyword">this</span>),
        <span class="hljs-attr">c</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a, <span class="hljs-keyword">this</span>);
        }
      };
      
      sampleObject.b();
      <span class="hljs-comment">// undefined, Window {...} (vagy global object)</span>
      
      sampleObject.c();
      <span class="hljs-comment">// 10, Object {...}</span></code></pre><p></p></div>

      <h2>Az átszámított hőmérsékleti adatok bemutatása</h2>

      <p>Ha eléggé kitartó az ember, a végén összejön.</p>

      <h2>A refaktorált időjárás-előrejelző átadása</h2>

      <p>Ez ugyan egy kis kiegészítő, mondhatni kényelmi szolgáltatás volt, mégis sokat tanultunk belőle.</p>

<h1>A DOM és a feltételek</h1>

    <h2>Az adminfelülettel kapcsolatos igények megfogalmazása</h2>

    <p>Összetettebb alkalmazásoknál előbb-utóbb felmerül az igény valamilyen kezelőfelületre. Ezeket tipikusan admin felületnek vagy oldalnak szokták nevezni.</p>

    <h2>1. feladat - Az adminfelület vázának elkészítése</h2>
    <p>Általában elmondható, hogy érdemes először csak a vázát elkészíteni az új funkcióknak, hogy lássuk, a gyakorlatban megállja-e a helyét a tervünk?</p>

      <h2>A DOM áttekintése</h2>

      <div class="content"><h2>DOM</h2><p>A JavaScript egyik fő célja a HTML dokumentumok dinamikus kezelése. Erre a célra a böngészőben az ún. Document Object Modelt (a továbbiakban DOM) tudod használni.</p></div>

    <h2>A DOM megismerése</h2>

    <div class="content"><p>A JavaScript egyik fő célja a HTML dokumentumok dinamikus kezelése. Erre a célra a böngészőben az ún. Document Object MA DOM API segítségével lekérdezheted és változtathatod a HTML elemeket. Az API-t a globális <strong>document</strong> objektumon keresztül éred el.</p><p>Egy HTML elemhez többféleképpen is hozzáférhetsz.</p><h2><code>document.getElementById()</code></h2><p>Az elemet az <strong>id</strong> attribútum alapján szeretném elérni. Mivel az id-nak egyedinek kell lennie egy oldalon, ezért ez a függvény az adott elemet adja vissza (egész pontosan egy objektumot ad vissza, amin keresztül tudod az elemet módosítani).</p><p><img class="shadow" src="./resources/dom_getElementById.gif" alt="getElementById"></p><p>Abban az esetben, ha a megadott id nem létezik az oldalon, a függvény <strong>null</strong> értékkel tér vissza.</p><p><img class="shadow" src="./resources/dom_getElementById_null.gif" alt="getElementById null"></p><h2><code>document.getElementsByName()</code></h2><p>Hasonló a <code>getElementById</code> függvényhez, de itt a <strong>name</strong> attribútum alapján történik a keresés. Figyeljük meg az apró különbséget, az elements a függvény nevében többesszámban van. Ez a függvény egy tömböt fog visszaadni nekünk.</p><p><img class="shadow" src="./resources/dom_getElementsByName.gif" alt="getElementsByName"></p><h2><code>document.getElementsByClassName()</code></h2><p>A  <strong>class</strong> attribútum alapján visszakapjuk azokat a HTML elemeket egy tömbben.</p><h2><code>document.getElementsByTagName()</code></h2><p>Ez a függvény minden elemet visszaad nekünk, aminek a típusa a megadott tag.</p><h2><code>document.querySelector()</code></h2><p>Ez a függvény CSS selectorok alapján keres nekünk HTML elemeket, majd visszaadja az első találatot.</p><h2><code>document.querySelectorAll()</code></h2><p>Szintén CSS selectorok alapján keres nekünk HTML elemeket, de minden egyező elemet visszaad nekünk.</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/js/js_htmldom.asp" rel="noopener noreferrer" target="_blank">DOM Api</a></p></div>

    <h2>A DOM elemek őse - element</h2>

    <div class="content"><h2>Element - a DOM elemek őse</h2><p>Az <strong>Element</strong> objektumon keresztül érjük el az oldalon található HTML elemeket.
        Mutatok pár érdekes dolgot vele kapcsolatban, és fel is okosítjuk kicsit.</p><h2>Element</h2><p>Ha bármilyen módon kiválasztasz egy HTML elemet az oldalon, egy <code>Element</code> típusú JavaScript objektumot fogsz visszakapni. Például igaz ez a <code>querySelector</code> használata esetén is.</p><h2>Element bővítése</h2><p>Az objektumoknál már tanultuk, hogy lehet bővíteni őket. De egy bizonyos prototype-juk, azaz tervrajzuk vagy prototípusuk is. Minden új elem ez alapján a prototípus alapján készül. Így ha szeretnéd az összes HTML elemet felruházni egy új képességgel, akkor ezt a prototype-ban kell létrehoznod.</p><p>Például lehet bővíteni az <code>Element</code>-et valamilyen metódussal:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input'</span>);
        Element.prototype.setDisabled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">this</span>.setAttribute(<span class="hljs-string">'disabled'</span>, <span class="hljs-string">'disabled'</span>);
          <span class="hljs-keyword">this</span>.classList.add(<span class="hljs-string">'disabled'</span>);
        }
        
        input.setDisabled();</code></pre><p></p><p>Ez azért nem kicsit durva, nézzük át mégegyszer:</p><ul><li>Először megkeresem az inputot és elmentem az <code>input</code> nevű változóba.</li><li>Bővítem az Element prototípusát egy új metódussal, a neve <code>setDisabled</code> lesz.</li><li>Amikor meghívják, a <code>this</code> az az element lesz, ami után írják a metódus nevét.</li><li>Beállítom az attribútumot és hozzáadok egy osztályt is az osztálylistához.</li><li>Végül meghívom az adott elemre.</li></ul><h2>Dokumentáció</h2><p><a href="http://www.w3schools.com/js/js_htmldom_elements.asp" rel="noopener noreferrer" target="_blank">Element</a></p></div>

    <h2>A HTML attribútumok lekérdezése és módosítása</h2>

    <div class="content"><h2>Attributes - a tulajdonságok</h2><p>Ahogy már megmutattam, a HTML elemek tulajdonságait attribútumoknak is hívjuk.
        Most ezeket fogjuk JavaScript segítségével módosítani.</p><h2><code>getAttribute()</code> - tulajdonságok lekérése</h2><p>Ez a metódus, a <code>getAttribute</code> függvény visszaadja egy adott HTML elem egy bizonyos attribútumának az értékét. Hogy mire vagy kíváncsi, azt neked kell megadod.</p><p>Emlékszel amikor a string változókat kellett vágni? Ott is megadtuk, hogy honnan kezdje a vágást és meddig vágjon? Tehát paraméterekkel láttuk el a metódust.
        Itt ugyanerről van szó, meg kell mondanunk a <code>getAttribute</code> függvénynek, hogy mire is vagyunk kíváncsiak, a sok tulajdonság közül konkrétan melyik is érdekel minket.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> classes = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"H1"</span>).getAttribute(<span class="hljs-string">"class"</span>);</code></pre><p></p><p>Ez egy stringet fog visszaadni. Ha a <code>H1</code> elem így néz ki: <code>&lt;h1 class="main dark"&gt;Hello&lt;/h1&gt;</code>, akkor a <code>classes</code> változó tartalma a következő lesz: <code>"main dark"</code>.</p><h2><code>setAttribute()</code> - tulajdonságok módosítása</h2><p>Hasonlít a barátjához, de ezzel a HTML elem tulajdonságait nem lekérni, hanem módosítani tudod.
        Ebből fakad, hogy nem elég neki egy paraméter, meg kell adni az új értéket is a tulajdonság neve után. A példában egy HTML elem több tulajdonságát is módosítom:</p><p></p><pre><code class="javascript hljs"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"H1"</span>).setAttribute(<span class="hljs-string">"class"</span>, <span class="hljs-string">"dark grey big"</span>);
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"H1"</span>).setAttribute(<span class="hljs-string">"title"</span>, <span class="hljs-string">"Urgent message"</span>);
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"H1"</span>).setAttribute(<span class="hljs-string">"id"</span>, <span class="hljs-string">"mainTitle"</span>);</code></pre><p></p><h2>Dokumentáció</h2><ul><li><a href="http://www.w3schools.com/jsref/met_element_getattribute.asp" rel="noopener noreferrer" target="_blank">getAttribute</a></li><li><a href="http://www.w3schools.com/jsref/met_element_setattribute.asp" rel="noopener noreferrer" target="_blank">setAttribute</a></li></ul></div>

    <h2>Több elem módosítása ciklus segítségével</h2>

    <div class="content"><h2>Tömeges módosítás</h2><p>Gyakran kell majd egyszerre több HTML elem tulajdonságait is módosítanod.
        Ehhez kombináljuk a lekérdezést és a megismert ciklusokat egymással.
        Tehát végig kell menned az összes elemen, és egyesével módosítani a tulajdonságaikat.</p><h2>For - a legjobb választás</h2><p>Láttuk, hogy a <code>querySelectorAll</code> metódus visszaadja az összes elemet egy tömbben. Igen ám, de nem minden tömb, ami annak látszik.</p><p><strong>NodeList:</strong> Ugyanis amit visszaad, az okosabb, mint egy tömb. Ezért vigyázni kell, ha végig akarsz menni az elemein, mert könnyen találkozhatsz olyannal, amelyikre nem működnek az ismert trükkök, mondjuk a <code>setAttribute</code>.</p><p>De a <code>length</code> tulajdonság a segítségünkre siet:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myNodelist = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"p"</span>);
        <span class="hljs-keyword">let</span> i;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; myNodelist.length; i++) {
          myNodelist[i].style.backgroundColor = <span class="hljs-string">"red"</span>;
        }</code></pre><p></p><p>Semmi különös nem történt, csupán egy for ciklussal bejártam a <code>NodeList</code> elemeit, amelyek ebben a konkrét példában <code>&lt;p&gt;&lt;/p&gt;</code> elemek. A ciklusban pedig a háttérszínét mindegyiknek beállítottam pirosra.</p><h2>For...in - ha ragaszkodsz hozzá?!</h2><p>Ha mégis ragaszkodsz a jó öreg for...in ciklushoz, azzal is dolgozhatsz, de ebben az esetben precízen ellenőrizd le, hogy helyes HTML elemet kaptál-e!</p><p>Ebben segítek neked a példában:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> myNodelist = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"p"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> myNodelist) {
          <span class="hljs-keyword">if</span> (myNodelist[k].style) {
            myNodelist[k].style.backgroundColor = <span class="hljs-string">"red"</span>;
          }
        }</code></pre><p></p><p>Leellenőriztem, hogy van-e olyan tulajdonsága a <code>myNodelist</code> k kulcsú elemének, hogy <code>style</code>. Ha van, akkor beállítom a háttérszínt, ha nincs akkor nem hivatkozok rá mert hibát kapnék.</p><h2>Dokumentáció</h2><p><a href="http://www.w3schools.com/js/js_functions.asp" rel="noopener noreferrer" target="_blank">Functions</a></p></div>

    <h2>Több elem módosítása külön függvénnyel</h2>

    <div class="content"><h2>Módosítás függvénnyel - a helyzet fokozódik</h2><p>Lépések:</p><ol class="list-strong"><li><span>Készíts egy függvényt.</span></li><li><span>Add át neki a szelektort, a tulajdonság nevét és értékét.</span></li><li><span>A függvényben végigjárod az elemeket, és módosítod a tulajdonságot.</span></li><li><span>Végül valamit vissza is adsz a kíváncsiak kedvéért.</span></li></ol><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">massModify</span>(<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">var</span> divs = <span class="hljs-built_in">document</span>.querySelectorAll(selector);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> divs) {
          <span class="hljs-keyword">if</span> (divs[k].setAttribute) {
            divs[k].setAttribute(<span class="hljs-string">'style'</span>, <span class="hljs-string">'color: red'</span>);
          }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      
      massModify(<span class="hljs-string">'.mass'</span>);</code></pre><p></p></div>

      <h2>Az adminfelület vázának bemutatása</h2>

      <p>Mérdföldkő teljesítve, jöhet a következő.</p>

      <h2>2. feladat - Az adminfelület működőképessé tétele</h2>

      <p>A weblap "lelke" a JavaScript.</p>

      <h2>Egy elem gyerekei</h2>

      <div class="content"><h2>Children - az elem gyerekei</h2><p>A HTML elemek között van egy képletes szülő-gyerek kapcsolat. A beágyazott elemeket, amelyek egy másik elemben vannak, annak gyerekeinek is szokás nevezni. A következő metódusok is innen kapták a nevüket.</p><h2><code>childElementCount</code></h2><p>Az <code>Element.childElementCount</code> tulajdonság megmondja, hány gyereke van a HTML elemednek. Ez akkor lehet hasznos, ha keresel benne valamit. Ha először lekéred, hogy egyáltalán vannak-e gyerekei, nem fogsz feleslegesen dolgozni.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> elementCount = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myDIV"</span>).childElementCount;
      </code></pre><p></p><h2><code>childNodes</code> vs. <code>children</code></h2><p>Most megkeressük a gyerekeket.</p><ul><li><code>element.childNodes</code> az összes gyerek, beleértve a kommentek és szövegek is.</li><li><code>element.children</code> csak az <code>Element</code> típusú gyerekek, vagyis komment és szöveg nincs benne.</li></ul><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> nodes = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myDIV"</span>).childNodes.length;
      <span class="hljs-keyword">let</span> children = <span class="hljs-built_in">document</span>.body.children;
      </code></pre><p></p><h2><code>firstChild|lastChild</code> vs. <code>firstElementChild|lastElementChild</code></h2><p>Első vagy utolsó gyerekelem.</p><ul><li><code>element.firstChild</code> az első gyerek, komment vagy szöveg is.</li><li><code>element.firstElementChild</code> csak az <code>Element</code> típusú első gyerek.</li><li><code>element.lastChild</code> az utolsó gyerek, komment vagy szöveg is.</li><li><code>element.lastElementChild</code> csak az <code>Element</code> típusú utolsó gyerek.</li></ul><h2>Dokumentáció</h2><p><a href="http://www.w3schools.com/jsref/dom_obj_all.asp" rel="noopener noreferrer" target="_blank">DOM element methods</a></p></div>

      <h2>Új elemek létrehozása és hozzáadása gyerekként</h2>

      <div class="content"><h2>Children - gyerek management</h2><p>Azt már tudod, hogyan kell lekérni egy Element gyerekeit, most azt is megmutatom, hogyan tudsz hozzáadni újat, vagy meglévőt eltávolítani.</p><h2><code>document.createElement()</code></h2><p>Mielőtt hozzá akarsz adni egy elemet egy másikhoz, nyilván létre kellene hozni.
        Ezt szolgálja a <code>createElement</code> metódus. Használata nagyon egyszerű.</p><ul><li>Megadod, hogy milyen elemet szeretnél létrehozni és elmented egy változóba:</li></ul><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
        </code></pre><p></p><h2><code>Element.appendChild()</code></h2><p>A neve alapján tehát hozzáfűz egy új elemet a meglévőhöz. Egészen pontosan nem is hozzá, hanem bele fűzi, mivel ezzel a metódussal abban az Element -ben hoz létre egy új gyerek Element -et, amelyre a metódust meghívod.
        Az új elem az utolsó lesz a szülő Element gyerekei között.
        Lépésről lépésre:</p><ul><li>Kell egy Element, amibe bele akarod tenni az újat. <code>querySelector</code></li><li>Létre kell hozni egy új elemet. <code>createElement</code></li><li>Ha szükséges, be lehet állítani az új Element tuajdonságait. <code>setAttribute</code></li><li>Végül az új elemet hozzáadod a kiválaszott Element-hez. <code>appendChild</code></li></ul><p>Bővebben a példában:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"ul li"</span>);
        <span class="hljs-keyword">var</span> anchor = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"li"</span>);
        anchor.innerHTML = <span class="hljs-string">"Water"</span>;
        anchor.setAttribute(<span class="hljs-string">"href"</span>, <span class="hljs-string">"https://training360.com"</span>);
        li.appendChild(a);
        </code></pre><p></p><h2>Element.removeChild()</h2><p>Egy kis szintaxis: <code>node.removeChild(node)</code> Nagyon hasonlít a testvérére az <code>appendChild</code>-ra, csak nem kell elemet létrehozni.</p><p>Lépésről lépésre:</p><ul><li>Kell egy Element, amiből az egyik child-ot el akarjuk távolítani. <code>querySelector</code></li><li>Kell az az elem, amit el akarunk távolítani. <code>querySelector</code></li><li>Végül az eltávolítás. Fontos, hogy csak child elemet lehet. <code>removeChild</code></li></ul><p>Bővebben a példában:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"ul"</span>);
        <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"ul li:first-child"</span>);
        ul.removeChild(li);
        </code></pre><p></p><h2>Dokumentáció</h2><ul><li><a href="http://www.w3schools.com/jsref/met_node_appendchild.asp" rel="noopener noreferrer" target="_blank">appendChild</a></li><li><a href="http://www.w3schools.com/jsref/met_node_removechild.asp" rel="noopener noreferrer" target="_blank">removeChild</a></li></ul></div>

    <h2>Eseménykezelők hozzáadása HTML elemekhez</h2>

    <div class="content"><h2>Event - az esemény</h2><p>A JavaScriptben lehetőség van eseményeket figyelni, és a hatásukra valamilyen kódot futtatni. Ilyen esemény például amikor betöltődik az oldal, vagy a felhasználó rákattint egy elemre.</p><h2>= vs. addEventListener</h2><p>Ha azt szeretnéd, hogy történjen valami, ha mondjuk egy gombra kattintanak, azt háromféleképpen is meg tudod adni.</p><ol><li>Element attribútummal: <code>&lt;element onclick="myScript"&gt;</code></li><li>JavaScriptből hasonlóan: <code>object.onclick = function() { myScript };</code></li><li>addEventListenerrel: <code>object.addEventListener("click", myScript);</code></li></ol><p>Az első kettőnél egy eseményre csak egy működést adhatsz meg, míg az <code>addEventListener</code> használatával többet is.</p><blockquote><b>Fontos:</b> <code>addEventListener</code> esetén nem kell az on szócska az esemény neve elé.</blockquote><h2>Window események</h2><p>A közös bennük, hogy nem felhasználói beavatkozásra történnek meg, hanem a böngésző működése váltja ki őket. Nem csak a window -ra lehet őket megadni, a legtöbb elem esetén használhatóak.</p><p>A fontosabbak:</p><ul><li><code>onload</code> az objektum betöltődött</li><li><code>onresize</code> az objektumot átméretezték</li><li><code>onscroll</code> scrolloztak az objektumon</li></ul><p>Például figyelhetjük ha scrolloztak, és egy bizonyos távolsagra az oldal tetejétől kisebbre vehetjük a fejlécet, vagy elrejthetünk bizonyos elemeket:</p><p></p><pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.onscroll = myFunction;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.body.scrollTop &gt; <span class="hljs-number">50</span> || <span class="hljs-built_in">document</span>.documentElement.scrollTop &gt; <span class="hljs-number">50</span>) {
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myP"</span>).className = <span class="hljs-string">"test"</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myP"</span>).className = <span class="hljs-string">""</span>;
          }
        }</code></pre><p></p><h2>Dokumentáció</h2><p><a href="http://www.w3schools.com/jsref/dom_obj_event.asp" rel="noopener noreferrer" target="_blank">DOM Events</a></p></div>

    <h2>Az egér és az űrlapelemek eseményei</h2>

    <div class="content"><h2>Mouse events - egér események</h2><p>A leggyakrabban figyelt események az egér események. Itt bejönnek a képbe a mobil eszközök is, mert ott már nincs egér, hanem legtöbbször ujjal kezelik őket. Ezeknél a kattintás a <code>tap</code>-et, azaz a tapintást jelenti.</p><p>A legfontosabbak:</p><ul><li><code>onclick</code> kattintás vagy tappintás, ha mobileszközről van szó</li><li><code>onmouseover</code> az elem fölé viszik az egérmutatót (mobilon értelmetlen)</li><li><code>onmouseout</code> az elemről elhúzzák az egérmutatót (mobilon értelmetlen)</li></ul><p>Mindegyiket valamilyen konkrét HTML elemre, azaz Element típusú objektumra lehet beállítani, a fent részletezett három mód valamelyikével:</p><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fillPre</span>(<span class="hljs-params">content</span>) </span>{
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'pre'</span>).innerHTML = content;
      }
      <span class="hljs-keyword">let</span> button = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.click-button'</span>);
      button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">var</span> className = <span class="hljs-keyword">this</span>.className;
        fillPre(<span class="hljs-string">'clicked: '</span> + className);
      });
      </code></pre><p></p><h2><code>onchange</code> és <code>onsubmit</code> - form elemek</h2><p>Fontos értesülnöd róla, ha valaki piszkálja a formot.</p><ul><li><code>onchange</code> input elemek értékének változását figyelheted.</li><li><code>onsubmit</code> a form (űrlap) elküldése előtt fut le, ezt figyelheted vele. Ha az eseménykezelő függvény visszatérési értéke <code>false</code>, akkor az űrlap nem kerül elküldésre.</li></ul><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fillPre</span>(<span class="hljs-params">content</span>) </span>{
        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'pre'</span>).innerHTML = content;
      }
      <span class="hljs-keyword">var</span> inputList = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'input'</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; inputList.length; i++) {
        <span class="hljs-keyword">if</span> (inputList[i].addEventListener) {
          inputList[i].addEventListener(<span class="hljs-string">'change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
            fillPre( <span class="hljs-keyword">this</span>.className + <span class="hljs-string">': '</span> + <span class="hljs-keyword">this</span>.value );
          });
        }
      }
      </code></pre><p></p><h2>Dokumentáció</h2><p><a href="http://www.w3schools.com/jsref/dom_obj_event.asp" rel="noopener noreferrer" target="_blank">DOM Events</a></p></div>

    <h2>A működőképes adminfelület bemutatása</h2>

    <p>A jól végzett munka után még poénkodni is maradt idő.</p>

    <h2>3. feladat - új felhasználók rögzítése</h2>
    

    <p>A felhasználókezelés egy nagyon rutinfeladat, de egy újszülöttnek minden vicc új.</p>

    <h2>Egy elem szülője</h2>

    <div class="content"><h2>Parent</h2><p>Angolul szülőt jelent és az is. Ha egy elemnek lehetnek gyerekei, és meg lehet kérdezni, hogy hány gyereke van, és akár keresni is lehet közöttük, ugyanígy ha a gyermek elem felől nézzük a dolgot, annak is működnie kell. Jöjjön a kik a szüleid kérdés. Illetve pontosítok: ki a szülőd, mivel minden elemnek csak egyetlen közvetlen szülője lehet.</p><h2><code>parentNode</code> vs. <code>parentElement</code></h2><p><strong>parentNode:</strong> az adott elem szülő node-ját adja vissza, mely lehet <code>Element</code> vagy gyökérelem esetén a <code>document</code>.</p><p><strong>parentElement:</strong> az adott elem szülő elemét adja vissza, mely mindig egy <code>Element</code>, vagy gyökérelem esetén <code>null</code>.</p><p>Fontos különbség van a <code>node</code> és az <code>element</code> között. A <code>Node</code> egy csomópont a dokumentumban, lehet egy egyszerű <code>textNode</code> is, ami nem valódi HTML <code>Element</code>. Mert minden Element node, de nem minden node element :)</p><p></p><pre><code class="html hljs xml">document.body.parentNode; // <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
        document.body.parentElement; // <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span> element</code></pre><p></p><h2>Munka a szülőkkel</h2><p>A példában elrejtem a <code>span</code> szülőjét a kíváncsi tekintetek elől:</p><p></p><pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"this.parentElement.style.display = 'none';"</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p></p><p>Kattintásra a <code>div</code>-nek fogja a <code>style.display</code> tulajdonságát <code>"none"</code>-ra állítani. Tehát a kattintott elem szülőjének.</p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/jsref/prop_node_parentelement.asp" rel="noopener noreferrer" target="_blank">ParentElement</a></p></div>

    <h2>A switch kapcsoló</h2>

    <div class="content"><h2>Switch - a kapcsoló</h2><p>Ahogy a neve is mutatja, a <code>switch</code> egy kapcsoló. Több állása is lehet, egy változót vagy kifejezést vizsgál, és annak az értéke alapján ugrik a megfelelő utasításhoz.</p><h2>Használata</h2><p>Egy paramétere van, egy olyan változó vagy kifejezés, ami értéket ad vissza. Azután meg kell adni, hogy milyen érték hatására milyen utasítás fusson le.</p><p>Kulcsszavak:</p><ul><li><code>switch(value)</code> - a value az az érték, amit figyel a <code>switch</code>.</li><li><code>case value: kifejezés break;</code> - ha a value megegyezik a vizsgált értékkel, lefut a kifejezés, utána <code>break</code> utasítást teszünk, hogy a többi ne fusson le.</li><li><code>default: kifejezés</code> - ha egyik case sem volt igaz, akkor ez fog lefutni.</li></ul><p>Előnye, hogy gyorsabb, mint az <code>else...if</code>, viszont csak konkrét értékeket lehet vele vizsgálni, azaz például kisebb-nagyobb logikai kifejezést nem tud értelmezni.</p><p>Megkeresem a hét napjának nevét a száma alapján:</p><p><img class="shadow" src="./resources/statement_switch.gif" alt="Switch statement"></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch" rel="noopener noreferrer" target="_blank">JS Switch</a></p></div>

    <h2>A while ciklus</h2>

    <div class="content"><h2>While ciklus</h2><p>Ahogy a neve is mutatja, mindaddig fut amíg a megadott feltétel igaz.
        Egy paramétere van, ami egy logikai kifejezés, ennek kell igaznak lennie, hogy a ciklus újra lefusson.</p><h2>Használata</h2><p>Paraméterei:</p><ul><li><strong>feltétel:</strong> egy logikai kifejezés.</li></ul><p>Egy <code>while</code> ciklus létrehozása:</p><p><img class="shadow" src="./resources/loops_while.gif" alt="While loop"></p><h2>Végtelen ciklus</h2><p>A <code>while</code> ciklus használata esetén gyakran előfordul, hogy a feltételt nem figyeljük megfelelően. Ekkor fordul elő, hogy a feltétel mindig igaz marad, és a ciklus végtelen hurokba kerül.
        A különböző értelmezők általában bizonyos számú futás után hibát adnak és leállnak, vagy lefagy a felület, mint például az alábbi esetben is.</p><blockquote><strong>Mindig figyelj oda a feltétel megfelelő frissítésére!</strong></blockquote><p>Az alábbi példa egy végtelen ciklust mutat be.</p><p>A probléma az, hogy a feltételt elfelejtettem módosítani a ciklusmagban (persze direkt):</p><p><img class="shadow" src="./resources/loops_while_infinity.gif" alt="Infinity loop"></p><h2>Kollekciók bejárása</h2><p>Természetesen a <code>while</code> ciklus is alkalmas arra, hogy tömböket vagy objektumokat járj be a segítségével. Itt viszont nem kapsz semmi segítséget ehhez, neked kell leprogramoznod a kulcsok léptetését.</p><p>A példában kiolvasom a kulcsokat, majd bejárom az objektumot, közben pedig növelem az iterátort, ami alapján előállítom a kulcsokat:</p><p><img class="shadow" src="./resources/loops_while_iterator.gif" alt="While iterator"></p><h2><code>do while</code> - hátultesztelő ciklus</h2><p>Az elöltesztelős ciklusoknál megfigyelhettük, hogy először a feltétel vizsgálata történik meg, majd utána a kiértékelés eredményétől függően a ciklusmag futtatása. Ezzel szemben a hátultesztelős ciklus először lefuttatja a ciklusmagot, és csak utána vizsgálja meg a feltételt. A gyakorlatban ez a következőképp fest:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>; <span class="hljs-keyword">do</span> {
          <span class="hljs-built_in">console</span>.log(i);
          i++;
        }
        <span class="hljs-keyword">while</span> ( i &lt; <span class="hljs-number">0</span> );</code></pre><p></p><p>A fenti esetben a konzolra kiírja a program, hogy 10, ugyanis a hátultesztelős ciklus lényege, hogy akár igaz a feltétel, akár hamis, egy alkalommal biztosan le fog futni.</p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/hu/docs/Web/JavaScript/Reference/Statements/while" rel="noopener noreferrer" target="_blank">While loop</a></p></div>

        <h2>DOM manipuláció while ciklussal</h2>

        <div class="content"><h2>DOM manipuláció</h2><p>Most összetett struktúrákat, listákat, táblázatokat fogunk generálni js-sel. Izgalmas lesz.</p><h2>Lista <code>while</code> cilkussal</h2><p>Bemelegítésnek készítek egy p elemekből álló listát while ciklussal:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];
            <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">let</span> container = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"div"</span>);
            <span class="hljs-keyword">while</span>(i &lt; numbers.length) {
              <span class="hljs-keyword">let</span> p = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"p"</span>);
              p.innerHTML = numbers[i];
              container.appendChild(p);
              i++;
            }</code></pre><p></p><p><strong>Mit tettem?</strong></p><ul><li>Létrehoztam a <code>numbers</code> tömböt.</li><li>Beállítottam az <code>i</code> változót, ez lett az index.</li><li>Megkerestem az első <code>div</code>-et az oldalon.</li><li>Addig futtattam a <code>while</code> ciklust, amíg kisebb az <code>i</code>, mint a tömb hossza.</li><li>A ciklusban létrehoztam egy <code>p</code> elemet és beállítottam a tartalmát a numbers tömb aktuális elemére.</li><li>Hozzáadtam a <code>p</code> elemet a <code>container</code>-hez, ami egy <code>div</code>.</li><li>Végül növeltem az <code>i</code> változót eggyel.</li></ul></div>

    <h2>A felhasználók adatainak megadása</h2>

    <div class="content"><h2>Táblázat rajzolása objektumtömbből</h2><p>Amikor egy szevrerről megkapod mondjuk a felhasználókat, az a legtöbbször egy tömb lesz, ami az egyes felhasználókat objektumként tartalmazza. Erre szokták mondani, hogy objektumtömb, vagy objektumok tömbje.</p><p>Legyen hát egy objektumtömböd:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> users = [{
        <span class="hljs-string">"_id"</span>: <span class="hljs-string">"5cdad500da7a3648b7f5a3f3"</span>,
        <span class="hljs-string">"name"</span>: <span class="hljs-string">"Berger Whitney"</span>,
        <span class="hljs-string">"company"</span>: <span class="hljs-string">"ENAUT"</span>,
        <span class="hljs-string">"email"</span>: <span class="hljs-string">"berger.whitney@enaut.name"</span>
      }, {
        <span class="hljs-string">"_id"</span>: <span class="hljs-string">"5cdad50017e5fdde3c44bc5b"</span>,
        <span class="hljs-string">"name"</span>: <span class="hljs-string">"Laverne Dale"</span>,
        <span class="hljs-string">"company"</span>: <span class="hljs-string">"PYRAMIS"</span>,
        <span class="hljs-string">"email"</span>: <span class="hljs-string">"laverne.dale@pyramis.io"</span>
      }];</code></pre><p></p><p>Minden felhasználó objektuma azonosan épül fel, de az adataik természetesen különbözőek.</p></div>

    <h2>DOM manipuláció for ciklussal</h2>

    <div class="content"><h2>Rajzolj táblázatot!</h2><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> table = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#demoTable"</span>);
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; users.length; i++ ) {
          <span class="hljs-keyword">let</span> tr = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"tr"</span>);
          <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> data <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.values(users[i]) ) {
            <span class="hljs-keyword">let</span> td = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"td"</span>);
            td.innerHTML = data;
            tr.appendChild(td);
          }
          table.appendChild(tr);
        }</code></pre><p></p><p>A helyes táblázathoz két egymásba ágyazott ciklus kell. Az egyikben létrehozod a sorokat, a másikban a cellákat a sorokon belül. Amikor elkészíted a fenti példát a saját gépeden, használd a Google Chrome beépített debug eszközét ahogy tanultuk. Állítsd meg minden sorban a ciklusokat és nézd végig a változók pillanatnyi értékét.</p></div>

    <h2>Gombok elkészítésének refaktorálása</h2>

    <div class="content"><p>Itt egy egyszerű Bootstrap <code>btn-group</code>-ot hozok létre.</p><h2>Dokumentáció</h2><p><a href="https://getbootstrap.com/docs/4.4/components/button-group/" rel="noopener noreferrer" target="_blank">Btn Group</a></p></div>

    <h2>Az új felhasználók rögzítésének bemutatása</h2>

    <p>Szép is jó is, mi kellhet még?</p>

    <h2>Az elkészített adminfelület átadása</h2>

    <p>Tamás is meg volt elégedve, reméljük, az ügyfél is boldog lesz.</p>

    <h1>Backend GET</h1>

    <h2>A backenddel kapcsolatos igények megfogalmazása</h2>

    <div class="content"><p>Mindig nehéz kérdés, hogy a backend milyen technológiával legyen megvalósítva.</p><p>Általában két dolog dönt.</p><ul><li>Van-e konkrét ügyféligény rá?</li><li>Mihez van szakemberünk?</li></ul></div>

    <h2>1. feladat - backend megvalósítása NodeJS alapokon</h2>

    <p>FullStack fejlesztőnek azokat hívják, akik mind a frontend, mind a backend fejlesztéséhez értenek.<br>Ma Kristóf is elindult ezen a rögös úton.</p>

    <h2>A backend áttekintése</h2>

    <div class="content"><h2>A frontend és a backend</h2><p class="margin-top-1"><img class="shadow" src="Front-End-and-Back-End.png" alt="Front End, Back End"></p></div>

    <h2>A Node Package Manager - NPM</h2>

    <div class="content"><h2>NPM alapok</h2><p>Az NPM betűszó a Node Pacakge Manager rövidítése. A fejlesztők készítenek egy modult, ami egy mini alkalmazás és bárki integrálhatja a saját munkájába. Ezek gyakorlatilag egyszerű folder moulok, azaz a modul egy mappában van megvalósítva. Egy parancssori alkalmazás segítségével tudjuk telepíteni, eltávolítani, keresni ezeket a csomagokat (modulokat). Az NPM-et nem kell külön telepíteni, a NodeJS-szel együtt települ.</p><h2>Telepítsünk csomagot!</h2><p>Az új csomagok telepítése nagyon egyszerű.</p><ol class="list-strong"><li><p>Nyiss egy parancssort.</p></li><li><p>Navigálj abba a mappába ahol a csomagot használni akarod, jellemzően ahol mondjuk az app.js fájlod van ami indítja a NodeJS alkalmazásodat.</p></li><li><p>Telepítsd monduk a lodash csomagot, ezzel profi módon lehet például a tömböket kezelni. A parancs három részből áll. Először a program neve, majd a parancs - jelen esetben az install -, végül a csomag neve amit telepíteni szeretnél:</p><pre><code class="plaintext hljs">npm install lodash</code></pre><p></p></li><li><p>Kis gondolkodás után letölti a csomagot majd kicsomagolja és létrehozza abban a mappában ahol kiadtad a parancsot a 'node_modules' almappát (ha még nem létezik).
        Ebben a mappában megtalálod a letöltött folder modult, lesz egy olyan mappa hogy 'lodash'.</p></li><li><p>Úgy tudod használatba venni a modult, ha egyszerűen a nevével hivatkozol rá az app.js fájlban:</p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>);
        </code></pre><p></p></li></ol><h2>Local vs. Global</h2><p>Az előző fejezetben a csomag lokálisan települt, azaz ha egy másik mappából szeretnéd használni a modult az nem fog menni, mert nem látja a másik mappában lévő NodeJS alkalmazás.</p><h2>Globális telepítés</h2><p>A lépések hasonlóak mint a lokálisnál, azzal a különbséggel hogy a <code>-g</code> flaget kell használnod:</p><p></p><pre><code class="plaintext hljs">npm install express-generator -g</code></pre><p></p><p>Ezzel az express-generator csomag windowson például a 'C:/Users/AppData/Roaming' mappán belül települ egy almappába verziótól függően. Így a gépen futó bármelyik NodeJS alkalmazásod el fogja érni. Bizonyos csomagoak csak így futnak helyesen, például ez az express-generator is ilyen, egy szerver keretrendszert telepít a megadott mappába azaz nem kapcsolódik szervesen egy bizonyos NodeJS alkalmazáshoz.</p><h2>Dokumentáció</h2><p><a href="https://docs.npmjs.com/getting-started/what-is-npm" rel="noopener noreferrer" target="_blank">Getting Started</a></p></div>

    <h2>A package.json fájl</h2>

    <div class="content"><h2>A package.json fájl</h2><p>Ha többen is dolgoztok egy projekten, akkor tegyük fel hogy az egyikőtök telepít egy csomagot. A verziókövető rendszerben nem szokták a csomagokat követni, ezért az egyik felhívja a másikat hogy telepítsd már ezt meg azt a csomagot. Ez oké amíg ketten vagytok, de három ember felett már kezelhetetlenné válik. Erre találták ki a package.json fájlt. A NodeJS alkalmazásod gyökerébe kell elhelyezned és szépen felsorolni benne hogy milyen csomagok kellenek az alkalmazáshoz. Amikor változik, csak mindenki nyom egy <code>npm install</code>-t és máris szinkronban vannak a csomagok. Lássuk hogy működik.</p><h2>package.json</h2><p>Az alkalmazásod gyökerében kell a fájlt létrehoznod kézzel, vagy ezzel a paranccsal:</p><p></p><pre><code class="plaintext hljs">npm init -y</code></pre><p></p><p>Az <code>-y</code> kapcsoló azt jelenti, hogy minden kérdést elfogadsz, enélkül válaszolni kell néhányra.</p><p>Ahogy a neve is mutatja, az NPM csomagokat és a projected beállításait tartalmazza. Egy objektum van benne szöveges formában, a fontos részei ezek:</p><ul><li>A csomag (alkalmazás) neve:<pre class="margin-bottom-1"><code class="json hljs"><span class="hljs-string">"name"</span>: <span class="hljs-string">"yellowroad"</span>,</code></pre></li><li>Verzió, három szám, [főverzió].[alverzió].[patch]:<pre class="margin-bottom-1"><code class="json hljs"><span class="hljs-string">"version"</span>: <span class="hljs-string">"0.0.1"</span>,</code></pre></li><li>Az alkalmazás rövid leírása:<pre class="margin-bottom-1"><code class="json hljs"><span class="hljs-string">"description"</span>: <span class="hljs-string">"YellowRoad teaching platform."</span>,</code></pre></li><li>Ha fent van a GitHub-on a csomag, akkor annak a beállításai (típus, url):<pre class="margin-bottom-1"><code class="json hljs"><span class="hljs-string">"repository"</span>: {
        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"git"</span>,
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"git+https://github.com/cherryApp/YellowRoad.git"</span>
      },</code></pre></li><li>Szerző:<pre class="margin-bottom-1"><code class="json hljs"><span class="hljs-string">"author"</span>: <span class="hljs-string">"author@author.hu"</span>,</code></pre></li><li>Licensz. Ez különösen akkor fontos ha terjeszteni akarod majd az appod:<pre class="margin-bottom-1"><code class="json hljs"><span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>,</code></pre></li><li>Függőségek. Itt sorolod fel hogy milyen egyéb csomagokat használsz még:<pre class="margin-bottom-1"><code class="json hljs"><span class="hljs-string">"dependencies"</span>: {...}</code></pre></li><li>A függőségre egy példa, itt legalább 2.0.x verzió kell az async csomagból:<pre class="margin-bottom-1"><code class="json hljs"><span class="hljs-string">"async"</span>: <span class="hljs-string">"^2.0.1"</span>,
      </code></pre></li></ul><h2>Verziók</h2><p>Azt, hogy egy csomagnak melyik verziójára van szükséged, egy számmal kell megadnod, ami három részből áll:</p><p><code>[major version].[minor version].[patch]</code></p><p><strong>major version:</strong> a program főverziója, ez általában az előző verziókkal visszafelé nem kompatibilis és komoly fejlesztéseket tartalmaz. Például amikor kiadnak egy új szoftvert vagy csomagot, akkor azt az <code>1.0.0</code> verzióval szokták. Amikor pedig komony fejlesztések történnek, akkor léptetik a major, vagy főverziót, és lesz belőle <code>2.0.0</code>, <code>3.0.0</code> és így tovább.</p><p><strong>minor version:</strong> ez egy kisebb lépés, például kisebb fejlesztéseket tartalmaz. Fontos, hogy általában a kompatibilitást nem töri meg. Tehát ha te egy alkalmazást készítettél az <code>1.3.4</code> verzióhoz, az valószínűleg futni fog az <code>1.5.2</code> verzión is.</p><p><strong>patch:</strong> hibajavítás, a program működését érdemben nem befolyásolja.</p><p><strong>NPM jelölések:</strong> az NPM-nél lehet tenni egy jelet a verziszám elé, ami azt jelenti, hogy milyen frissítéseket engedsz meg a csomagoknál.</p><ul><li><code>~</code> : ez a tilde (altGr + 1), azt jelenti, hogy csak a patch-et engeded meg. Ha így adod meg a csomagot: <code>"lodash": "~2.4.1"</code>, akkor ha kijön egy <code>2.4.7</code> verió, akkor frissülni fog, de ha a csomag a <code>2.5.1</code> verzióra lép, akkor már nem. Magyarul, csak az utolsó szám változhat.</li><li><code>^</code> : ez a caret(altGr + 3 + space), azt jelenti, hogy a minor verziót lehet léptetni. Tehát a kisebb fejlesztések is jöhetnek. Ha így adod meg a csomagot: <code>"lodash": "^2.4.1"</code>, akkor ha kijön egy <code>2.9.1</code> verió, akkor frissülni fog, de ha a csomag a <code>3.0.1</code> verzióra lép, akkor már nem. Magyarul, a második és a harmadik szám is változhat.</li></ul><h2>Remove</h2><p>A remove utasítással lehet a csomagokat eltávolítani, és itt is megy a <code>--save</code> flag, azaz ha benne volt a csomag a package.json-ban, akkor onnan is eltávolítja:</p><p></p><pre><code class="plaintext hljs">npm remove lodash
      </code></pre><p></p><h2>Dokumentáció</h2><p><a href="https://docs.npmjs.com/getting-started/using-a-package.json" rel="noopener noreferrer" target="_blank">Package.json</a></p></div>

    <h2>A json-server használata</h2>

    <div class="content"><h2>Szerver</h2><p>Eddig kizárólag frontend oldalon dolgoztunk, ami azt jelenti, hogy azokat a kódokat írtuk meg, amelyek a böngészőben futnak le. Most full-stack fejlesztő válik belőled, azaz képessé teszünk arra, hogy ne csak a frontend, hanem a szerver oldali kódokat is elkészítsd.</p><p>A szerver a szolga szóból jön, az a dolga, hogy a frontend felől jövő kéréseket kiszolgálja, azokra választ adjon. Ezek a válaszok lehetnek fájlok, adatok, JSON string-ek, bármi.</p><h2>json-server</h2><p>A json-server egy olyan NodeJS csomag, amivel egy perc alatt tudsz készíteni egy szervert, ami JSON válaszokat küld neked a kérésekre. Tökéletes választás, ha szeretnéd tesztelni az alkalmazásodban a klient-server kommunikációt.</p><h2>Telepítés</h2><ol class="list-strong"><li><span>Hozz létre egy mappát a projektednek.</span></li><li><span><code>npm init -y</code> : generáltasd le a package.json fájlt.</span></li><li><span><code>npm install -g json-server</code> : a json-server telepítése globálisan javasolt, mivel így tudod indítani a parancssorból is és elérhető lesz az összes projektedben.</span></li><li><p>Hozz létre egy JSON fájlt mondjuk <code>db.json</code> néven a kívánt tartalommal. Egy objektum legyen a gyökere, és ebben az egyes tulajdonságok tömbök. Ezek lesznek az adattáblák:</p><p></p><pre><code class="json hljs">{
        <span class="hljs-attr">"users"</span>: [
          { <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Big Tom"</span>, <span class="hljs-attr">"email"</span>: <span class="hljs-string">"bigtom@gmail.com"</span> },
          { <span class="hljs-attr">"id"</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Little Jimmy"</span>, <span class="hljs-attr">"email"</span>: <span class="hljs-string">"littlejimmy@gmail.com"</span> }
        ],
        <span class="hljs-attr">"comments"</span>: [
          { <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"body"</span>: <span class="hljs-string">"some comment"</span>, <span class="hljs-attr">"userId"</span>: <span class="hljs-number">1</span> }
        ]
      }</code></pre><p></p><blockquote><strong>Fontos: legyen mindegyik objektumban egy <code>id</code> tulajdonság és lehetőleg 1-gyel kezdődjön.</strong></blockquote></li><li><span><code>json-server --watch db.json</code> : figyeli a JSON fájlt a szerver, ha módosul. Ezenkívül elindul és lehet neki kéréseket küldeni. Ki fogja írni, hogy melyik proton fut, alapból a 3000 lesz, de ezt meg is változtathatod.</span></li><li><span>Nyisd meg a böngészőben: <code>http://localhost:3000/users</code>. Meg fogod kapni JSON formátumban a<code>users</code> tömböt, és már kezdheted is tesztelni az alkalmazásodat, hogyan tud együtt működni egy szerverrel.</span></li></ol><h2><code>README.md</code></h2><p>Ha rákeresel a json-server csomagra a GitHub-on, akkor találni fogsz részletes dokumentációt is. Érdemes ezt áttanulmányozni, mielőtt elakadnál. A github úgy működik, hogyha van a repóban egy <code>README.md</code> fájl a gyökérben, akkor alapból a fájlok alatt megjeleníti szépen formázva a tartalmát.</p><p><b>Légy önálló!</b> Ha valami nem működik először nézd meg a dokumentációt. Ha így sem megy, nézz utána a neten (Google a barátod). Ha még mindig nem, akkor kérdezz meg valaki tapasztaltabb szakembert a területen.</p><p>Mégegyszer a lépések baj esetén:</p><ol class="list-strong"><li><span>Dokumentáció</span></li><li><span>Google + Stack Overflow + stb. (netes keresések)</span></li><li><span>Kolléga, tanár, hozzáértő haver</span></li><li><span>Kapcsold ki a WoW-ot és aludj kicsit ;-)</span></li></ol><h2>Dokumentáció</h2><p><a href="https://github.com/typicode/json-server" rel="noopener noreferrer" target="_blank">json-server</a></p></div>

    <h2>A GET kérések használata</h2>

    <div class="content"><h2>GET</h2><p>A kliens - szerver modell arról szól, hogy küld a kliens egy kérést a szervernek, az pedig válaszol rá. A kérés a <code>Request</code> a válasz a <code>Response</code>.</p><h2>Get Request</h2><p>Egy get kérés így néz ki, a böngésző ezt küldi a szerver felé:</p><p><code>GET /images/logo.gif HTTP/1.1</code></p><p>Elemezzük kicsit:</p><ul><li><code>GET</code> : metódus, azaz hogy hogyan szeretné a kliens megkapni az adatokat a válaszban.</li><li><code>/images/logo.gif</code> : erőforrás, annak a címe amit kér, ez páldául egy .gif kép.</li><li><code>HTTP/1.1</code> : verzió, a HTTP szabvány melyik verziójával történik a kommunikáció.</li></ul><p>Ezt a teljesen egyszerű szöveges kérést küldi a böngésző a szervered felé.</p><p><strong>Header:</strong> a kérés része az első sor után következő haeader sorok. Ezek tövábbi adatokat tartalmaznak a kérésről és mindig <code>HEADER: VALUE</code> formában vannak megadva.</p><p></p><pre><code class="plaintext hljs">Host: origo.hu
        Connection: close
        User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.9) Gecko/2008052906 Firefox/3.0
        Accept-Charset: ISO-8859-1,UTF-8;q=0.7,*;q=0.7
        Cache-Control: no-cache
        Accept-Language: de,en;q=0.7,en-us;q=0.3</code></pre><p></p><p>Ebből néhány érdekeset kiemelnék:</p><ul><li><code>User-Agent</code> : a kliens által használt böngésző típusa.</li><li><code>Accept-Charset</code> : a böngésző milyen karakterkódolással tudja fogadni az adatokat.</li><li><code>Accept-Language</code> : a válasz nyelve milyen legyen.</li><li><code>Cache-Control</code> : azt határozza meg, hogy a kliens és szerver közti útvonalon kötelezően használjanak-e cache-elést, vagy sem.</li></ul><h2>Get Response</h2><p>Egy ilyen get kérésre a szerver ilyen választ szokott küldeni:</p><ul><li><code>HTTP/1.1 200 OK</code> : státusz, a válasz első sora. A státuszkód (jelent esetben 200) jelzi hogy mi lett a kérés eredménye. A 2xx, azaz a 2 -essel kezdődő sikeres kérést jelent.</li><li><code>HTTP/1.1 404 Not Found</code> : itt például nem volt sikeres a kérés, mert a kért erőforrás nem létezik. Ilyenkor kiegészülhet a válasz státusza egy szöveggel is, ami jelen esetben: <code>Not Found</code>.</li></ul><p>A Response is tartalmaz header sorokat, a Request -hez hasonlóan. És a header után jön a <code>BODY</code>, ami már a konkrét adat, amit a kliens kért a szervertől.</p><h2>Dokumentáció</h2><p><a href="https://hu.wikipedia.org/wiki/HTTP#K%C3%A9r%C3%A9s_(request)" rel="noopener noreferrer" target="_blank">Wiki, HTTP</a></p></div>

    <h2>Az elkészített szerver átadása</h2>

    <p>Kristóf sem úgy született, hogy értett a NodeJS-hez vagy az NPM-hez.<br>Viszont nem rest önállóan utánanézni azoknak a dolgoknak, amelyek elsőre esetleg nem teljesen világosak. Egy fejlesztőnél hatalmas előny, ha önállóan képes megoldani a problémákat, vagy utánanézni egy megoldásnak.</p>

    <h2>2. feladat - JSON adatok fogadása és lekezelése</h2>
    <p>Oké, hogy van egy szervered, de hogyan kapod meg onnan az adatokat?</p>

    <h2>A JSON definíciója</h2>

    <div class="content"><h2>JSON</h2><p>Azt jelenti, hogy JavaScript Object Notation. Egy szabványos adat leíró formátum, amivel egyszerűen lehet az adatokat küldeni alkamazások között vagy az interneten keresztül.</p><p>Tehát arra való, hogy adatot küldözgethess a szervernek, onnan is tudj fogadni dolgokat, sőt akár más programok is megértik. Ez nagyon jó.</p><h2>Hogyan épül fel?</h2><ul><li>Csak objektum vagy tömb lehet az alapja ([]{}).</li><li>Objektum esetén a kulcsokat és a string típusú értékeket is idézőjelek közé kell tenni ("").</li><li>Az érték csak string, number, boolean, JSON object, JSON array vagy null típusú lehet.</li><li>Ha muszáj idézőjeleket használni az értékekben, azt eszképelni kell (\).</li></ul><h2>Egy user JSON formátumban</h2><p></p><pre><code class="json hljs">{
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Handrix Gambler"</span>,
        <span class="hljs-attr">"age"</span>: <span class="hljs-number">44</span>,
        <span class="hljs-attr">"hobbies"</span>: [
          <span class="hljs-string">"poker"</span>,
          <span class="hljs-string">"blackjack"</span>
        ],
        <span class="hljs-attr">"serious"</span>: <span class="hljs-literal">true</span>
      }</code></pre><p></p><blockquote><strong>Fontos:</strong><ul><li>Az összes kulcsot idézőjelbe tettem (ez js-ben nem kötelező, de itt igen).</li><li>A String-et idézőjelbe kell tenni.</li><li>A Number, Boolean típusokat nem kell idézőjelbe tenni.</li></ul></blockquote><h2><code>JSON.parse()</code></h2><p>A <code>parse</code> metódussal tudod a JSON stringet újra objektummá alakítani.
      Tehát a JSON az egy string. Ha szeretnéd úgy használni a benne lévő adatokat, mint tömb vagy objektum elemeket, akkor vissza kell alakítani változóvá, hogy újra objektum legyen.</p><p><img class="shadow" src="./resources/json-parse.jpg" alt="json parse"></p><h2><code>JSON.stringify()</code></h2><p>A <code>stringify</code> metódussal pedig az objektumokat vagy tömböket lehet json-izálni.
      Ekkor készít belőlük egy JSON stringet a JS, ezt pedig küldhetjük a szervernek vagy másik alkalmazásnak is.</p><p><img class="shadow" src="./resources/json-stringify.jpg" alt="json str"></p><h2>Dokumentáció</h2><p><a href="https://www.w3schools.com/whatis/whatis_json.asp" rel="noopener noreferrer" target="_blank">JSON format</a></p></div>

    <h2>Az utasításvégrehajtás</h2>

    <div class="content"><h2>Az utasításvégrehajtás folyamata</h2><p><b>Mi is az az aszinkron művelet?</b></p><p>Eddig bármilyen utasításokat is adtunk ki, azok mindig a leírás sorrendjében, vagy legalább is kiszámítható sorrendben hajtódtak végre.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
        <span class="hljs-keyword">let</span> y = x * <span class="hljs-number">3</span> + x ** <span class="hljs-number">2</span>;
        <span class="hljs-built_in">console</span>.log(y);</code></pre><p></p><p>A végrehajtás sorrendje itt egyértelmű: először az <code>x</code> változó értéke 5 lesz, majd ki kell számítani ennek a négyzetét és a háromszorosát, utána ezeket össze kell adni, és az eredményt bele kell tenni az <code>y</code> nevű változóba. Legvégül kiírjuk az y értékét. A kód pillanatok alatt lefut, észre sem vesszük és már meg is jelenik az eredmény a konzolon.</p><p>Vannak azonban olyan műveletek, melyek nem hajthatóak végre ilyen gyorsan. Ilyen például egy időzítetten végrehajtott művelet és egy adatkérés egy szerverről. A JavaScript egy ún. non-blocking nyelv, mely azt jelenti, hogy a lassabb műveleteket másik szálon futtatja, így a következő utasítás akkor is elindul és végrehajtódik, ha a lassabb művelet még nem fejeződött be. Mivel előre nem tudhatjuk, hogy az így párhuzamosan futtatott <strong>aszinkron művelet</strong> mikor ér véget, ezért azt sem tudhatjuk, hogy annak eredménye mikor áll rendelkezésre.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> asyncCall = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-keyword">set</span><span class="hljs-title">Timeout</span>(<span class="hljs-params">(</span>) =&gt; {
            <span class="hljs-keyword">return</span> {<span class="hljs-attr">message</span>: <span class="hljs-string">"Ez egy időzített üzenet."</span>};
          }, <span class="hljs-number">2000</span>);
        };
        <span class="hljs-keyword">const</span> value = asyncCall();
        <span class="hljs-built_in">console</span>.log(value.message);</code></pre><p></p><p>Az <code>asyncCall</code> egy olyan függvény, amelynek a <code>return</code> utasítása időzítetten hajtódik végre, azaz a függvény meghívásától kezdve csak minimum 2 másodperccel később áll rendelkezésre. Sajnos azt tapasztaljuk, hogy a <code>console.log()</code> függvény előbb hajtódik végre, mint ahogy a <code>value</code> változó értéket kapna, ezért az "Uncaught TypeError: Cannot read property 'message' of undefined at &lt;anonymous&gt;:8:19" hibaüzenetet kapjuk. Miért is? Nézzük meg a lefutást idődiagrammon!</p><p class="img-container"><a href="async.png" target="_blank"><img src="./resources/async.png" alt="Aszinkron végrehajtás"></a></p><p>Láthatjuk, hogy a <code>setTimeout()</code> függvény hívása valahogy kikerült az utasítások sorából, és velük párhuzamosan fut le. Miután a fő szálon lévő összes utasítás lefutott, ez a mellékszál visszatérhet, és a visszaadott érték megjelenhet a fő szálon. De már késő, ezzel sajnos már nem tudunk mit kezdeni.</p><p>Ennek feloldására két megoldás is született:</p><ul><li>a <strong>callback</strong> függvények és</li><li>a <code>Promise</code> objektum.</li></ul></div>

    <h2>Callback függvények</h2>

    <div class="content"><h2>Callback függvény</h2><p>Az aszinkron művelet eredményét a fő szálban nem használhatjuk, de átadhatunk egy olyan függvényt az aszinkron műveletnek, melyet akkor fog meghívni, amikor befejezte a végrehajtást, és visszatérhet a fő szállba. Ezt a függvényt hívjuk <strong>callback függvénynek</strong>.</p><p>Tulajdonképpen a <code>button.addEventListener('click' buttonClickHandler)</code> utasításban a <code>buttonClickHandler</code> egy callback függvény, mely azután hajtódik végre, hogy a JavaScript kódunk már teljesen lefutott. Hogy azután mikor? Hát akkor, amikor a gombon kattintunk. Azonban addig, míg a fő szálon lévő utolsó utasítás is le nem futott, hiába kattintgatunk. Milyen sorrendben hajtódnak végre ezek az utasítások?</p><p></p><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buttonClickHandler</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title">console</span>.<span class="hljs-title">log</span>(<span class="hljs-params"><span class="hljs-string">'Kattintottál'</span></span>);
        <span class="hljs-title">const</span> <span class="hljs-title">button</span> = <span class="hljs-title">document</span>.<span class="hljs-title">querySelector</span>(<span class="hljs-params"><span class="hljs-string">'#submitButton'</span></span>);
        <span class="hljs-title">button</span>.<span class="hljs-title">addEventListener</span>(<span class="hljs-params"><span class="hljs-string">'click'</span>, buttonClickHandler</span>);
        ...
        <span class="hljs-title">console</span>.<span class="hljs-title">log</span>(<span class="hljs-params"><span class="hljs-string">'Utolsó utasítás'</span></span>);</span></code></pre><p></p><p>Lássuk a végrehajtás sorrendjét!</p><p class="img-container"><a href="./resources/callback.png" target="_blank"><img src="callback.png" alt="Callback függvény lefutása"></a></p><p>Mint látjuk, az eseménykezelő elindul a kattintáskor, az átadott <code>buttonClickHandler</code> callback függvény azonban csak akkor fut le, amikor már minden más utasítás végrehajtása befejeződött.</p></div>

    <h2>A Promise használata</h2>

    <div class="content"><h2><promise></promise></h2><p>A <code>Promise</code> egy aszinkron hívást körbeölelő objektum, amely a művelet aktuális állapotát hordozza magában. Minden <code>Promise</code> egyetlen egyszer futhat le, és a futás eredménye csak sikeres vagy sikertelen lehet. Az eredménytől függően képes a megfelelő <code>callback</code> metódusokat meghívni.</p><h2>Promise állapotok</h2><p>Egy promise a következő állapotokkal rendelkezhet:</p><ul><li><strong>fulfilled</strong> : vagyis teljesített, ha az aszinkron művelet sikeresen</li><li><strong>rejected</strong> : lefutott, ha az aszinkron művelet sikertelen volt</li><li><strong>pending</strong> : ha a művelet még fut</li><li><strong>settled</strong> : ha az aszinkron hívás már megtörtént, függetlenül a sikerességétől</li></ul><p>Az alábbi kép szépen szemlélteti a <code>Promise</code>-ok lefutását, állapotait:</p><p class="img-container"><img src="./resources/js-promise.svg" alt="Promise"></p><p>A specifikáció a <code>Promise</code> objektumoktól egyetlen metódust követel meg, a <code>then()</code>-t. Ez a függvény két <code>callback</code> paramétert vár melyeket attól függően hív meg, hogy milyen eredménnyel fog járni az aszinkron művelet.
        <a href="http://webprogramozas.inf.elte.hu/tananyag/weaf1/lecke9_lap1.html#hiv11" target="_blank">Forrás</a></p><p>Egy egyszerű példa:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
          <span class="hljs-keyword">set</span><span class="hljs-title">Timeout</span>(<span class="hljs-params">(</span>) =&gt; {
            reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">"Error message"</span>));
          }, <span class="hljs-number">3000</span>);
        });
        myPromise
          .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(data);
          })
          .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.error(err);
          });</code></pre><p></p><p>A <code>Promise</code>-nak két paramétert adtunk. Az egyik a <code>resolve</code>, a másik a <code>reject</code>. Mindkettő egy-egy függvény. A <code>resolve</code>-ot akkor hívjuk meg, ha megfelelően futott le a folyamat, a <code>reject</code>-et pedig akkor, ha valamilyen hiba történt. Ha bármelyik függvény meghívásra kerül, a <code>Promise</code> megszűnik létezni. Egy <code>Promise</code>-ra csak az egyiket lehet meghívni. Mindkettő függvény paraméterezhető is ha szükség van rá.</p><p>Nézzünk meg egy összetettebb példát is:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> datas = [
          { <span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">31</span> },
          { <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Jane"</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> },
          { <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Anonim"</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Anonymous"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">62</span> }
        ];
        
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postDataFunc</span>(<span class="hljs-params">age</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            <span class="hljs-keyword">set</span><span class="hljs-title">Timeout</span>(<span class="hljs-params">(</span>) =&gt; {
              <span class="hljs-keyword">const</span> post = datas.find(<span class="hljs-function"><span class="hljs-params">postdata</span> =&gt;</span> postdata.age === age);
              <span class="hljs-keyword">if</span> (post) {
                resolve(post);
              } <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">"Data not found"</span>));
              }
            }, <span class="hljs-number">3000</span>);
          });
        }
        
        postDataFunc(<span class="hljs-number">31</span>)
          .then(<span class="hljs-function"><span class="hljs-params">post</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(post);
            <span class="hljs-keyword">return</span> post;
          })
          .then(<span class="hljs-function"><span class="hljs-params">post</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Name:"</span>, post.firstName, post.lastName);
          })
          .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {    <span class="hljs-built_in">console</span>.error(err);  });
        <span class="hljs-comment">// Name: John Doe</span></code></pre><p></p><p>A fenti <code>Promise</code> már egy fokkal összetettebb.</p><ul><li>A <code>postDataFunc</code>-be megadunk egy életkort.</li><li>Ezen belül a <code>Promise</code>-nak megadjuk a <code>resolve</code>, és <code>reject</code> paramétereket.</li><li>Indítunk egy <code>setTimeout</code>-ot. Ez egy aszinkron művelet, ezt fogja körbe a <code>Promise</code>.</li><li>A <code>post</code> egy <code>boolean</code>, azaz hogy van e találatunk vagy nincs. Azaz megnézzük,hogy a tömbünkbe van e olyan objektum, ahol az <code>age</code> egyenlő a megadott értékkel.</li><li>Ha nem volt találatunk a <code>reject</code>-et hívjuk meg.</li><li>Ha volt találatunk a <code>resolve</code>-ot hívjuk meg.</li><li>Meghívjuk a függvényt jelenleg a 31 paraméterrel. A függvényünk visszatérési értéke a <code>Promise</code>.</li><li>Három másodperc múlva kiírja, hogy: <code>Name: John Doe</code>. (Ha nem talált akkor pedig: <data>not found</data>.)</li><li>A <code>catch</code> a hibakezelésre van.</li></ul><p>A következő példában egy újabb remek használatát láthatjátok a <code>Promise</code>-nak. Két <code>Promise</code> hozunk létre. A <code>Promise.all()</code> annyit tesz, hogy a paraméterként megadott, jelen esetben kettő darab <code>Promise</code>-ból egy darab összegyúrt <code>Promise</code>-t ad vissza. Ez az összetett <code>Promise</code> akkor lesz teljesített, ha a magába foglalt <code>Promise</code>-ok mindegyike lefutott.</p><p>Az alábbi példában az egyik 3 a másik 10 másodperc után fut le. Így a későbbi időpontban, tehát 10 másodperc múlva lesz mind a kettő teljesítve (Ne feledjük, aszinkron futnak!)</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
          <span class="hljs-keyword">set</span><span class="hljs-title">Timeout</span>(<span class="hljs-params">(</span>) =&gt; {
            resolve({
              <span class="hljs-attr">sound</span>: <span class="hljs-string">"miau"</span>,
              <span class="hljs-attr">loyal</span>: <span class="hljs-literal">false</span>
            });
          }, <span class="hljs-number">10000</span>);
        });
        <span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
          <span class="hljs-keyword">set</span><span class="hljs-title">Timeout</span>(<span class="hljs-params">(</span>) =&gt; {
            resolve({
              <span class="hljs-attr">sound</span>: <span class="hljs-string">"vau"</span>,
              <span class="hljs-attr">loyal</span>: <span class="hljs-literal">true</span>
            });
          }, <span class="hljs-number">3000</span>);
        });
        
        <span class="hljs-built_in">Promise</span>.all([cat, dog]).then(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> [catProps, dogProps] = responses;
          <span class="hljs-built_in">console</span>.log(catProps, dogProps);
        });
        </code></pre><p></p><h2>Dokumentáció</h2><p><a href="https://babeljs.io/learn-es2015/#ecmascript-2015-features-promises" rel="noopener noreferrer" target="_blank">Promise</a></p></div>

    <h2>Fetch API</h2>

    <div class="content"><h2>Fetch</h2><p>A <code>Fetch API</code> a még callback függ használó <code>XMLHttpRequest</code> kiváltására jött létre. Mind Google, mind Mozilla bácsi támogatja már a használatát. Különválasztották a kérést és a választ, valamint egyszerűbb a szintaxis, és könnyebb egyéni headeröket beállítani.</p><p>A gyakorlatbakérünk egy json formátumú adatot, és belerakjuk egy változóba. Figyeld meg, a <code>fecth()</code> egy <code>Promise</code>-szal tér vissza!</p><blockquote><b>Megjegyzés:</b> üzemelj be egy json-server-t, és annak küldd a kéréseket!</blockquote><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> fetchInit = {
        <span class="hljs-attr">method</span>: <span class="hljs-string">"GET"</span>,
        <span class="hljs-attr">headers</span>: <span class="hljs-keyword">new</span> Headers(),
        <span class="hljs-attr">mode</span>: <span class="hljs-string">"cors"</span>,
        <span class="hljs-attr">cache</span>: <span class="hljs-string">"default"</span>
      };
      <span class="hljs-keyword">const</span> fetchData = fetch(<span class="hljs-string">"http://localhost:3000/users"</span>, fetchInit);
      fetchData.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> data.json()).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data));</code></pre><p></p><h2>Kombináljuk!</h2><p>A <code>fetch()</code> egy <code>Promise</code>-szal tér vissza, amit bátran használunk is. Elkérjük a JSON-t, és feldolgozzuk, mint az imént:</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> postPromise = fetch(<span class="hljs-string">"http://localhost:3000/users"</span>);
      postPromise
        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> data.json())
        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
          <span class="hljs-built_in">console</span>.log(data);
        })
        .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
          <span class="hljs-built_in">console</span>.log(err);
        });
      </code></pre><p></p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener noreferrer" target="_blank">Fetch API</a></p></div>

      <h2>Az adatok fogadásának bemutatása</h2>
      <div class="content"><h2>Teljes kommunikáció</h2><p>Akkor hát jöjjön a full-stack élet. Régen azt mondták, úgy tanul a gyerek, ha kérdez. Én pedig úgy tapasztaltam, hogy úgy, ha utánoz. Tehát most nem fogom kódokkal alátámasztva elvenni a munkádat, hanem csak egy vázlatos instrukciót adok, hogy mit kell tenned ahhoz, hogy teljesen összeálljon a kliens-szerver buli. Hajrá hajrá...</p><h2>Szerver oldal</h2><p>Itt állíts be egy tesztszervert, ami szép JSON adatokat küld a kliensnek. A lépések mondjuk lehetnek ezek is:</p><ul><li>NPM project beállítása, package.json generálása.</li><li>json-server telepítése.</li><li>data.json fájl létrehozása és feltöltése dummy adatokkal (valami kitalált adat, lényeg hogy minél sokfélébb legyen a teszteléshez).</li><li>json-server indítása és tesztelése egyszerá böngészőben megnyitással, hogy mennek-e a végpontok?</li></ul><h2>Kliens oldal</h2><ul><li>HTML struktúra menüvel, lábléccel, hogy nézzen ki valahogy.</li><li>Egy táblázat az adatoknak, én üresen hagynám a <code>&lt;tbody&gt;&lt;/tbody&gt;</code> elemet, ezt majd a js kitölti a kapott adatokból.</li><li>Függvény, ami egy tömb alapján képes kitölteni a táblázatot adatsorokkal. Itt érdemes lehet a <code>document.createElement</code> és <code>.appendChild</code> metódusokat használni.</li><li>Fetch kérés indítása a json-server felé.</li><li>A kapott válasz tömbjét kéne átadni a függvénynek, ami a táblázatot generálja.</li><li>Ha minden oké, akkor szépen meg fognak jelenni az adatok a táblázatban.</li></ul><h2>Sok sikert!</h2></div>

    <h2>Az elkészített backend átadása</h2>

    <p>Ha Tamás is elégedett, akkor lehet bontani a pezsgőt.</p>

    <h1>DELETE, POST és PUT</h1>

    <h2>Az adminfelület véglegesítésével kapcsolatos igények megfogalmazása</h2>

    <p>Ez már a célegyenes.</p>

    <h2>1. feladat - Létrehozás, módosítás, törlés az adminfelületen</h2>

    <div class="content"><p>Kezd összeállni a CRUD:</p><p>Create<br>Read<br>Update<br>Delete</p><p>A négy fő művelet, amit az adatokon lehet végezni.</p></div>

    <h2>A szerveradatok módosításának áttekintése</h2>

    <div class="content"><p>A szerver mindig a megfelelő metódus alapján tudja, hogy épp a CRUD melyik műveletét szeretném elvégezni:</p><p>Create: POST<br>Read: GET<br>Update: PUT<br>Delete: DELETE</p></div>

    <h2>A szerver frontend előkészítése</h2>

    <div class="content"><p>Ebben a leckében meglévő elemekből építkezünk.</p><p>Itt a lista arról, amit érdemes átnézned:</p><ul><li>Fetch API használata</li><li>Bootstrap űrlapok és gombok</li></ul></div>

    <h2>A szerver frontend adatmegjelenítési logikájának elkészítése</h2>

    <div class="content"><p>Ebben a leckében meglévő elemekből építkezünk.</p><p>Itt a lista arról, amit érdemes átnézned:</p><ul><li>Ciklusok</li><li>DOM, elemek dinamikus létrehozása</li><li>Táblázatok generálása</li></ul></div>

    <h2>A szerver frontend adatmegjelenítésének véglegesítése</h2>

    <div class="content"><p>Amit érdemes lehet átnézni:</p><ul><li>DOM elemek létrehozása</li><li><code>document.createElement()</code> metódus</li></ul></div>

    <h2>A szerverfrontend gombjainak elkészítése</h2>

    <div class="content"><p>Nézd át ezeket is:</p><ul><li>Bootstrap alapok</li><li>Bootstrap gombok</li></ul></div>

    <h2>A DELETE metódus használata</h2>

    <div class="content"><h2>A DELETE metódus</h2><p>Ahogy a neve is mutatja, a DELETE metódus a HTTP szabványban az erőforrások törlésére van. Ha ilyen metódussal küldesz egy kérést a szervernek, akkor tudni fogja, hogy törölni szeretnél valamilyen adatot.</p><h2>Törlés a szerveren</h2><p>Adott valamilyen szerver, ami az adatokat szolgáltatja az alkalmazásodnak. Lépésről lépésre végigvezetlek a törlés folyamatán:</p><p><strong>Fetch kérés indítása a szerver felé:</strong></p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> fetchOptions = {
        <span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span>,
        <span class="hljs-attr">mode</span>: <span class="hljs-string">'cors'</span>,
        <span class="hljs-attr">cache</span>: <span class="hljs-string">'no-cache'</span>,
        <span class="hljs-attr">credentials</span>: <span class="hljs-string">'same-origin'</span>
      };
      fetch(<span class="hljs-string">"http://localhost:3000/users/"</span>+id, fetchOptions)
        .then( <span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.json() )
        .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json) );</code></pre><p></p><p><strong>Lehetséges válaszok:</strong></p><ul><li>Az adott erőforrás nem létezik:<br><code>DELETE http://localhost:3000/users/1 404 (Not Found)</code></li><li>Sikeres törlés esetén üres válasz: <code>{}</code></li></ul><h2>Biztonság</h2><p>Az adatok törlésénél körültekintően kell eljárnod. Az a minimum, hogy felteszel egy biztonsági kérdést, hogy tényleg törölni akarja-e az erőforrást a program kezelője?</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">if</span> (confirm(<span class="hljs-string">"Biztosan törli a felhasználót?"</span>)) {
        fetch(<span class="hljs-string">"http://localhost:3000/users/"</span>+id, fetchOptions)
          .then( <span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.json() )
          .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json) );
      }</code></pre><p></p><p>A <code>confirm()</code> metódus <code>true</code> értékkel tér vissza, ha az okét választották, egyébként <code>false</code> a visszatérési érték. Ezt vizsgálom egy <code>if</code> kifejezéssel. Azért nincs <code>else</code> ága az if-nek, mivel ha arra kattintottak, hogy mésgem, akkor nem kell csinálni semmit.</p><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener noreferrer" target="_blank">Fetch használata</a></p></div>

      <h2>A szülő adatok lekérdezése</h2>

      <div class="content"><p>Amit én átnéznék előtte:</p><ul><li><code>parentElement</code>, <code>parentNode</code></li></ul></div>

      <h2>Az oldal újratöltésének elkerülése</h2>

      <div class="content"><p>A beállításhoz itt találod a teljes dokumentációt:</p><p><code><a href="https://github.com/ritwickdey/vscode-live-server/blob/master/docs/settings.md" rel="noopener noreferrer" target="_blank">liveServer.settings.ignoreFiles</a></code></p></div>

      <h2>Új adatok beviteléhez beviteli mezők létrehozása</h2>

      <div class="content"><p>Amit érdemes lehet átnéni:</p><ul><li><a href="https://getbootstrap.com/docs/4.4/components/forms/" rel="noopener noreferrer" target="_blank">Bootstrap űrlapok</a></li><li><a href="https://getbootstrap.com/docs/4.4/components/buttons/" rel="noopener noreferrer" target="_blank">Bootstrap gombok</a></li></ul></div>

      <h2>Új adatok hozzáadása POST metódussal</h2>

      <div class="content"><h2>POST</h2><p>Ez feldolgozandó adatot küld fel a szerverre. Például HTML űrlap tartalmát, vagy egy fetch kérésben lévő adatokat. Az adatot az üzenettest tartalmazza.</p><h2>Új felhasználó létrehozása</h2><p>Ahhoz, hogy adatot küldj a szervernek, használhatod a <code>POST</code> vagy a <code>PUT</code> metódust is. Mindkettővel fel tudod tölteni az adatokat, a legtöbbször a szerver készítője mondja meg, hogy melyiket mikor használhatod. A mi példánkban a <code>POST</code>-ot használjuk a <code>Create</code> művelehtez, azaz új adatok létrehozásához.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> user = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Peter Big"</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>
      };
      <span class="hljs-keyword">let</span> fetchOptions = {
        <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
        <span class="hljs-attr">mode</span>: <span class="hljs-string">'cors'</span>,
        <span class="hljs-attr">cache</span>: <span class="hljs-string">'no-cache'</span>,
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
        },
        <span class="hljs-attr">credentials</span>: <span class="hljs-string">'same-origin'</span>,
        <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify( user )
      };
      fetch( <span class="hljs-string">"http://localhost:3000/users/"</span>, fetchOptions )
        .then( <span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.json() )
        .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json) );
      </code></pre><p></p><h2>Fontos megjegyzések!</h2><p>Nézd meg jól a kódot, mert lényeges különbségek vannak benne egy <code>GET</code> kéréshez képest.</p><ul><li>Létrehoztam egy <code>user</code> objektumot, ezt küldöm a szervernek.</li><li>A <code>fetchOptions</code> tartalmaz egy új tulajdonságot, <code>headers</code> a neve. Itt adtam meg, hogy <code>json</code> formátumban küldöm majd az adatokat, különben a szerver nem tudná feldolgozni őket.</li><li><code>body</code>: ez a tulajdonság adja meg az adatokat, amelyeket a szervenek fogok küldeni. Mivel azt mondtam a fejlécben, hogy <code>json</code> lesz a formátum, ezért a <code>user</code> objektumot <code>json</code> formátumra kell alakítanom.</li><li>A válaszban az újonnan létrejött usert kapom vissza. Az <code>id</code> tulajdonságot nem szokták megadni, mivel azt a szerver általában automatikusan hozza létre. A válasz így néz ki az én esetemben:<br><code>{name: "Peter Big", age: 21, id: 4}</code></li></ul><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener noreferrer" target="_blank">Fetch használata</a></p></div>

    <h2>Adatok frissítése PUT metódussal</h2>

    <div class="content"><h2>PUT kérés</h2><p>A  <code>PUT</code> kérések a megadott erőforrást feltöltik a szerverre. Ebből a szempontból nagyon hasonlóak a <code>POST</code> -hoz.</p><h2>Adatok módosítása</h2><p>Mi most a <code>PUT</code> kérést fogjuk az adatmódosításra használni. Ezért a <code>body</code>-ban, el fogjuk küldeni a szervernek a módosítandó adatokat, az url pedig az <code>id</code> mezőt is tartalmazni fogja, hogy meg tudja állapítani a szerver, hogy melyik felhasználót szeretnénk módosítani.</p><p></p><pre><code class="javascript hljs"><span class="hljs-keyword">let</span> user = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Micky Big"</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>
      };
      <span class="hljs-keyword">let</span> fetchOptions = {
        <span class="hljs-attr">method</span>: <span class="hljs-string">'PUT'</span>,
        <span class="hljs-attr">mode</span>: <span class="hljs-string">'cors'</span>,
        <span class="hljs-attr">cache</span>: <span class="hljs-string">'no-cache'</span>,
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
        },
        <span class="hljs-attr">credentials</span>: <span class="hljs-string">'same-origin'</span>,
        <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify( user )
      };
      fetch( <span class="hljs-string">"http://localhost:3000/users/3"</span>, fetchOptions )
        .then( <span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.json() )
        .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json) );</code></pre><p></p><p>A frissítés két dologban tér el a létrehozástól:</p><ul><li>A metódus <code>PUT</code>.</li><li>A <code>fetch</code> url végén meg kell adni az <code>id</code>-t, hogy tudja a szerver hogy melyik user-t kell módosítani.</li><li>Ezt a választ kaptam: <code>{name: "Micky Big", age: 21, id: 3}</code>, látod, az id változatlan, az adatok viszont módosultak.</li></ul><h2>Dokumentáció</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener noreferrer" target="_blank">Fetch használata</a></p></div>

    <h2>Adatbézis frissítő függvény elkészítése</h2>

    <div class="content"><p>Érdemes megnézni mielőtt hozzáfogsz:</p><ul><li>Fetch API</li><li><code>addEventListener</code></li><li><code>parentElement</code></li></ul></div>

    <h2>Az adatok elküldése a szervernek</h2>

    <div class="content"><p>Itt is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener noreferrer" target="_blank">Fetch API</a> ismerete a fontos.</p></div>

    <h2>A módosításokra képes adminfelület bemutatása</h2>

    <p>Így a vége felé al tudom képzelni, hogy Kristóf sem gondolta volna, hogy egyszer idáig el fog jutni.</p>

    <h2>Projektzáró megbeszélés</h2>

    <p>Gratulálunk Kristófnak.<br>De Te valószínűleg még nála is többet tudsz mostanra.</p>

    <h2>A véglegesített adminfelület átadása</h2>

    <p>Ez komoly volt, jöhetnek a következő projektek.</p>


</body>
</html>